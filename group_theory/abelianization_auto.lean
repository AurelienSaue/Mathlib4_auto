/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Michael Howes

The functor Grp → Ab which is the left adjoint
of the forgetful functor Ab → Grp.
-/
import PrePort
import Lean3Lib.init.default
import Mathlib.group_theory.quotient_group
import Mathlib.tactic.group
import PostPort

universes u v 

namespace Mathlib

-- let G be a group

/-- The commutator subgroup of a group G is the normal subgroup
  generated by the commutators [p,q]=`p*q*p⁻¹*q⁻¹` -/
def commutator (G : Type u) [group G] : subgroup G :=
  subgroup.normal_closure (set_of fun (x : G) => ∃ (p : G), ∃ (q : G), p * q * (p⁻¹) * (q⁻¹) = x)

/-- The abelianization of G is the quotient of G by its commutator subgroup -/
def abelianization (G : Type u) [group G]  :=
  quotient_group.quotient (commutator G)

namespace abelianization


protected instance comm_group (G : Type u) [group G] : comm_group (abelianization G) :=
  comm_group.mk group.mul sorry group.one sorry sorry group.inv group.div sorry sorry

protected instance inhabited (G : Type u) [group G] : Inhabited (abelianization G) :=
  { default := 1 }

/-- `of` is the canonical projection from G to its abelianization. -/
def of {G : Type u} [group G] : G →* abelianization G :=
  monoid_hom.mk quotient_group.mk sorry sorry

-- so far -- built Gᵃᵇ and proved it's an abelian group.

-- defined `of : G → Gᵃᵇ`

-- let A be an abelian group and let f be a group hom from G to A

theorem commutator_subset_ker {G : Type u} [group G] {A : Type v} [comm_group A] (f : G →* A) : commutator G ≤ monoid_hom.ker f := sorry

/-- If `f : G → A` is a group homomorphism to an abelian group, then `lift f` is the unique map from
  the abelianization of a `G` to `A` that factors through `f`. -/
def lift {G : Type u} [group G] {A : Type v} [comm_group A] (f : G →* A) : abelianization G →* A :=
  quotient_group.lift (commutator G) f sorry

@[simp] theorem lift.of {G : Type u} [group G] {A : Type v} [comm_group A] (f : G →* A) (x : G) : coe_fn (lift f) (coe_fn of x) = coe_fn f x :=
  rfl

theorem lift.unique {G : Type u} [group G] {A : Type v} [comm_group A] (f : G →* A) (φ : abelianization G →* A) (hφ : ∀ (x : G), coe_fn φ (coe_fn of x) = coe_fn f x) {x : abelianization G} : coe_fn φ x = coe_fn (lift f) x :=
  quotient_group.induction_on x hφ

/-- See note [partially-applied ext lemmas]. -/
theorem hom_ext {G : Type u} [group G] {A : Type v} [monoid A] (φ : abelianization G →* A) (ψ : abelianization G →* A) (h : monoid_hom.comp φ of = monoid_hom.comp ψ of) : φ = ψ := sorry

