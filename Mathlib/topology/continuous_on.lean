/-
Copyright (c) 2019 Reid Barton. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: S√©bastien Gou√´zel
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.topology.constructions
import Mathlib.PostPort

universes u_1 u_2 u_3 u_4 

namespace Mathlib

/-!
# Neighborhoods and continuity relative to a subset

This file defines relative versions

* `nhds_within`           of `nhds`
* `continuous_on`         of `continuous`
* `continuous_within_at`  of `continuous_at`

and proves their basic properties, including the relationships between
these restricted notions and the corresponding notions for the subtype
equipped with the subspace topology.

## Notation

* `ùìù x`: the filter of neighborhoods of a point `x`;
* `ùìü s`: the principal filter of a set `s`;
* `ùìù[s] x`: the filter `nhds_within x s` of neighborhoods of a point `x` within a set `s`.

-/

/-- The "neighborhood within" filter. Elements of `ùìù[s] a` are sets containing the
intersection of `s` and a neighborhood of `a`. -/
def nhds_within {Œ± : Type u_1} [topological_space Œ±] (a : Œ±) (s : set Œ±) : filter Œ± :=
  nhds a ‚äì filter.principal s

@[simp] theorem nhds_bind_nhds_within {Œ± : Type u_1} [topological_space Œ±] {a : Œ±} {s : set Œ±} : (filter.bind (nhds a) fun (x : Œ±) => nhds_within x s) = nhds_within a s :=
  Eq.trans filter.bind_inf_principal (congr_arg2 has_inf.inf nhds_bind_nhds rfl)

@[simp] theorem eventually_nhds_nhds_within {Œ± : Type u_1} [topological_space Œ±] {a : Œ±} {s : set Œ±} {p : Œ± ‚Üí Prop} : filter.eventually (fun (y : Œ±) => filter.eventually (fun (x : Œ±) => p x) (nhds_within y s)) (nhds a) ‚Üî
  filter.eventually (fun (x : Œ±) => p x) (nhds_within a s) :=
  iff.mp filter.ext_iff nhds_bind_nhds_within (set_of fun (x : Œ±) => p x)

theorem eventually_nhds_within_iff {Œ± : Type u_1} [topological_space Œ±] {a : Œ±} {s : set Œ±} {p : Œ± ‚Üí Prop} : filter.eventually (fun (x : Œ±) => p x) (nhds_within a s) ‚Üî filter.eventually (fun (x : Œ±) => x ‚àà s ‚Üí p x) (nhds a) :=
  filter.eventually_inf_principal

@[simp] theorem eventually_nhds_within_nhds_within {Œ± : Type u_1} [topological_space Œ±] {a : Œ±} {s : set Œ±} {p : Œ± ‚Üí Prop} : filter.eventually (fun (y : Œ±) => filter.eventually (fun (x : Œ±) => p x) (nhds_within y s)) (nhds_within a s) ‚Üî
  filter.eventually (fun (x : Œ±) => p x) (nhds_within a s) := sorry

theorem nhds_within_eq {Œ± : Type u_1} [topological_space Œ±] (a : Œ±) (s : set Œ±) : nhds_within a s =
  infi fun (t : set Œ±) => infi fun (H : t ‚àà set_of fun (t : set Œ±) => a ‚àà t ‚àß is_open t) => filter.principal (t ‚à© s) :=
  filter.has_basis.eq_binfi (filter.has_basis.inf_principal (nhds_basis_opens a) s)

theorem nhds_within_univ {Œ± : Type u_1} [topological_space Œ±] (a : Œ±) : nhds_within a set.univ = nhds a :=
  eq.mpr (id (Eq._oldrec (Eq.refl (nhds_within a set.univ = nhds a)) (nhds_within.equations._eqn_1 a set.univ)))
    (eq.mpr (id (Eq._oldrec (Eq.refl (nhds a ‚äì filter.principal set.univ = nhds a)) filter.principal_univ))
      (eq.mpr (id (Eq._oldrec (Eq.refl (nhds a ‚äì ‚ä§ = nhds a)) inf_top_eq)) (Eq.refl (nhds a))))

theorem nhds_within_has_basis {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] {p : Œ≤ ‚Üí Prop} {s : Œ≤ ‚Üí set Œ±} {a : Œ±} (h : filter.has_basis (nhds a) p s) (t : set Œ±) : filter.has_basis (nhds_within a t) p fun (i : Œ≤) => s i ‚à© t :=
  filter.has_basis.inf_principal h t

theorem nhds_within_basis_open {Œ± : Type u_1} [topological_space Œ±] (a : Œ±) (t : set Œ±) : filter.has_basis (nhds_within a t) (fun (u : set Œ±) => a ‚àà u ‚àß is_open u) fun (u : set Œ±) => u ‚à© t :=
  nhds_within_has_basis (nhds_basis_opens a) t

theorem mem_nhds_within {Œ± : Type u_1} [topological_space Œ±] {t : set Œ±} {a : Œ±} {s : set Œ±} : t ‚àà nhds_within a s ‚Üî ‚àÉ (u : set Œ±), is_open u ‚àß a ‚àà u ‚àß u ‚à© s ‚äÜ t := sorry

theorem mem_nhds_within_iff_exists_mem_nhds_inter {Œ± : Type u_1} [topological_space Œ±] {t : set Œ±} {a : Œ±} {s : set Œ±} : t ‚àà nhds_within a s ‚Üî ‚àÉ (u : set Œ±), ‚àÉ (H : u ‚àà nhds a), u ‚à© s ‚äÜ t :=
  filter.has_basis.mem_iff (nhds_within_has_basis (filter.basis_sets (nhds a)) s)

theorem diff_mem_nhds_within_compl {X : Type u_1} [topological_space X] {x : X} {s : set X} (hs : s ‚àà nhds x) (t : set X) : s \ t ‚àà nhds_within x (t·∂ú) :=
  filter.diff_mem_inf_principal_compl hs t

theorem nhds_of_nhds_within_of_nhds {Œ± : Type u_1} [topological_space Œ±] {s : set Œ±} {t : set Œ±} {a : Œ±} (h1 : s ‚àà nhds a) (h2 : t ‚àà nhds_within a s) : t ‚àà nhds a := sorry

theorem mem_nhds_within_of_mem_nhds {Œ± : Type u_1} [topological_space Œ±] {s : set Œ±} {t : set Œ±} {a : Œ±} (h : s ‚àà nhds a) : s ‚àà nhds_within a t :=
  filter.mem_inf_sets_of_left h

theorem self_mem_nhds_within {Œ± : Type u_1} [topological_space Œ±] {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a s :=
  filter.mem_inf_sets_of_right (filter.mem_principal_self s)

theorem inter_mem_nhds_within {Œ± : Type u_1} [topological_space Œ±] (s : set Œ±) {t : set Œ±} {a : Œ±} (h : t ‚àà nhds a) : s ‚à© t ‚àà nhds_within a s :=
  filter.inter_mem_sets (filter.mem_inf_sets_of_right (filter.mem_principal_self s)) (filter.mem_inf_sets_of_left h)

theorem nhds_within_mono {Œ± : Type u_1} [topological_space Œ±] (a : Œ±) {s : set Œ±} {t : set Œ±} (h : s ‚äÜ t) : nhds_within a s ‚â§ nhds_within a t :=
  inf_le_inf_left (nhds a) (iff.mpr filter.principal_mono h)

theorem pure_le_nhds_within {Œ± : Type u_1} [topological_space Œ±] {a : Œ±} {s : set Œ±} (ha : a ‚àà s) : pure a ‚â§ nhds_within a s :=
  le_inf (pure_le_nhds a) (iff.mpr filter.le_principal_iff ha)

theorem mem_of_mem_nhds_within {Œ± : Type u_1} [topological_space Œ±] {a : Œ±} {s : set Œ±} {t : set Œ±} (ha : a ‚àà s) (ht : t ‚àà nhds_within a s) : a ‚àà t :=
  pure_le_nhds_within ha ht

theorem filter.eventually.self_of_nhds_within {Œ± : Type u_1} [topological_space Œ±] {p : Œ± ‚Üí Prop} {s : set Œ±} {x : Œ±} (h : filter.eventually (fun (y : Œ±) => p y) (nhds_within x s)) (hx : x ‚àà s) : p x :=
  mem_of_mem_nhds_within hx h

theorem tendsto_const_nhds_within {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] {l : filter Œ≤} {s : set Œ±} {a : Œ±} (ha : a ‚àà s) : filter.tendsto (fun (x : Œ≤) => a) l (nhds_within a s) :=
  filter.tendsto.mono_right filter.tendsto_const_pure (pure_le_nhds_within ha)

theorem nhds_within_restrict'' {Œ± : Type u_1} [topological_space Œ±] {a : Œ±} (s : set Œ±) {t : set Œ±} (h : t ‚àà nhds_within a s) : nhds_within a s = nhds_within a (s ‚à© t) :=
  le_antisymm (le_inf inf_le_left (iff.mpr filter.le_principal_iff (filter.inter_mem_sets self_mem_nhds_within h)))
    (inf_le_inf_left (nhds a) (iff.mpr filter.principal_mono (set.inter_subset_left s t)))

theorem nhds_within_restrict' {Œ± : Type u_1} [topological_space Œ±] {a : Œ±} (s : set Œ±) {t : set Œ±} (h : t ‚àà nhds a) : nhds_within a s = nhds_within a (s ‚à© t) :=
  nhds_within_restrict'' s (filter.mem_inf_sets_of_left h)

theorem nhds_within_restrict {Œ± : Type u_1} [topological_space Œ±] {a : Œ±} (s : set Œ±) {t : set Œ±} (h‚ÇÄ : a ‚àà t) (h‚ÇÅ : is_open t) : nhds_within a s = nhds_within a (s ‚à© t) :=
  nhds_within_restrict' s (mem_nhds_sets h‚ÇÅ h‚ÇÄ)

theorem nhds_within_le_of_mem {Œ± : Type u_1} [topological_space Œ±] {a : Œ±} {s : set Œ±} {t : set Œ±} (h : s ‚àà nhds_within a t) : nhds_within a t ‚â§ nhds_within a s := sorry

theorem nhds_within_eq_nhds_within {Œ± : Type u_1} [topological_space Œ±] {a : Œ±} {s : set Œ±} {t : set Œ±} {u : set Œ±} (h‚ÇÄ : a ‚àà s) (h‚ÇÅ : is_open s) (h‚ÇÇ : t ‚à© s = u ‚à© s) : nhds_within a t = nhds_within a u := sorry

theorem nhds_within_eq_of_open {Œ± : Type u_1} [topological_space Œ±] {a : Œ±} {s : set Œ±} (h‚ÇÄ : a ‚àà s) (h‚ÇÅ : is_open s) : nhds_within a s = nhds a :=
  iff.mpr inf_eq_left (iff.mpr filter.le_principal_iff (mem_nhds_sets h‚ÇÅ h‚ÇÄ))

@[simp] theorem nhds_within_empty {Œ± : Type u_1} [topological_space Œ±] (a : Œ±) : nhds_within a ‚àÖ = ‚ä• :=
  eq.mpr (id (Eq._oldrec (Eq.refl (nhds_within a ‚àÖ = ‚ä•)) (nhds_within.equations._eqn_1 a ‚àÖ)))
    (eq.mpr (id (Eq._oldrec (Eq.refl (nhds a ‚äì filter.principal ‚àÖ = ‚ä•)) filter.principal_empty))
      (eq.mpr (id (Eq._oldrec (Eq.refl (nhds a ‚äì ‚ä• = ‚ä•)) inf_bot_eq)) (Eq.refl ‚ä•)))

theorem nhds_within_union {Œ± : Type u_1} [topological_space Œ±] (a : Œ±) (s : set Œ±) (t : set Œ±) : nhds_within a (s ‚à™ t) = nhds_within a s ‚äî nhds_within a t := sorry

theorem nhds_within_inter {Œ± : Type u_1} [topological_space Œ±] (a : Œ±) (s : set Œ±) (t : set Œ±) : nhds_within a (s ‚à© t) = nhds_within a s ‚äì nhds_within a t := sorry

theorem nhds_within_inter' {Œ± : Type u_1} [topological_space Œ±] (a : Œ±) (s : set Œ±) (t : set Œ±) : nhds_within a (s ‚à© t) = nhds_within a s ‚äì filter.principal t := sorry

@[simp] theorem nhds_within_singleton {Œ± : Type u_1} [topological_space Œ±] (a : Œ±) : nhds_within a (singleton a) = pure a := sorry

@[simp] theorem nhds_within_insert {Œ± : Type u_1} [topological_space Œ±] (a : Œ±) (s : set Œ±) : nhds_within a (insert a s) = pure a ‚äî nhds_within a s := sorry

theorem mem_nhds_within_insert {Œ± : Type u_1} [topological_space Œ±] {a : Œ±} {s : set Œ±} {t : set Œ±} : t ‚àà nhds_within a (insert a s) ‚Üî a ‚àà t ‚àß t ‚àà nhds_within a s := sorry

theorem insert_mem_nhds_within_insert {Œ± : Type u_1} [topological_space Œ±] {a : Œ±} {s : set Œ±} {t : set Œ±} (h : t ‚àà nhds_within a s) : insert a t ‚àà nhds_within a (insert a s) := sorry

theorem nhds_within_prod_eq {Œ± : Type u_1} [topological_space Œ±] {Œ≤ : Type u_2} [topological_space Œ≤] (a : Œ±) (b : Œ≤) (s : set Œ±) (t : set Œ≤) : nhds_within (a, b) (set.prod s t) = filter.prod (nhds_within a s) (nhds_within b t) := sorry

theorem nhds_within_prod {Œ± : Type u_1} [topological_space Œ±] {Œ≤ : Type u_2} [topological_space Œ≤] {s : set Œ±} {u : set Œ±} {t : set Œ≤} {v : set Œ≤} {a : Œ±} {b : Œ≤} (hu : u ‚àà nhds_within a s) (hv : v ‚àà nhds_within b t) : set.prod u v ‚àà nhds_within (a, b) (set.prod s t) :=
  eq.mpr (id (Eq._oldrec (Eq.refl (set.prod u v ‚àà nhds_within (a, b) (set.prod s t))) (nhds_within_prod_eq a b s t)))
    (filter.prod_mem_prod hu hv)

theorem tendsto_if_nhds_within {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} {p : Œ± ‚Üí Prop} [decidable_pred p] {a : Œ±} {s : set Œ±} {l : filter Œ≤} (h‚ÇÄ : filter.tendsto f (nhds_within a (s ‚à© p)) l) (h‚ÇÅ : filter.tendsto g (nhds_within a (s ‚à© set_of fun (x : Œ±) => ¬¨p x)) l) : filter.tendsto (fun (x : Œ±) => ite (p x) (f x) (g x)) (nhds_within a s) l := sorry

theorem map_nhds_within {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] (f : Œ± ‚Üí Œ≤) (a : Œ±) (s : set Œ±) : filter.map f (nhds_within a s) =
  infi
    fun (t : set Œ±) => infi fun (H : t ‚àà set_of fun (t : set Œ±) => a ‚àà t ‚àß is_open t) => filter.principal (f '' (t ‚à© s)) :=
  filter.has_basis.eq_binfi (filter.has_basis.map f (nhds_within_basis_open a s))

theorem tendsto_nhds_within_mono_left {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] {f : Œ± ‚Üí Œ≤} {a : Œ±} {s : set Œ±} {t : set Œ±} {l : filter Œ≤} (hst : s ‚äÜ t) (h : filter.tendsto f (nhds_within a t) l) : filter.tendsto f (nhds_within a s) l :=
  filter.tendsto.mono_left h (nhds_within_mono a hst)

theorem tendsto_nhds_within_mono_right {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] {f : Œ≤ ‚Üí Œ±} {l : filter Œ≤} {a : Œ±} {s : set Œ±} {t : set Œ±} (hst : s ‚äÜ t) (h : filter.tendsto f l (nhds_within a s)) : filter.tendsto f l (nhds_within a t) :=
  filter.tendsto.mono_right h (nhds_within_mono a hst)

theorem tendsto_nhds_within_of_tendsto_nhds {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] {f : Œ± ‚Üí Œ≤} {a : Œ±} {s : set Œ±} {l : filter Œ≤} (h : filter.tendsto f (nhds a) l) : filter.tendsto f (nhds_within a s) l :=
  filter.tendsto.mono_left h inf_le_left

theorem principal_subtype {Œ± : Type u_1} (s : set Œ±) (t : set (Subtype fun (x : Œ±) => x ‚àà s)) : filter.principal t = filter.comap coe (filter.principal (coe '' t)) := sorry

theorem mem_closure_iff_nhds_within_ne_bot {Œ± : Type u_1} [topological_space Œ±] {s : set Œ±} {x : Œ±} : x ‚àà closure s ‚Üî filter.ne_bot (nhds_within x s) :=
  mem_closure_iff_cluster_pt

theorem nhds_within_ne_bot_of_mem {Œ± : Type u_1} [topological_space Œ±] {s : set Œ±} {x : Œ±} (hx : x ‚àà s) : filter.ne_bot (nhds_within x s) :=
  iff.mp mem_closure_iff_nhds_within_ne_bot (subset_closure hx)

theorem is_closed.mem_of_nhds_within_ne_bot {Œ± : Type u_1} [topological_space Œ±] {s : set Œ±} (hs : is_closed s) {x : Œ±} (hx : filter.ne_bot (nhds_within x s)) : x ‚àà s := sorry

theorem dense_range.nhds_within_ne_bot {Œ± : Type u_1} [topological_space Œ±] {Œπ : Type u_2} {f : Œπ ‚Üí Œ±} (h : dense_range f) (x : Œ±) : filter.ne_bot (nhds_within x (set.range f)) :=
  iff.mp mem_closure_iff_cluster_pt (h x)

theorem eventually_eq_nhds_within_iff {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} : filter.eventually_eq (nhds_within a s) f g ‚Üî filter.eventually (fun (x : Œ±) => x ‚àà s ‚Üí f x = g x) (nhds a) :=
  filter.mem_inf_principal

theorem eventually_eq_nhds_within_of_eq_on {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} (h : set.eq_on f g s) : filter.eventually_eq (nhds_within a s) f g :=
  filter.mem_inf_sets_of_right h

theorem set.eq_on.eventually_eq_nhds_within {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} (h : set.eq_on f g s) : filter.eventually_eq (nhds_within a s) f g :=
  eventually_eq_nhds_within_of_eq_on h

theorem tendsto_nhds_within_congr {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} {l : filter Œ≤} (hfg : ‚àÄ (x : Œ±), x ‚àà s ‚Üí f x = g x) (hf : filter.tendsto f (nhds_within a s) l) : filter.tendsto g (nhds_within a s) l :=
  iff.mp (filter.tendsto_congr' (eventually_eq_nhds_within_of_eq_on hfg)) hf

theorem eventually_nhds_with_of_forall {Œ± : Type u_1} [topological_space Œ±] {s : set Œ±} {a : Œ±} {p : Œ± ‚Üí Prop} (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí p x) : filter.eventually (fun (x : Œ±) => p x) (nhds_within a s) :=
  filter.mem_inf_sets_of_right h

theorem tendsto_nhds_within_of_tendsto_nhds_of_eventually_within {Œ± : Type u_1} [topological_space Œ±] {Œ≤ : Type u_2} {a : Œ±} {l : filter Œ≤} {s : set Œ±} (f : Œ≤ ‚Üí Œ±) (h1 : filter.tendsto f l (nhds a)) (h2 : filter.eventually (fun (x : Œ≤) => f x ‚àà s) l) : filter.tendsto f l (nhds_within a s) :=
  iff.mpr filter.tendsto_inf { left := h1, right := iff.mpr filter.tendsto_principal h2 }

theorem filter.eventually_eq.eq_of_nhds_within {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] {s : set Œ±} {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} {a : Œ±} (h : filter.eventually_eq (nhds_within a s) f g) (hmem : a ‚àà s) : f a = g a :=
  filter.eventually.self_of_nhds_within h hmem

theorem eventually_nhds_within_of_eventually_nhds {Œ± : Type u_1} [topological_space Œ±] {s : set Œ±} {a : Œ±} {p : Œ± ‚Üí Prop} (h : filter.eventually (fun (x : Œ±) => p x) (nhds a)) : filter.eventually (fun (x : Œ±) => p x) (nhds_within a s) :=
  mem_nhds_within_of_mem_nhds h

/-!
### `nhds_within` and subtypes
-/

theorem mem_nhds_within_subtype {Œ± : Type u_1} [topological_space Œ±] {s : set Œ±} {a : Subtype fun (x : Œ±) => x ‚àà s} {t : set (Subtype fun (x : Œ±) => x ‚àà s)} {u : set (Subtype fun (x : Œ±) => x ‚àà s)} : t ‚àà nhds_within a u ‚Üî t ‚àà filter.comap coe (nhds_within (‚Üëa) (coe '' u)) := sorry

theorem nhds_within_subtype {Œ± : Type u_1} [topological_space Œ±] (s : set Œ±) (a : Subtype fun (x : Œ±) => x ‚àà s) (t : set (Subtype fun (x : Œ±) => x ‚àà s)) : nhds_within a t = filter.comap coe (nhds_within (‚Üëa) (coe '' t)) :=
  filter.ext fun (u : set (Subtype fun (x : Œ±) => x ‚àà s)) => mem_nhds_within_subtype

theorem nhds_within_eq_map_subtype_coe {Œ± : Type u_1} [topological_space Œ±] {s : set Œ±} {a : Œ±} (h : a ‚àà s) : nhds_within a s = filter.map coe (nhds { val := a, property := h }) := sorry

theorem tendsto_nhds_within_iff_subtype {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] {s : set Œ±} {a : Œ±} (h : a ‚àà s) (f : Œ± ‚Üí Œ≤) (l : filter Œ≤) : filter.tendsto f (nhds_within a s) l ‚Üî filter.tendsto (set.restrict f s) (nhds { val := a, property := h }) l := sorry

/-- A function between topological spaces is continuous at a point `x‚ÇÄ` within a subset `s`
if `f x` tends to `f x‚ÇÄ` when `x` tends to `x‚ÇÄ` while staying within `s`. -/
def continuous_within_at {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) (x : Œ±) :=
  filter.tendsto f (nhds_within x s) (nhds (f x))

/-- If a function is continuous within `s` at `x`, then it tends to `f x` within `s` by definition.
We register this fact for use with the dot notation, especially to use `tendsto.comp` as
`continuous_within_at.comp` will have a different meaning. -/
theorem continuous_within_at.tendsto {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {x : Œ±} (h : continuous_within_at f s x) : filter.tendsto f (nhds_within x s) (nhds (f x)) :=
  h

/-- A function between topological spaces is continuous on a subset `s`
when it's continuous at every point of `s` within `s`. -/
def continuous_on {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) (s : set Œ±) :=
  ‚àÄ (x : Œ±), x ‚àà s ‚Üí continuous_within_at f s x

theorem continuous_on.continuous_within_at {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {x : Œ±} (hf : continuous_on f s) (hx : x ‚àà s) : continuous_within_at f s x :=
  hf x hx

theorem continuous_within_at_univ {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) (x : Œ±) : continuous_within_at f set.univ x ‚Üî continuous_at f x := sorry

theorem continuous_within_at_iff_continuous_at_restrict {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) {x : Œ±} {s : set Œ±} (h : x ‚àà s) : continuous_within_at f s x ‚Üî continuous_at (set.restrict f s) { val := x, property := h } :=
  tendsto_nhds_within_iff_subtype h f (nhds (f x))

theorem continuous_within_at.tendsto_nhds_within {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} {s : set Œ±} {t : set Œ≤} (h : continuous_within_at f s x) (ht : set.maps_to f s t) : filter.tendsto f (nhds_within x s) (nhds_within (f x) t) :=
  iff.mpr filter.tendsto_inf
    { left := h,
      right := iff.mpr filter.tendsto_principal (filter.mem_inf_sets_of_right (iff.mpr filter.mem_principal_sets ht)) }

theorem continuous_within_at.tendsto_nhds_within_image {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} {s : set Œ±} (h : continuous_within_at f s x) : filter.tendsto f (nhds_within x s) (nhds_within (f x) (f '' s)) :=
  continuous_within_at.tendsto_nhds_within h (set.maps_to_image f s)

theorem continuous_within_at.prod_map {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] [topological_space Œ¥] {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ¥} {s : set Œ±} {t : set Œ≤} {x : Œ±} {y : Œ≤} (hf : continuous_within_at f s x) (hg : continuous_within_at g t y) : continuous_within_at (prod.map f g) (set.prod s t) (x, y) := sorry

theorem continuous_on_iff {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} : continuous_on f s ‚Üî
  ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÄ (t : set Œ≤), is_open t ‚Üí f x ‚àà t ‚Üí ‚àÉ (u : set Œ±), is_open u ‚àß x ‚àà u ‚àß u ‚à© s ‚äÜ f ‚Åª¬π' t := sorry

theorem continuous_on_iff_continuous_restrict {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} : continuous_on f s ‚Üî continuous (set.restrict f s) := sorry

theorem continuous_on_iff' {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} : continuous_on f s ‚Üî ‚àÄ (t : set Œ≤), is_open t ‚Üí ‚àÉ (u : set Œ±), is_open u ‚àß f ‚Åª¬π' t ‚à© s = u ‚à© s := sorry

theorem continuous_on_iff_is_closed {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} : continuous_on f s ‚Üî ‚àÄ (t : set Œ≤), is_closed t ‚Üí ‚àÉ (u : set Œ±), is_closed u ‚àß f ‚Åª¬π' t ‚à© s = u ‚à© s := sorry

theorem continuous_on.prod_map {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] [topological_space Œ¥] {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ¥} {s : set Œ±} {t : set Œ≤} (hf : continuous_on f s) (hg : continuous_on g t) : continuous_on (prod.map f g) (set.prod s t) := sorry

theorem continuous_on_empty {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) : continuous_on f ‚àÖ :=
  fun (x : Œ±) => false.elim

theorem nhds_within_le_comap {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {x : Œ±} {s : set Œ±} {f : Œ± ‚Üí Œ≤} (ctsf : continuous_within_at f s x) : nhds_within x s ‚â§ filter.comap f (nhds_within (f x) (f '' s)) :=
  iff.mp filter.map_le_iff_le_comap (continuous_within_at.tendsto_nhds_within_image ctsf)

theorem continuous_within_at_iff_ptendsto_res {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤) {x : Œ±} {s : set Œ±} : continuous_within_at f s x ‚Üî filter.ptendsto (pfun.res f s) (nhds x) (nhds (f x)) :=
  filter.tendsto_iff_ptendsto (nhds x) (nhds (f x)) s f

theorem continuous_iff_continuous_on_univ {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} : continuous f ‚Üî continuous_on f set.univ := sorry

theorem continuous_within_at.mono {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {t : set Œ±} {x : Œ±} (h : continuous_within_at f t x) (hs : s ‚äÜ t) : continuous_within_at f s x :=
  filter.tendsto.mono_left h (nhds_within_mono x hs)

theorem continuous_within_at.mono_of_mem {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {t : set Œ±} {x : Œ±} (h : continuous_within_at f t x) (hs : t ‚àà nhds_within x s) : continuous_within_at f s x :=
  filter.tendsto.mono_left h (nhds_within_le_of_mem hs)

theorem continuous_within_at_inter' {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {t : set Œ±} {x : Œ±} (h : t ‚àà nhds_within x s) : continuous_within_at f (s ‚à© t) x ‚Üî continuous_within_at f s x := sorry

theorem continuous_within_at_inter {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {t : set Œ±} {x : Œ±} (h : t ‚àà nhds x) : continuous_within_at f (s ‚à© t) x ‚Üî continuous_within_at f s x := sorry

theorem continuous_within_at_union {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {t : set Œ±} {x : Œ±} : continuous_within_at f (s ‚à™ t) x ‚Üî continuous_within_at f s x ‚àß continuous_within_at f t x := sorry

theorem continuous_within_at.union {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {t : set Œ±} {x : Œ±} (hs : continuous_within_at f s x) (ht : continuous_within_at f t x) : continuous_within_at f (s ‚à™ t) x :=
  iff.mpr continuous_within_at_union { left := hs, right := ht }

theorem continuous_within_at.mem_closure_image {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {x : Œ±} (h : continuous_within_at f s x) (hx : x ‚àà closure s) : f x ‚àà closure (f '' s) :=
  mem_closure_of_tendsto h (filter.mem_sets_of_superset self_mem_nhds_within (set.subset_preimage_image f s))

theorem continuous_within_at.mem_closure {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {x : Œ±} {A : set Œ≤} (h : continuous_within_at f s x) (hx : x ‚àà closure s) (hA : s ‚äÜ f ‚Åª¬π' A) : f x ‚àà closure A :=
  closure_mono (iff.mpr set.image_subset_iff hA) (continuous_within_at.mem_closure_image h hx)

theorem continuous_within_at.image_closure {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} (hf : ‚àÄ (x : Œ±), x ‚àà closure s ‚Üí continuous_within_at f s x) : f '' closure s ‚äÜ closure (f '' s) := sorry

@[simp] theorem continuous_within_at_singleton {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} : continuous_within_at f (singleton x) x := sorry

@[simp] theorem continuous_within_at_insert_self {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} {s : set Œ±} : continuous_within_at f (insert x s) x ‚Üî continuous_within_at f s x := sorry

theorem continuous_within_at.insert_self {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} {s : set Œ±} : continuous_within_at f s x ‚Üí continuous_within_at f (insert x s) x :=
  iff.mpr continuous_within_at_insert_self

theorem continuous_within_at.diff_iff {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {t : set Œ±} {x : Œ±} (ht : continuous_within_at f t x) : continuous_within_at f (s \ t) x ‚Üî continuous_within_at f s x := sorry

@[simp] theorem continuous_within_at_diff_self {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {x : Œ±} : continuous_within_at f (s \ singleton x) x ‚Üî continuous_within_at f s x :=
  continuous_within_at.diff_iff continuous_within_at_singleton

theorem is_open_map.continuous_on_image_of_left_inv_on {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} (h : is_open_map (set.restrict f s)) {finv : Œ≤ ‚Üí Œ±} (hleft : set.left_inv_on finv f s) : continuous_on finv (f '' s) := sorry

theorem is_open_map.continuous_on_range_of_left_inverse {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : is_open_map f) {finv : Œ≤ ‚Üí Œ±} (hleft : function.left_inverse finv f) : continuous_on finv (set.range f) :=
  eq.mpr (id (Eq._oldrec (Eq.refl (continuous_on finv (set.range f))) (Eq.symm set.image_univ)))
    (is_open_map.continuous_on_image_of_left_inv_on (is_open_map.restrict hf is_open_univ)
      fun (x : Œ±) (_x : x ‚àà set.univ) => hleft x)

theorem continuous_on.congr_mono {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} {s : set Œ±} {s‚ÇÅ : set Œ±} (h : continuous_on f s) (h' : set.eq_on g f s‚ÇÅ) (h‚ÇÅ : s‚ÇÅ ‚äÜ s) : continuous_on g s‚ÇÅ := sorry

theorem continuous_on.congr {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} {s : set Œ±} (h : continuous_on f s) (h' : set.eq_on g f s) : continuous_on g s :=
  continuous_on.congr_mono h h' (set.subset.refl s)

theorem continuous_on_congr {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} {s : set Œ±} (h' : set.eq_on g f s) : continuous_on g s ‚Üî continuous_on f s :=
  { mp := fun (h : continuous_on g s) => continuous_on.congr h (set.eq_on.symm h'),
    mpr := fun (h : continuous_on f s) => continuous_on.congr h h' }

theorem continuous_at.continuous_within_at {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {x : Œ±} (h : continuous_at f x) : continuous_within_at f s x :=
  continuous_within_at.mono (iff.mpr (continuous_within_at_univ f x) h) (set.subset_univ s)

theorem continuous_within_at.continuous_at {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {x : Œ±} (h : continuous_within_at f s x) (hs : s ‚àà nhds x) : continuous_at f x := sorry

theorem continuous_on.continuous_at {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {x : Œ±} (h : continuous_on f s) (hx : s ‚àà nhds x) : continuous_at f x :=
  continuous_within_at.continuous_at (h x (mem_of_nhds hx)) hx

theorem continuous_within_at.comp {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} {s : set Œ±} {t : set Œ≤} {x : Œ±} (hg : continuous_within_at g t (f x)) (hf : continuous_within_at f s x) (h : s ‚äÜ f ‚Åª¬π' t) : continuous_within_at (g ‚àò f) s x := sorry

theorem continuous_within_at.comp' {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} {s : set Œ±} {t : set Œ≤} {x : Œ±} (hg : continuous_within_at g t (f x)) (hf : continuous_within_at f s x) : continuous_within_at (g ‚àò f) (s ‚à© f ‚Åª¬π' t) x :=
  continuous_within_at.comp hg (continuous_within_at.mono hf (set.inter_subset_left s (f ‚Åª¬π' t)))
    (set.inter_subset_right s (f ‚Åª¬π' t))

theorem continuous_on.comp {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} {s : set Œ±} {t : set Œ≤} (hg : continuous_on g t) (hf : continuous_on f s) (h : s ‚äÜ f ‚Åª¬π' t) : continuous_on (g ‚àò f) s :=
  fun (x : Œ±) (hx : x ‚àà s) => continuous_within_at.comp (hg (f x) (h hx)) (hf x hx) h

theorem continuous_on.mono {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {t : set Œ±} (hf : continuous_on f s) (h : t ‚äÜ s) : continuous_on f t :=
  fun (x : Œ±) (hx : x ‚àà t) => filter.tendsto.mono_left (hf x (h hx)) (nhds_within_mono x h)

theorem continuous_on.comp' {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} {s : set Œ±} {t : set Œ≤} (hg : continuous_on g t) (hf : continuous_on f s) : continuous_on (g ‚àò f) (s ‚à© f ‚Åª¬π' t) :=
  continuous_on.comp hg (continuous_on.mono hf (set.inter_subset_left s (f ‚Åª¬π' t))) (set.inter_subset_right s (f ‚Åª¬π' t))

theorem continuous.continuous_on {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} (h : continuous f) : continuous_on f s :=
  continuous_on.mono (eq.mp (Eq._oldrec (Eq.refl (continuous f)) (propext continuous_iff_continuous_on_univ)) h)
    (set.subset_univ s)

theorem continuous.continuous_within_at {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {x : Œ±} (h : continuous f) : continuous_within_at f s x :=
  continuous_at.continuous_within_at (continuous.continuous_at h)

theorem continuous.comp_continuous_on {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} {s : set Œ±} (hg : continuous g) (hf : continuous_on f s) : continuous_on (g ‚àò f) s :=
  continuous_on.comp (continuous.continuous_on hg) hf set.subset_preimage_univ

theorem continuous_on.comp_continuous {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} {s : set Œ≤} (hg : continuous_on g s) (hf : continuous f) (hs : ‚àÄ (x : Œ±), f x ‚àà s) : continuous (g ‚àò f) :=
  eq.mpr (id (Eq._oldrec (Eq.refl (continuous (g ‚àò f))) (propext continuous_iff_continuous_on_univ)))
    (continuous_on.comp hg (eq.mp (Eq._oldrec (Eq.refl (continuous f)) (propext continuous_iff_continuous_on_univ)) hf)
      fun (x : Œ±) (_x : x ‚àà set.univ) => hs x)

theorem continuous_within_at.preimage_mem_nhds_within {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} {s : set Œ±} {t : set Œ≤} (h : continuous_within_at f s x) (ht : t ‚àà nhds (f x)) : f ‚Åª¬π' t ‚àà nhds_within x s :=
  h ht

theorem continuous_within_at.preimage_mem_nhds_within' {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {x : Œ±} {s : set Œ±} {t : set Œ≤} (h : continuous_within_at f s x) (ht : t ‚àà nhds_within (f x) (f '' s)) : f ‚Åª¬π' t ‚àà nhds_within x s := sorry

theorem continuous_within_at.congr_of_eventually_eq {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {f‚ÇÅ : Œ± ‚Üí Œ≤} {s : set Œ±} {x : Œ±} (h : continuous_within_at f s x) (h‚ÇÅ : filter.eventually_eq (nhds_within x s) f‚ÇÅ f) (hx : f‚ÇÅ x = f x) : continuous_within_at f‚ÇÅ s x := sorry

theorem continuous_within_at.congr {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {f‚ÇÅ : Œ± ‚Üí Œ≤} {s : set Œ±} {x : Œ±} (h : continuous_within_at f s x) (h‚ÇÅ : ‚àÄ (y : Œ±), y ‚àà s ‚Üí f‚ÇÅ y = f y) (hx : f‚ÇÅ x = f x) : continuous_within_at f‚ÇÅ s x :=
  continuous_within_at.congr_of_eventually_eq h (filter.mem_sets_of_superset self_mem_nhds_within h‚ÇÅ) hx

theorem continuous_within_at.congr_mono {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} {s : set Œ±} {s‚ÇÅ : set Œ±} {x : Œ±} (h : continuous_within_at f s x) (h' : set.eq_on g f s‚ÇÅ) (h‚ÇÅ : s‚ÇÅ ‚äÜ s) (hx : g x = f x) : continuous_within_at g s‚ÇÅ x :=
  continuous_within_at.congr (continuous_within_at.mono h h‚ÇÅ) h' hx

theorem continuous_on_const {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {s : set Œ±} {c : Œ≤} : continuous_on (fun (x : Œ±) => c) s :=
  continuous.continuous_on continuous_const

theorem continuous_within_at_const {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {b : Œ≤} {s : set Œ±} {x : Œ±} : continuous_within_at (fun (_x : Œ±) => b) s x :=
  continuous.continuous_within_at continuous_const

theorem continuous_on_id {Œ± : Type u_1} [topological_space Œ±] {s : set Œ±} : continuous_on id s :=
  continuous.continuous_on continuous_id

theorem continuous_within_at_id {Œ± : Type u_1} [topological_space Œ±] {s : set Œ±} {x : Œ±} : continuous_within_at id s x :=
  continuous.continuous_within_at continuous_id

theorem continuous_on_open_iff {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} (hs : is_open s) : continuous_on f s ‚Üî ‚àÄ (t : set Œ≤), is_open t ‚Üí is_open (s ‚à© f ‚Åª¬π' t) := sorry

theorem continuous_on.preimage_open_of_open {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {t : set Œ≤} (hf : continuous_on f s) (hs : is_open s) (ht : is_open t) : is_open (s ‚à© f ‚Åª¬π' t) :=
  iff.mp (continuous_on_open_iff hs) hf t ht

theorem continuous_on.preimage_closed_of_closed {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {t : set Œ≤} (hf : continuous_on f s) (hs : is_closed s) (ht : is_closed t) : is_closed (s ‚à© f ‚Åª¬π' t) := sorry

theorem continuous_on.preimage_interior_subset_interior_preimage {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {t : set Œ≤} (hf : continuous_on f s) (hs : is_open s) : s ‚à© f ‚Åª¬π' interior t ‚äÜ s ‚à© interior (f ‚Åª¬π' t) := sorry

theorem continuous_on_of_locally_continuous_on {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí ‚àÉ (t : set Œ±), is_open t ‚àß x ‚àà t ‚àß continuous_on f (s ‚à© t)) : continuous_on f s := sorry

theorem continuous_on_open_of_generate_from {Œ± : Type u_1} [topological_space Œ±] {Œ≤ : Type u_2} {s : set Œ±} {T : set (set Œ≤)} {f : Œ± ‚Üí Œ≤} (hs : is_open s) (h : ‚àÄ (t : set Œ≤), t ‚àà T ‚Üí is_open (s ‚à© f ‚Åª¬π' t)) : continuous_on f s := sorry

theorem continuous_within_at.prod {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≥} {s : set Œ±} {x : Œ±} (hf : continuous_within_at f s x) (hg : continuous_within_at g s x) : continuous_within_at (fun (x : Œ±) => (f x, g x)) s x :=
  filter.tendsto.prod_mk_nhds hf hg

theorem continuous_on.prod {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≥} {s : set Œ±} (hf : continuous_on f s) (hg : continuous_on g s) : continuous_on (fun (x : Œ±) => (f x, g x)) s :=
  fun (x : Œ±) (hx : x ‚àà s) => continuous_within_at.prod (hf x hx) (hg x hx)

theorem inducing.continuous_on_iff {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} (hg : inducing g) {s : set Œ±} : continuous_on f s ‚Üî continuous_on (g ‚àò f) s := sorry

theorem embedding.continuous_on_iff {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥] {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} (hg : embedding g) {s : set Œ±} : continuous_on f s ‚Üî continuous_on (g ‚àò f) s :=
  inducing.continuous_on_iff (embedding.to_inducing hg)

theorem continuous_within_at_of_not_mem_closure {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {s : set Œ±} {x : Œ±} : ¬¨x ‚àà closure s ‚Üí continuous_within_at f s x := sorry

theorem continuous_on_if' {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {s : set Œ±} {p : Œ± ‚Üí Prop} {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} {h : (a : Œ±) ‚Üí Decidable (p a)} (hpf : ‚àÄ (a : Œ±),
  a ‚àà s ‚à© frontier (set_of fun (a : Œ±) => p a) ‚Üí
    filter.tendsto f (nhds_within a (s ‚à© set_of fun (a : Œ±) => p a)) (nhds (ite (p a) (f a) (g a)))) (hpg : ‚àÄ (a : Œ±),
  a ‚àà s ‚à© frontier (set_of fun (a : Œ±) => p a) ‚Üí
    filter.tendsto g (nhds_within a (s ‚à© set_of fun (a : Œ±) => ¬¨p a)) (nhds (ite (p a) (f a) (g a)))) (hf : continuous_on f (s ‚à© set_of fun (a : Œ±) => p a)) (hg : continuous_on g (s ‚à© set_of fun (a : Œ±) => ¬¨p a)) : continuous_on (fun (a : Œ±) => ite (p a) (f a) (g a)) s := sorry

theorem continuous_on_if {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {p : Œ± ‚Üí Prop} {h : (a : Œ±) ‚Üí Decidable (p a)} {s : set Œ±} {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (hp : ‚àÄ (a : Œ±), a ‚àà s ‚à© frontier (set_of fun (a : Œ±) => p a) ‚Üí f a = g a) (hf : continuous_on f (s ‚à© closure (set_of fun (a : Œ±) => p a))) (hg : continuous_on g (s ‚à© closure (set_of fun (a : Œ±) => ¬¨p a))) : continuous_on (fun (a : Œ±) => ite (p a) (f a) (g a)) s := sorry

theorem continuous_if' {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {p : Œ± ‚Üí Prop} {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} {h : (a : Œ±) ‚Üí Decidable (p a)} (hpf : ‚àÄ (a : Œ±),
  a ‚àà frontier (set_of fun (x : Œ±) => p x) ‚Üí
    filter.tendsto f (nhds_within a (set_of fun (x : Œ±) => p x)) (nhds (ite (p a) (f a) (g a)))) (hpg : ‚àÄ (a : Œ±),
  a ‚àà frontier (set_of fun (x : Œ±) => p x) ‚Üí
    filter.tendsto g (nhds_within a (set_of fun (x : Œ±) => ¬¨p x)) (nhds (ite (p a) (f a) (g a)))) (hf : continuous_on f (set_of fun (x : Œ±) => p x)) (hg : continuous_on g (set_of fun (x : Œ±) => ¬¨p x)) : continuous fun (a : Œ±) => ite (p a) (f a) (g a) := sorry

theorem continuous_on_fst {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {s : set (Œ± √ó Œ≤)} : continuous_on prod.fst s :=
  continuous.continuous_on continuous_fst

theorem continuous_within_at_fst {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {s : set (Œ± √ó Œ≤)} {p : Œ± √ó Œ≤} : continuous_within_at prod.fst s p :=
  continuous.continuous_within_at continuous_fst

theorem continuous_on_snd {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {s : set (Œ± √ó Œ≤)} : continuous_on prod.snd s :=
  continuous.continuous_on continuous_snd

theorem continuous_within_at_snd {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {s : set (Œ± √ó Œ≤)} {p : Œ± √ó Œ≤} : continuous_within_at prod.snd s p :=
  continuous.continuous_within_at continuous_snd

