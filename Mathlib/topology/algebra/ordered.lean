/-
Copyright (c) 2017 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Mario Carneiro, Yury Kudryashov
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.tactic.linarith.default
import Mathlib.tactic.tfae
import Mathlib.algebra.archimedean
import Mathlib.algebra.group.pi
import Mathlib.algebra.ordered_ring
import Mathlib.order.liminf_limsup
import Mathlib.data.set.intervals.image_preimage
import Mathlib.data.set.intervals.ord_connected
import Mathlib.data.set.intervals.surj_on
import Mathlib.data.set.intervals.pi
import Mathlib.topology.algebra.group
import Mathlib.topology.extend_from_subset
import Mathlib.order.filter.interval
import Mathlib.PostPort

universes u_1 l u v w u_2 

namespace Mathlib

/-!
# Theory of topology on ordered spaces

## Main definitions

The order topology on an ordered space is the topology generated by all open intervals (or
equivalently by those of the form `(-∞, a)` and `(b, +∞)`). We define it as `preorder.topology α`.
However, we do *not* register it as an instance (as many existing ordered types already have
topologies, which would be equal but not definitionally equal to `preorder.topology α`). Instead,
we introduce a class `order_topology α`(which is a `Prop`, also known as a mixin) saying that on
the type `α` having already a topological space structure and a preorder structure, the topological
structure is equal to the order topology.

We also introduce another (mixin) class `order_closed_topology α` saying that the set of points
`(x, y)` with `x ≤ y` is closed in the product space. This is automatically satisfied on a linear
order with the order topology.

We prove many basic properties of such topologies.

## Main statements

This file contains the proofs of the following facts. For exact requirements
(`order_closed_topology` vs `order_topology`, `preorder` vs `partial_order` vs `linear_order` etc)
see their statements.

### Open / closed sets

* `is_open_lt` : if `f` and `g` are continuous functions, then `{x | f x < g x}` is open;
* `is_open_Iio`, `is_open_Ioi`, `is_open_Ioo` : open intervals are open;
* `is_closed_le` : if `f` and `g` are continuous functions, then `{x | f x ≤ g x}` is closed;
* `is_closed_Iic`, `is_closed_Ici`, `is_closed_Icc` : closed intervals are closed;
* `frontier_le_subset_eq`, `frontier_lt_subset_eq` : frontiers of both `{x | f x ≤ g x}`
  and `{x | f x < g x}` are included by `{x | f x = g x}`;
* `exists_Ioc_subset_of_mem_nhds`, `exists_Ico_subset_of_mem_nhds` : if `x < y`, then any
  neighborhood of `x` includes an interval `[x, z)` for some `z ∈ (x, y]`, and any neighborhood
  of `y` includes an interval `(z, y]` for some `z ∈ [x, y)`.

### Convergence and inequalities

* `le_of_tendsto_of_tendsto` : if `f` converges to `a`, `g` converges to `b`, and eventually
  `f x ≤ g x`, then `a ≤ b`
* `le_of_tendsto`, `ge_of_tendsto` : if `f` converges to `a` and eventually `f x ≤ b`
  (resp., `b ≤ f x`), then `a ≤ b` (resp., `b ≤ a); we also provide primed versions
  that assume the inequalities to hold for all `x`.

### Min, max, `Sup` and `Inf`

* `continuous.min`, `continuous.max`: pointwise `min`/`max` of two continuous functions is
  continuous.
* `tendsto.min`, `tendsto.max` : if `f` tends to `a` and `g` tends to `b`, then their pointwise
  `min`/`max` tend to `min a b` and `max a b`, respectively.
* `tendsto_of_tendsto_of_tendsto_of_le_of_le` : theorem known as squeeze theorem,
  sandwich theorem, theorem of Carabinieri, and two policemen (and a drunk) theorem; if `g` and `h`
  both converge to `a`, and eventually `g x ≤ f x ≤ h x`, then `f` converges to `a`.

### Connected sets and Intermediate Value Theorem

* `is_preconnected_I??` : all intervals `I??` are preconnected,
* `is_preconnected.intermediate_value`, `intermediate_value_univ` : Intermediate Value Theorem for
  connected sets and connected spaces, respectively;
* `intermediate_value_Icc`, `intermediate_value_Icc'`: Intermediate Value Theorem for functions
  on closed intervals.

### Miscellaneous facts

* `is_compact.exists_forall_le`, `is_compact.exists_forall_ge` : extreme value theorem, a continuous
  function on a compact set takes its minimum and maximum values.
* `is_closed.Icc_subset_of_forall_mem_nhds_within` : “Continuous induction” principle;
  if `s ∩ [a, b]` is closed, `a ∈ s`, and for each `x ∈ [a, b) ∩ s` some of its right neighborhoods
  is included `s`, then `[a, b] ⊆ s`.
* `is_closed.Icc_subset_of_forall_exists_gt`, `is_closed.mem_of_ge_of_forall_exists_gt` : two
  other versions of the “continuous induction” principle.

## Implementation

We do _not_ register the order topology as an instance on a preorder (or even on a linear order).
Indeed, on many such spaces, a topology has already been constructed in a different way (think
of the discrete spaces `ℕ` or `ℤ`, or `ℝ` that could inherit a topology as the completion of `ℚ`),
and is in general not defeq to the one generated by the intervals. We make it available as a
definition `preorder.topology α` though, that can be registered as an instance when necessary, or
for specific types.
-/

/-- A topology on a set which is both a topological space and a preorder is _order-closed_ if the
set of points `(x, y)` with `x ≤ y` is closed in the product space. We introduce this as a mixin.
This property is satisfied for the order topology on a linear order, but it can be satisfied more
generally, and suffices to derive many interesting properties relating order and topology. -/
class order_closed_topology (α : Type u_1) [topological_space α] [preorder α] 
where
  is_closed_le' : is_closed (set_of fun (p : α × α) => prod.fst p ≤ prod.snd p)

protected instance order_dual.topological_space {α : Type u} [topological_space α] : topological_space (order_dual α) :=
  id

theorem is_closed_le_prod {α : Type u} [topological_space α] [preorder α] [t : order_closed_topology α] : is_closed (set_of fun (p : α × α) => prod.fst p ≤ prod.snd p) :=
  order_closed_topology.is_closed_le'

theorem is_closed_le {α : Type u} {β : Type v} [topological_space α] [preorder α] [t : order_closed_topology α] [topological_space β] {f : β → α} {g : β → α} (hf : continuous f) (hg : continuous g) : is_closed (set_of fun (b : β) => f b ≤ g b) :=
  iff.mp continuous_iff_is_closed (continuous.prod_mk hf hg) (set_of fun (p : α × α) => prod.fst p ≤ prod.snd p)
    is_closed_le_prod

theorem is_closed_le' {α : Type u} [topological_space α] [preorder α] [t : order_closed_topology α] (a : α) : is_closed (set_of fun (b : α) => b ≤ a) :=
  is_closed_le continuous_id continuous_const

theorem is_closed_Iic {α : Type u} [topological_space α] [preorder α] [t : order_closed_topology α] {a : α} : is_closed (set.Iic a) :=
  is_closed_le' a

theorem is_closed_ge' {α : Type u} [topological_space α] [preorder α] [t : order_closed_topology α] (a : α) : is_closed (set_of fun (b : α) => a ≤ b) :=
  is_closed_le continuous_const continuous_id

theorem is_closed_Ici {α : Type u} [topological_space α] [preorder α] [t : order_closed_topology α] {a : α} : is_closed (set.Ici a) :=
  is_closed_ge' a

protected instance order_dual.order_closed_topology {α : Type u} [topological_space α] [preorder α] [t : order_closed_topology α] : order_closed_topology (order_dual α) :=
  order_closed_topology.mk (is_closed.preimage continuous_swap order_closed_topology.is_closed_le')

theorem is_closed_Icc {α : Type u} [topological_space α] [preorder α] [t : order_closed_topology α] {a : α} {b : α} : is_closed (set.Icc a b) :=
  is_closed_inter is_closed_Ici is_closed_Iic

@[simp] theorem closure_Icc {α : Type u} [topological_space α] [preorder α] [t : order_closed_topology α] (a : α) (b : α) : closure (set.Icc a b) = set.Icc a b :=
  is_closed.closure_eq is_closed_Icc

@[simp] theorem closure_Iic {α : Type u} [topological_space α] [preorder α] [t : order_closed_topology α] (a : α) : closure (set.Iic a) = set.Iic a :=
  is_closed.closure_eq is_closed_Iic

@[simp] theorem closure_Ici {α : Type u} [topological_space α] [preorder α] [t : order_closed_topology α] (a : α) : closure (set.Ici a) = set.Ici a :=
  is_closed.closure_eq is_closed_Ici

theorem le_of_tendsto_of_tendsto {α : Type u} {β : Type v} [topological_space α] [preorder α] [t : order_closed_topology α] {f : β → α} {g : β → α} {b : filter β} {a₁ : α} {a₂ : α} [filter.ne_bot b] (hf : filter.tendsto f b (nhds a₁)) (hg : filter.tendsto g b (nhds a₂)) (h : filter.eventually_le b f g) : a₁ ≤ a₂ := sorry

theorem le_of_tendsto_of_tendsto' {α : Type u} {β : Type v} [topological_space α] [preorder α] [t : order_closed_topology α] {f : β → α} {g : β → α} {b : filter β} {a₁ : α} {a₂ : α} [filter.ne_bot b] (hf : filter.tendsto f b (nhds a₁)) (hg : filter.tendsto g b (nhds a₂)) (h : ∀ (x : β), f x ≤ g x) : a₁ ≤ a₂ :=
  le_of_tendsto_of_tendsto hf hg (filter.eventually_of_forall h)

theorem le_of_tendsto {α : Type u} {β : Type v} [topological_space α] [preorder α] [t : order_closed_topology α] {f : β → α} {a : α} {b : α} {x : filter β} [filter.ne_bot x] (lim : filter.tendsto f x (nhds a)) (h : filter.eventually (fun (c : β) => f c ≤ b) x) : a ≤ b :=
  le_of_tendsto_of_tendsto lim tendsto_const_nhds h

theorem le_of_tendsto' {α : Type u} {β : Type v} [topological_space α] [preorder α] [t : order_closed_topology α] {f : β → α} {a : α} {b : α} {x : filter β} [filter.ne_bot x] (lim : filter.tendsto f x (nhds a)) (h : ∀ (c : β), f c ≤ b) : a ≤ b :=
  le_of_tendsto lim (filter.eventually_of_forall h)

theorem ge_of_tendsto {α : Type u} {β : Type v} [topological_space α] [preorder α] [t : order_closed_topology α] {f : β → α} {a : α} {b : α} {x : filter β} [filter.ne_bot x] (lim : filter.tendsto f x (nhds a)) (h : filter.eventually (fun (c : β) => b ≤ f c) x) : b ≤ a :=
  le_of_tendsto_of_tendsto tendsto_const_nhds lim h

theorem ge_of_tendsto' {α : Type u} {β : Type v} [topological_space α] [preorder α] [t : order_closed_topology α] {f : β → α} {a : α} {b : α} {x : filter β} [filter.ne_bot x] (lim : filter.tendsto f x (nhds a)) (h : ∀ (c : β), b ≤ f c) : b ≤ a :=
  ge_of_tendsto lim (filter.eventually_of_forall h)

@[simp] theorem closure_le_eq {α : Type u} {β : Type v} [topological_space α] [preorder α] [t : order_closed_topology α] [topological_space β] {f : β → α} {g : β → α} (hf : continuous f) (hg : continuous g) : closure (set_of fun (b : β) => f b ≤ g b) = set_of fun (b : β) => f b ≤ g b :=
  is_closed.closure_eq (is_closed_le hf hg)

theorem closure_lt_subset_le {α : Type u} {β : Type v} [topological_space α] [preorder α] [t : order_closed_topology α] [topological_space β] {f : β → α} {g : β → α} (hf : continuous f) (hg : continuous g) : closure (set_of fun (b : β) => f b < g b) ⊆ set_of fun (b : β) => f b ≤ g b := sorry

theorem continuous_within_at.closure_le {α : Type u} {β : Type v} [topological_space α] [preorder α] [t : order_closed_topology α] [topological_space β] {f : β → α} {g : β → α} {s : set β} {x : β} (hx : x ∈ closure s) (hf : continuous_within_at f s x) (hg : continuous_within_at g s x) (h : ∀ (y : β), y ∈ s → f y ≤ g y) : f x ≤ g x :=
  (fun (this : (f x, g x) ∈ set_of fun (p : α × α) => prod.fst p ≤ prod.snd p) => this)
    (is_closed.closure_subset order_closed_topology.is_closed_le'
      (continuous_within_at.mem_closure (continuous_within_at.prod hf hg) hx h))

/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,
then the set `{x ∈ s | f x ≤ g x}` is a closed set. -/
theorem is_closed.is_closed_le {α : Type u} {β : Type v} [topological_space α] [preorder α] [t : order_closed_topology α] [topological_space β] {f : β → α} {g : β → α} {s : set β} (hs : is_closed s) (hf : continuous_on f s) (hg : continuous_on g s) : is_closed (has_sep.sep (fun (x : β) => f x ≤ g x) s) :=
  continuous_on.preimage_closed_of_closed (continuous_on.prod hf hg) hs order_closed_topology.is_closed_le'

theorem nhds_within_Ici_ne_bot {α : Type u} [topological_space α] [preorder α] {a : α} {b : α} (H₂ : a ≤ b) : filter.ne_bot (nhds_within b (set.Ici a)) :=
  nhds_within_ne_bot_of_mem H₂

instance nhds_within_Ici_self_ne_bot {α : Type u} [topological_space α] [preorder α] (a : α) : filter.ne_bot (nhds_within a (set.Ici a)) :=
  nhds_within_Ici_ne_bot (le_refl a)

theorem nhds_within_Iic_ne_bot {α : Type u} [topological_space α] [preorder α] {a : α} {b : α} (H : a ≤ b) : filter.ne_bot (nhds_within a (set.Iic b)) :=
  nhds_within_ne_bot_of_mem H

instance nhds_within_Iic_self_ne_bot {α : Type u} [topological_space α] [preorder α] (a : α) : filter.ne_bot (nhds_within a (set.Iic a)) :=
  nhds_within_Iic_ne_bot (le_refl a)

protected instance order_closed_topology.to_t2_space {α : Type u} [topological_space α] [partial_order α] [t : order_closed_topology α] : t2_space α :=
  t2_space.mk
    ((fun (this : is_open (set_of fun (p : α × α) => prod.fst p ≠ prod.snd p)) (a b : α) (h : a ≠ b) => sorry)
      is_closed_eq)

theorem is_open_lt_prod {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] : is_open (set_of fun (p : α × α) => prod.fst p < prod.snd p) := sorry

theorem is_open_lt {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] [topological_space β] {f : β → α} {g : β → α} (hf : continuous f) (hg : continuous g) : is_open (set_of fun (b : β) => f b < g b) := sorry

theorem is_open_Iio {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} : is_open (set.Iio a) :=
  is_open_lt continuous_id continuous_const

theorem is_open_Ioi {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} : is_open (set.Ioi a) :=
  is_open_lt continuous_const continuous_id

theorem is_open_Ioo {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} : is_open (set.Ioo a b) :=
  is_open_inter is_open_Ioi is_open_Iio

@[simp] theorem interior_Ioi {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} : interior (set.Ioi a) = set.Ioi a :=
  is_open.interior_eq is_open_Ioi

@[simp] theorem interior_Iio {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} : interior (set.Iio a) = set.Iio a :=
  is_open.interior_eq is_open_Iio

@[simp] theorem interior_Ioo {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} : interior (set.Ioo a b) = set.Ioo a b :=
  is_open.interior_eq is_open_Ioo

/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions
on a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. -/
theorem intermediate_value_univ₂ {α : Type u} {γ : Type w} [topological_space α] [linear_order α] [order_closed_topology α] [topological_space γ] [preconnected_space γ] {a : γ} {b : γ} {f : γ → α} {g : γ → α} (hf : continuous f) (hg : continuous g) (ha : f a ≤ g a) (hb : g b ≤ f b) : ∃ (x : γ), f x = g x := sorry

/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous
on a preconnected set `s` and for some `a b ∈ s` we have `f a ≤ g a` and `g b ≤ f b`,
then for some `x ∈ s` we have `f x = g x`. -/
theorem is_preconnected.intermediate_value₂ {α : Type u} {γ : Type w} [topological_space α] [linear_order α] [order_closed_topology α] [topological_space γ] {s : set γ} (hs : is_preconnected s) {a : γ} {b : γ} (ha : a ∈ s) (hb : b ∈ s) {f : γ → α} {g : γ → α} (hf : continuous_on f s) (hg : continuous_on g s) (ha' : f a ≤ g a) (hb' : g b ≤ f b) : ∃ (x : γ), ∃ (H : x ∈ s), f x = g x := sorry

/-- Intermediate Value Theorem for continuous functions on connected sets. -/
theorem is_preconnected.intermediate_value {α : Type u} {γ : Type w} [topological_space α] [linear_order α] [order_closed_topology α] [topological_space γ] {s : set γ} (hs : is_preconnected s) {a : γ} {b : γ} (ha : a ∈ s) (hb : b ∈ s) {f : γ → α} (hf : continuous_on f s) : set.Icc (f a) (f b) ⊆ f '' s :=
  fun (x : α) (hx : x ∈ set.Icc (f a) (f b)) =>
    iff.mpr set.mem_image_iff_bex
      (is_preconnected.intermediate_value₂ hs ha hb hf continuous_on_const (and.left hx) (and.right hx))

/-- Intermediate Value Theorem for continuous functions on connected spaces. -/
theorem intermediate_value_univ {α : Type u} {γ : Type w} [topological_space α] [linear_order α] [order_closed_topology α] [topological_space γ] [preconnected_space γ] (a : γ) (b : γ) {f : γ → α} (hf : continuous f) : set.Icc (f a) (f b) ⊆ set.range f :=
  fun (x : α) (hx : x ∈ set.Icc (f a) (f b)) => intermediate_value_univ₂ hf continuous_const (and.left hx) (and.right hx)

/-- Intermediate Value Theorem for continuous functions on connected spaces. -/
theorem mem_range_of_exists_le_of_exists_ge {α : Type u} {γ : Type w} [topological_space α] [linear_order α] [order_closed_topology α] [topological_space γ] [preconnected_space γ] {c : α} {f : γ → α} (hf : continuous f) (h₁ : ∃ (a : γ), f a ≤ c) (h₂ : ∃ (b : γ), c ≤ f b) : c ∈ set.range f := sorry

/-- If a preconnected set contains endpoints of an interval, then it includes the whole interval. -/
theorem is_preconnected.Icc_subset {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {s : set α} (hs : is_preconnected s) {a : α} {b : α} (ha : a ∈ s) (hb : b ∈ s) : set.Icc a b ⊆ s := sorry

/-- If a preconnected set contains endpoints of an interval, then it includes the whole interval. -/
theorem is_connected.Icc_subset {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {s : set α} (hs : is_connected s) {a : α} {b : α} (ha : a ∈ s) (hb : b ∈ s) : set.Icc a b ⊆ s :=
  is_preconnected.Icc_subset (and.right hs) ha hb

/-- If preconnected set in a linear order space is unbounded below and above, then it is the whole
space. -/
theorem is_preconnected.eq_univ_of_unbounded {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {s : set α} (hs : is_preconnected s) (hb : ¬bdd_below s) (ha : ¬bdd_above s) : s = set.univ := sorry

/-!
### Neighborhoods to the left and to the right on an `order_closed_topology`

Limits to the left and to the right of real functions are defined in terms of neighborhoods to
the left and to the right, either open or closed, i.e., members of `𝓝[Ioi a] a` and
`𝓝[Ici a] a` on the right, and similarly on the left. Here we simply prove that all
right-neighborhoods of a point are equal, and we'll prove later other useful characterizations which
require the stronger hypothesis `order_topology α` -/

/-!
#### Right neighborhoods, point excluded
-/

theorem Ioo_mem_nhds_within_Ioi {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} {c : α} (H : b ∈ set.Ico a c) : set.Ioo a c ∈ nhds_within b (set.Ioi b) := sorry

theorem Ioc_mem_nhds_within_Ioi {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} {c : α} (H : b ∈ set.Ico a c) : set.Ioc a c ∈ nhds_within b (set.Ioi b) :=
  filter.mem_sets_of_superset (Ioo_mem_nhds_within_Ioi H) set.Ioo_subset_Ioc_self

theorem Ico_mem_nhds_within_Ioi {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} {c : α} (H : b ∈ set.Ico a c) : set.Ico a c ∈ nhds_within b (set.Ioi b) :=
  filter.mem_sets_of_superset (Ioo_mem_nhds_within_Ioi H) set.Ioo_subset_Ico_self

theorem Icc_mem_nhds_within_Ioi {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} {c : α} (H : b ∈ set.Ico a c) : set.Icc a c ∈ nhds_within b (set.Ioi b) :=
  filter.mem_sets_of_superset (Ioo_mem_nhds_within_Ioi H) set.Ioo_subset_Icc_self

@[simp] theorem nhds_within_Ioc_eq_nhds_within_Ioi {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} (h : a < b) : nhds_within a (set.Ioc a b) = nhds_within a (set.Ioi a) :=
  le_antisymm (nhds_within_mono a set.Ioc_subset_Ioi_self)
    (nhds_within_le_of_mem (Ioc_mem_nhds_within_Ioi (iff.mpr set.left_mem_Ico h)))

@[simp] theorem nhds_within_Ioo_eq_nhds_within_Ioi {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} (h : a < b) : nhds_within a (set.Ioo a b) = nhds_within a (set.Ioi a) :=
  le_antisymm (nhds_within_mono a set.Ioo_subset_Ioi_self)
    (nhds_within_le_of_mem (Ioo_mem_nhds_within_Ioi (iff.mpr set.left_mem_Ico h)))

@[simp] theorem continuous_within_at_Ioc_iff_Ioi {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] [topological_space β] {a : α} {b : α} {f : α → β} (h : a < b) : continuous_within_at f (set.Ioc a b) a ↔ continuous_within_at f (set.Ioi a) a := sorry

@[simp] theorem continuous_within_at_Ioo_iff_Ioi {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] [topological_space β] {a : α} {b : α} {f : α → β} (h : a < b) : continuous_within_at f (set.Ioo a b) a ↔ continuous_within_at f (set.Ioi a) a := sorry

/-!
#### Left neighborhoods, point excluded
-/

theorem Ioo_mem_nhds_within_Iio {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} {c : α} (H : b ∈ set.Ioc a c) : set.Ioo a c ∈ nhds_within b (set.Iio b) := sorry

theorem Ico_mem_nhds_within_Iio {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} {c : α} (H : b ∈ set.Ioc a c) : set.Ico a c ∈ nhds_within b (set.Iio b) :=
  filter.mem_sets_of_superset (Ioo_mem_nhds_within_Iio H) set.Ioo_subset_Ico_self

theorem Ioc_mem_nhds_within_Iio {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} {c : α} (H : b ∈ set.Ioc a c) : set.Ioc a c ∈ nhds_within b (set.Iio b) :=
  filter.mem_sets_of_superset (Ioo_mem_nhds_within_Iio H) set.Ioo_subset_Ioc_self

theorem Icc_mem_nhds_within_Iio {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} {c : α} (H : b ∈ set.Ioc a c) : set.Icc a c ∈ nhds_within b (set.Iio b) :=
  filter.mem_sets_of_superset (Ioo_mem_nhds_within_Iio H) set.Ioo_subset_Icc_self

@[simp] theorem nhds_within_Ico_eq_nhds_within_Iio {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} (h : a < b) : nhds_within b (set.Ico a b) = nhds_within b (set.Iio b) := sorry

@[simp] theorem nhds_within_Ioo_eq_nhds_within_Iio {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} (h : a < b) : nhds_within b (set.Ioo a b) = nhds_within b (set.Iio b) := sorry

@[simp] theorem continuous_within_at_Ico_iff_Iio {α : Type u} {γ : Type w} [topological_space α] [linear_order α] [order_closed_topology α] [topological_space γ] {a : α} {b : α} {f : α → γ} (h : a < b) : continuous_within_at f (set.Ico a b) b ↔ continuous_within_at f (set.Iio b) b := sorry

@[simp] theorem continuous_within_at_Ioo_iff_Iio {α : Type u} {γ : Type w} [topological_space α] [linear_order α] [order_closed_topology α] [topological_space γ] {a : α} {b : α} {f : α → γ} (h : a < b) : continuous_within_at f (set.Ioo a b) b ↔ continuous_within_at f (set.Iio b) b := sorry

/-!
#### Right neighborhoods, point included
-/

theorem Ioo_mem_nhds_within_Ici {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} {c : α} (H : b ∈ set.Ioo a c) : set.Ioo a c ∈ nhds_within b (set.Ici b) :=
  mem_nhds_within_of_mem_nhds (mem_nhds_sets is_open_Ioo H)

theorem Ioc_mem_nhds_within_Ici {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} {c : α} (H : b ∈ set.Ioo a c) : set.Ioc a c ∈ nhds_within b (set.Ici b) :=
  filter.mem_sets_of_superset (Ioo_mem_nhds_within_Ici H) set.Ioo_subset_Ioc_self

theorem Ico_mem_nhds_within_Ici {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} {c : α} (H : b ∈ set.Ico a c) : set.Ico a c ∈ nhds_within b (set.Ici b) := sorry

theorem Icc_mem_nhds_within_Ici {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} {c : α} (H : b ∈ set.Ico a c) : set.Icc a c ∈ nhds_within b (set.Ici b) :=
  filter.mem_sets_of_superset (Ico_mem_nhds_within_Ici H) set.Ico_subset_Icc_self

@[simp] theorem nhds_within_Icc_eq_nhds_within_Ici {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} (h : a < b) : nhds_within a (set.Icc a b) = nhds_within a (set.Ici a) :=
  le_antisymm (nhds_within_mono a set.Icc_subset_Ici_self)
    (nhds_within_le_of_mem (Icc_mem_nhds_within_Ici (iff.mpr set.left_mem_Ico h)))

@[simp] theorem nhds_within_Ico_eq_nhds_within_Ici {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} (h : a < b) : nhds_within a (set.Ico a b) = nhds_within a (set.Ici a) :=
  le_antisymm (nhds_within_mono a fun (x : α) => and.left)
    (nhds_within_le_of_mem (Ico_mem_nhds_within_Ici (iff.mpr set.left_mem_Ico h)))

@[simp] theorem continuous_within_at_Icc_iff_Ici {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] [topological_space β] {a : α} {b : α} {f : α → β} (h : a < b) : continuous_within_at f (set.Icc a b) a ↔ continuous_within_at f (set.Ici a) a := sorry

@[simp] theorem continuous_within_at_Ico_iff_Ici {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] [topological_space β] {a : α} {b : α} {f : α → β} (h : a < b) : continuous_within_at f (set.Ico a b) a ↔ continuous_within_at f (set.Ici a) a := sorry

/-!
#### Left neighborhoods, point included
-/

theorem Ioo_mem_nhds_within_Iic {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} {c : α} (H : b ∈ set.Ioo a c) : set.Ioo a c ∈ nhds_within b (set.Iic b) :=
  mem_nhds_within_of_mem_nhds (mem_nhds_sets is_open_Ioo H)

theorem Ico_mem_nhds_within_Iic {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} {c : α} (H : b ∈ set.Ioo a c) : set.Ico a c ∈ nhds_within b (set.Iic b) :=
  filter.mem_sets_of_superset (Ioo_mem_nhds_within_Iic H) set.Ioo_subset_Ico_self

theorem Ioc_mem_nhds_within_Iic {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} {c : α} (H : b ∈ set.Ioc a c) : set.Ioc a c ∈ nhds_within b (set.Iic b) := sorry

theorem Icc_mem_nhds_within_Iic {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} {c : α} (H : b ∈ set.Ioc a c) : set.Icc a c ∈ nhds_within b (set.Iic b) :=
  filter.mem_sets_of_superset (Ioc_mem_nhds_within_Iic H) set.Ioc_subset_Icc_self

@[simp] theorem nhds_within_Icc_eq_nhds_within_Iic {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} (h : a < b) : nhds_within b (set.Icc a b) = nhds_within b (set.Iic b) := sorry

@[simp] theorem nhds_within_Ioc_eq_nhds_within_Iic {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] {a : α} {b : α} (h : a < b) : nhds_within b (set.Ioc a b) = nhds_within b (set.Iic b) := sorry

@[simp] theorem continuous_within_at_Icc_iff_Iic {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] [topological_space β] {a : α} {b : α} {f : α → β} (h : a < b) : continuous_within_at f (set.Icc a b) b ↔ continuous_within_at f (set.Iic b) b := sorry

@[simp] theorem continuous_within_at_Ioc_iff_Iic {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] [topological_space β] {a : α} {b : α} {f : α → β} (h : a < b) : continuous_within_at f (set.Ioc a b) b ↔ continuous_within_at f (set.Iic b) b := sorry

theorem frontier_le_subset_eq {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] {f : β → α} {g : β → α} [topological_space β] (hf : continuous f) (hg : continuous g) : frontier (set_of fun (b : β) => f b ≤ g b) ⊆ set_of fun (b : β) => f b = g b := sorry

theorem frontier_lt_subset_eq {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] {f : β → α} {g : β → α} [topological_space β] (hf : continuous f) (hg : continuous g) : frontier (set_of fun (b : β) => f b < g b) ⊆ set_of fun (b : β) => f b = g b := sorry

theorem continuous.min {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] {f : β → α} {g : β → α} [topological_space β] (hf : continuous f) (hg : continuous g) : continuous fun (b : β) => min (f b) (g b) :=
  (fun (this : ∀ (b : β), b ∈ frontier (set_of fun (b : β) => f b ≤ g b) → f b = g b) => continuous_if this hf hg)
    fun (b : β) (hb : b ∈ frontier (set_of fun (b : β) => f b ≤ g b)) => frontier_le_subset_eq hf hg hb

theorem continuous.max {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] {f : β → α} {g : β → α} [topological_space β] (hf : continuous f) (hg : continuous g) : continuous fun (b : β) => max (f b) (g b) :=
  continuous.min hf hg

theorem continuous_min {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] : continuous fun (p : α × α) => min (prod.fst p) (prod.snd p) :=
  continuous.min continuous_fst continuous_snd

theorem continuous_max {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] : continuous fun (p : α × α) => max (prod.fst p) (prod.snd p) :=
  continuous.max continuous_fst continuous_snd

theorem tendsto.max {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] {f : β → α} {g : β → α} {b : filter β} {a₁ : α} {a₂ : α} (hf : filter.tendsto f b (nhds a₁)) (hg : filter.tendsto g b (nhds a₂)) : filter.tendsto (fun (b : β) => max (f b) (g b)) b (nhds (max a₁ a₂)) :=
  filter.tendsto.comp (continuous.tendsto continuous_max (a₁, a₂)) (filter.tendsto.prod_mk_nhds hf hg)

theorem tendsto.min {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_closed_topology α] {f : β → α} {g : β → α} {b : filter β} {a₁ : α} {a₂ : α} (hf : filter.tendsto f b (nhds a₁)) (hg : filter.tendsto g b (nhds a₂)) : filter.tendsto (fun (b : β) => min (f b) (g b)) b (nhds (min a₁ a₂)) :=
  filter.tendsto.comp (continuous.tendsto continuous_min (a₁, a₂)) (filter.tendsto.prod_mk_nhds hf hg)

/-- The order topology on an ordered type is the topology generated by open intervals. We register
it on a preorder, but it is mostly interesting in linear orders, where it is also order-closed.
We define it as a mixin. If you want to introduce the order topology on a preorder, use
`preorder.topology`. -/
class order_topology (α : Type u_1) [t : topological_space α] [preorder α] 
where
  topology_eq_generate_intervals : t = topological_space.generate_from (set_of fun (s : set α) => ∃ (a : α), s = set.Ioi a ∨ s = set.Iio a)

/-- (Order) topology on a partial order `α` generated by the subbase of open intervals
`(a, ∞) = { x ∣ a < x }, (-∞ , b) = {x ∣ x < b}` for all `a, b` in `α`. We do not register it as an
instance as many ordered sets are already endowed with the same topology, most often in a non-defeq
way though. Register as a local instance when necessary. -/
def preorder.topology (α : Type u_1) [preorder α] : topological_space α :=
  topological_space.generate_from
    (set_of fun (s : set α) => ∃ (a : α), (s = set_of fun (b : α) => a < b) ∨ s = set_of fun (b : α) => b < a)

protected instance order_dual.order_topology {α : Type u_1} [topological_space α] [partial_order α] [order_topology α] : order_topology (order_dual α) := sorry

theorem is_open_iff_generate_intervals {α : Type u} [topological_space α] [partial_order α] [t : order_topology α] {s : set α} : is_open s ↔ topological_space.generate_open (set_of fun (s : set α) => ∃ (a : α), s = set.Ioi a ∨ s = set.Iio a) s := sorry

theorem is_open_lt' {α : Type u} [topological_space α] [partial_order α] [t : order_topology α] (a : α) : is_open (set_of fun (b : α) => a < b) :=
  eq.mpr (id (Eq._oldrec (Eq.refl (is_open (set_of fun (b : α) => a < b))) (propext is_open_iff_generate_intervals)))
    (topological_space.generate_open.basic (set_of fun (b : α) => a < b) (Exists.intro a (Or.inl rfl)))

theorem is_open_gt' {α : Type u} [topological_space α] [partial_order α] [t : order_topology α] (a : α) : is_open (set_of fun (b : α) => b < a) :=
  eq.mpr (id (Eq._oldrec (Eq.refl (is_open (set_of fun (b : α) => b < a))) (propext is_open_iff_generate_intervals)))
    (topological_space.generate_open.basic (set_of fun (b : α) => b < a) (Exists.intro a (Or.inr rfl)))

theorem lt_mem_nhds {α : Type u} [topological_space α] [partial_order α] [t : order_topology α] {a : α} {b : α} (h : a < b) : filter.eventually (fun (x : α) => a < x) (nhds b) :=
  mem_nhds_sets (is_open_lt' a) h

theorem le_mem_nhds {α : Type u} [topological_space α] [partial_order α] [t : order_topology α] {a : α} {b : α} (h : a < b) : filter.eventually (fun (x : α) => a ≤ x) (nhds b) :=
  filter.sets_of_superset (nhds b) (lt_mem_nhds h)
    fun (b : α) (hb : b ∈ set_of fun (x : α) => (fun (x : α) => a < x) x) => le_of_lt hb

theorem gt_mem_nhds {α : Type u} [topological_space α] [partial_order α] [t : order_topology α] {a : α} {b : α} (h : a < b) : filter.eventually (fun (x : α) => x < b) (nhds a) :=
  mem_nhds_sets (is_open_gt' b) h

theorem ge_mem_nhds {α : Type u} [topological_space α] [partial_order α] [t : order_topology α] {a : α} {b : α} (h : a < b) : filter.eventually (fun (x : α) => x ≤ b) (nhds a) :=
  filter.sets_of_superset (nhds a) (gt_mem_nhds h)
    fun (b_1 : α) (hb : b_1 ∈ set_of fun (x : α) => (fun (x : α) => x < b) x) => le_of_lt hb

theorem nhds_eq_order {α : Type u} [topological_space α] [partial_order α] [t : order_topology α] (a : α) : nhds a =
  (infi fun (b : α) => infi fun (H : b ∈ set.Iio a) => filter.principal (set.Ioi b)) ⊓
    infi fun (b : α) => infi fun (H : b ∈ set.Ioi a) => filter.principal (set.Iio b) := sorry

theorem tendsto_order {α : Type u} {β : Type v} [topological_space α] [partial_order α] [t : order_topology α] {f : β → α} {a : α} {x : filter β} : filter.tendsto f x (nhds a) ↔
  (∀ (a' : α), a' < a → filter.eventually (fun (b : β) => a' < f b) x) ∧
    ∀ (a' : α), a' > a → filter.eventually (fun (b : β) => f b < a') x := sorry

protected instance tendsto_Icc_class_nhds {α : Type u} [topological_space α] [partial_order α] [t : order_topology α] (a : α) : filter.tendsto_Ixx_class set.Icc (nhds a) (nhds a) := sorry

protected instance tendsto_Ico_class_nhds {α : Type u} [topological_space α] [partial_order α] [t : order_topology α] (a : α) : filter.tendsto_Ixx_class set.Ico (nhds a) (nhds a) :=
  filter.tendsto_Ixx_class_of_subset fun (_x _x_1 : α) => set.Ico_subset_Icc_self

protected instance tendsto_Ioc_class_nhds {α : Type u} [topological_space α] [partial_order α] [t : order_topology α] (a : α) : filter.tendsto_Ixx_class set.Ioc (nhds a) (nhds a) :=
  filter.tendsto_Ixx_class_of_subset fun (_x _x_1 : α) => set.Ioc_subset_Icc_self

protected instance tendsto_Ioo_class_nhds {α : Type u} [topological_space α] [partial_order α] [t : order_topology α] (a : α) : filter.tendsto_Ixx_class set.Ioo (nhds a) (nhds a) :=
  filter.tendsto_Ixx_class_of_subset fun (_x _x_1 : α) => set.Ioo_subset_Icc_self

/-- Also known as squeeze or sandwich theorem. This version assumes that inequalities hold
eventually for the filter. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le' {α : Type u} {β : Type v} [topological_space α] [partial_order α] [t : order_topology α] {f : β → α} {g : β → α} {h : β → α} {b : filter β} {a : α} (hg : filter.tendsto g b (nhds a)) (hh : filter.tendsto h b (nhds a)) (hgf : filter.eventually (fun (b : β) => g b ≤ f b) b) (hfh : filter.eventually (fun (b : β) => f b ≤ h b) b) : filter.tendsto f b (nhds a) := sorry

/-- Also known as squeeze or sandwich theorem. This version assumes that inequalities hold
everywhere. -/
theorem tendsto_of_tendsto_of_tendsto_of_le_of_le {α : Type u} {β : Type v} [topological_space α] [partial_order α] [t : order_topology α] {f : β → α} {g : β → α} {h : β → α} {b : filter β} {a : α} (hg : filter.tendsto g b (nhds a)) (hh : filter.tendsto h b (nhds a)) (hgf : g ≤ f) (hfh : f ≤ h) : filter.tendsto f b (nhds a) :=
  tendsto_of_tendsto_of_tendsto_of_le_of_le' hg hh (filter.eventually_of_forall hgf) (filter.eventually_of_forall hfh)

theorem nhds_order_unbounded {α : Type u} [topological_space α] [partial_order α] [t : order_topology α] {a : α} (hu : ∃ (u : α), a < u) (hl : ∃ (l : α), l < a) : nhds a =
  infi
    fun (l : α) => infi fun (h₂ : l < a) => infi fun (u : α) => infi fun (h₂ : a < u) => filter.principal (set.Ioo l u) := sorry

theorem tendsto_order_unbounded {α : Type u} {β : Type v} [topological_space α] [partial_order α] [t : order_topology α] {f : β → α} {a : α} {x : filter β} (hu : ∃ (u : α), a < u) (hl : ∃ (l : α), l < a) (h : ∀ (l u : α), l < a → a < u → filter.eventually (fun (b : β) => l < f b ∧ f b < u) x) : filter.tendsto f x (nhds a) := sorry

protected instance tendsto_Ixx_nhds_within {α : Type u_1} [preorder α] [topological_space α] (a : α) {s : set α} {t : set α} {Ixx : α → α → set α} [filter.tendsto_Ixx_class Ixx (nhds a) (nhds a)] [filter.tendsto_Ixx_class Ixx (filter.principal s) (filter.principal t)] : filter.tendsto_Ixx_class Ixx (nhds_within a s) (nhds_within a t) :=
  filter.tendsto_Ixx_class_inf

protected instance tendsto_Icc_class_nhds_pi {ι : Type u_1} {α : ι → Type u_2} [Nonempty ι] [(i : ι) → partial_order (α i)] [(i : ι) → topological_space (α i)] [∀ (i : ι), order_topology (α i)] (f : (i : ι) → α i) : filter.tendsto_Ixx_class set.Icc (nhds f) (nhds f) := sorry

theorem induced_order_topology' {α : Type u} {β : Type v} [partial_order α] [ta : topological_space β] [partial_order β] [order_topology β] (f : α → β) (hf : ∀ {x y : α}, f x < f y ↔ x < y) (H₁ : ∀ {a : α} {x : β}, x < f a → ∃ (b : α), ∃ (H : b < a), x ≤ f b) (H₂ : ∀ {a : α} {x : β}, f a < x → ∃ (b : α), ∃ (H : b > a), f b ≤ x) : order_topology α := sorry

theorem induced_order_topology {α : Type u} {β : Type v} [partial_order α] [ta : topological_space β] [partial_order β] [order_topology β] (f : α → β) (hf : ∀ {x y : α}, f x < f y ↔ x < y) (H : ∀ {x y : β}, x < y → ∃ (a : α), x < f a ∧ f a < y) : order_topology α := sorry

/-- On an `ord_connected` subset of a linear order, the order topology for the restriction of the
order is the same as the restriction to the subset of the order topology. -/
protected instance order_topology_of_ord_connected {α : Type u} [ta : topological_space α] [linear_order α] [order_topology α] {t : set α} [ht : set.ord_connected t] : order_topology ↥t := sorry

theorem nhds_top_order {α : Type u} [topological_space α] [order_top α] [order_topology α] : nhds ⊤ = infi fun (l : α) => infi fun (h₂ : l < ⊤) => filter.principal (set.Ioi l) := sorry

theorem nhds_bot_order {α : Type u} [topological_space α] [order_bot α] [order_topology α] : nhds ⊥ = infi fun (l : α) => infi fun (h₂ : ⊥ < l) => filter.principal (set.Iio l) := sorry

theorem tendsto_nhds_top_mono {α : Type u} {β : Type v} [topological_space β] [order_top β] [order_topology β] {l : filter α} {f : α → β} {g : α → β} (hf : filter.tendsto f l (nhds ⊤)) (hg : filter.eventually_le l f g) : filter.tendsto g l (nhds ⊤) := sorry

theorem tendsto_nhds_bot_mono {α : Type u} {β : Type v} [topological_space β] [order_bot β] [order_topology β] {l : filter α} {f : α → β} {g : α → β} (hf : filter.tendsto f l (nhds ⊥)) (hg : filter.eventually_le l g f) : filter.tendsto g l (nhds ⊥) :=
  tendsto_nhds_top_mono hf hg

theorem tendsto_nhds_top_mono' {α : Type u} {β : Type v} [topological_space β] [order_top β] [order_topology β] {l : filter α} {f : α → β} {g : α → β} (hf : filter.tendsto f l (nhds ⊤)) (hg : f ≤ g) : filter.tendsto g l (nhds ⊤) :=
  tendsto_nhds_top_mono hf (filter.eventually_of_forall hg)

theorem tendsto_nhds_bot_mono' {α : Type u} {β : Type v} [topological_space β] [order_bot β] [order_topology β] {l : filter α} {f : α → β} {g : α → β} (hf : filter.tendsto f l (nhds ⊥)) (hg : g ≤ f) : filter.tendsto g l (nhds ⊥) :=
  tendsto_nhds_bot_mono hf (filter.eventually_of_forall hg)

theorem exists_Ioc_subset_of_mem_nhds' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {s : set α} (hs : s ∈ nhds a) {l : α} (hl : l < a) : ∃ (l' : α), ∃ (H : l' ∈ set.Ico l a), set.Ioc l' a ⊆ s := sorry

theorem exists_Ico_subset_of_mem_nhds' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {s : set α} (hs : s ∈ nhds a) {u : α} (hu : a < u) : ∃ (u' : α), ∃ (H : u' ∈ set.Ioc a u), set.Ico a u' ⊆ s := sorry

theorem exists_Ioc_subset_of_mem_nhds {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {s : set α} (hs : s ∈ nhds a) (h : ∃ (l : α), l < a) : ∃ (l : α), ∃ (H : l < a), set.Ioc l a ⊆ s := sorry

theorem exists_Ico_subset_of_mem_nhds {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {s : set α} (hs : s ∈ nhds a) (h : ∃ (u : α), a < u) : ∃ (u : α), ∃ (_x : a < u), set.Ico a u ⊆ s := sorry

theorem order_separated {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a₁ : α} {a₂ : α} (h : a₁ < a₂) : ∃ (u : set α),
  ∃ (v : set α), is_open u ∧ is_open v ∧ a₁ ∈ u ∧ a₂ ∈ v ∧ ∀ (b₁ : α), b₁ ∈ u → ∀ (b₂ : α), b₂ ∈ v → b₁ < b₂ := sorry

protected instance order_topology.to_order_closed_topology {α : Type u} [topological_space α] [linear_order α] [order_topology α] : order_closed_topology α :=
  order_closed_topology.mk
    (iff.mpr is_open_prod_iff fun (a₁ a₂ : α) (h : ¬a₁ ≤ a₂) => (fun (h : a₂ < a₁) => sorry) (lt_of_not_ge h))

theorem order_topology.t2_space {α : Type u} [topological_space α] [linear_order α] [order_topology α] : t2_space α :=
  order_closed_topology.to_t2_space

protected instance order_topology.regular_space {α : Type u} [topological_space α] [linear_order α] [order_topology α] : regular_space α :=
  regular_space.mk
    fun (s : set α) (a : α) (hs : is_closed s) (ha : ¬a ∈ s) =>
      (fun (hs' : sᶜ ∈ nhds a) =>
          (fun (this : ∃ (t : set α), is_open t ∧ (∀ (l : α), l ∈ s → l < a → l ∈ t) ∧ nhds_within a t = ⊥) => sorry)
            (classical.by_cases (fun (h : ∃ (l : α), l < a) => sorry)
              fun (this : ¬∃ (l : α), l < a) =>
                Exists.intro ∅
                  { left := is_open_empty,
                    right :=
                      { left := fun (l : α) (_x : l ∈ s) (hl : l < a) => false.elim (this (Exists.intro l hl)),
                        right := nhds_within_empty a } }))
        (mem_nhds_sets hs ha)

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`,
provided `a` is neither a bottom element nor a top element. -/
theorem mem_nhds_iff_exists_Ioo_subset' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {s : set α} (hl : ∃ (l : α), l < a) (hu : ∃ (u : α), a < u) : s ∈ nhds a ↔ ∃ (l : α), ∃ (u : α), a ∈ set.Ioo l u ∧ set.Ioo l u ⊆ s := sorry

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`.
-/
theorem mem_nhds_iff_exists_Ioo_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_top_order α] [no_bot_order α] {a : α} {s : set α} : s ∈ nhds a ↔ ∃ (l : α), ∃ (u : α), a ∈ set.Ioo l u ∧ set.Ioo l u ⊆ s :=
  mem_nhds_iff_exists_Ioo_subset' (no_bot a) (no_top a)

theorem nhds_basis_Ioo' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} (hl : ∃ (l : α), l < a) (hu : ∃ (u : α), a < u) : filter.has_basis (nhds a) (fun (b : α × α) => prod.fst b < a ∧ a < prod.snd b)
  fun (b : α × α) => set.Ioo (prod.fst b) (prod.snd b) := sorry

theorem nhds_basis_Ioo {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_top_order α] [no_bot_order α] {a : α} : filter.has_basis (nhds a) (fun (b : α × α) => prod.fst b < a ∧ a < prod.snd b)
  fun (b : α × α) => set.Ioo (prod.fst b) (prod.snd b) :=
  nhds_basis_Ioo' (no_bot a) (no_top a)

theorem filter.eventually.exists_Ioo_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_top_order α] [no_bot_order α] {a : α} {p : α → Prop} (hp : filter.eventually (fun (x : α) => p x) (nhds a)) : ∃ (l : α), ∃ (u : α), a ∈ set.Ioo l u ∧ set.Ioo l u ⊆ set_of fun (x : α) => p x :=
  iff.mp mem_nhds_iff_exists_Ioo_subset hp

theorem Iio_mem_nhds {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {b : α} (h : a < b) : set.Iio b ∈ nhds a :=
  mem_nhds_sets is_open_Iio h

theorem Ioi_mem_nhds {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {b : α} (h : a < b) : set.Ioi a ∈ nhds b :=
  mem_nhds_sets is_open_Ioi h

theorem Iic_mem_nhds {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {b : α} (h : a < b) : set.Iic b ∈ nhds a :=
  filter.mem_sets_of_superset (Iio_mem_nhds h) set.Iio_subset_Iic_self

theorem Ici_mem_nhds {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {b : α} (h : a < b) : set.Ici a ∈ nhds b :=
  filter.mem_sets_of_superset (Ioi_mem_nhds h) set.Ioi_subset_Ici_self

theorem Ioo_mem_nhds {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {b : α} {x : α} (ha : a < x) (hb : x < b) : set.Ioo a b ∈ nhds x :=
  mem_nhds_sets is_open_Ioo { left := ha, right := hb }

theorem Ioc_mem_nhds {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {b : α} {x : α} (ha : a < x) (hb : x < b) : set.Ioc a b ∈ nhds x :=
  filter.mem_sets_of_superset (Ioo_mem_nhds ha hb) set.Ioo_subset_Ioc_self

theorem Ico_mem_nhds {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {b : α} {x : α} (ha : a < x) (hb : x < b) : set.Ico a b ∈ nhds x :=
  filter.mem_sets_of_superset (Ioo_mem_nhds ha hb) set.Ioo_subset_Ico_self

theorem Icc_mem_nhds {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {b : α} {x : α} (ha : a < x) (hb : x < b) : set.Icc a b ∈ nhds x :=
  filter.mem_sets_of_superset (Ioo_mem_nhds ha hb) set.Ioo_subset_Icc_self

/-!
### Intervals in `Π i, π i` belong to `𝓝 x`

For each leamma `pi_Ixx_mem_nhds` we add a non-dependent version `pi_Ixx_mem_nhds'` because
sometimes Lean fails to unify different instances while trying to apply the dependent version to,
e.g., `ι → ℝ`.
-/

theorem pi_Iic_mem_nhds {ι : Type u_1} {π : ι → Type u_2} [fintype ι] [(i : ι) → linear_order (π i)] [(i : ι) → topological_space (π i)] [∀ (i : ι), order_topology (π i)] {a : (i : ι) → π i} {x : (i : ι) → π i} (ha : ∀ (i : ι), x i < a i) : set.Iic a ∈ nhds x :=
  set.pi_univ_Iic a ▸
    set_pi_mem_nhds (set.finite.of_fintype set.univ) fun (i : ι) (_x : i ∈ set.univ) => Iic_mem_nhds (ha i)

theorem pi_Iic_mem_nhds' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {ι : Type u_1} [fintype ι] {a' : ι → α} {x' : ι → α} (ha : ∀ (i : ι), x' i < a' i) : set.Iic a' ∈ nhds x' :=
  pi_Iic_mem_nhds ha

theorem pi_Ici_mem_nhds {ι : Type u_1} {π : ι → Type u_2} [fintype ι] [(i : ι) → linear_order (π i)] [(i : ι) → topological_space (π i)] [∀ (i : ι), order_topology (π i)] {a : (i : ι) → π i} {x : (i : ι) → π i} (ha : ∀ (i : ι), a i < x i) : set.Ici a ∈ nhds x :=
  set.pi_univ_Ici a ▸
    set_pi_mem_nhds (set.finite.of_fintype set.univ) fun (i : ι) (_x : i ∈ set.univ) => Ici_mem_nhds (ha i)

theorem pi_Ici_mem_nhds' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {ι : Type u_1} [fintype ι] {a' : ι → α} {x' : ι → α} (ha : ∀ (i : ι), a' i < x' i) : set.Ici a' ∈ nhds x' :=
  pi_Ici_mem_nhds ha

theorem pi_Icc_mem_nhds {ι : Type u_1} {π : ι → Type u_2} [fintype ι] [(i : ι) → linear_order (π i)] [(i : ι) → topological_space (π i)] [∀ (i : ι), order_topology (π i)] {a : (i : ι) → π i} {b : (i : ι) → π i} {x : (i : ι) → π i} (ha : ∀ (i : ι), a i < x i) (hb : ∀ (i : ι), x i < b i) : set.Icc a b ∈ nhds x :=
  set.pi_univ_Icc a b ▸
    set_pi_mem_nhds (set.finite.of_fintype set.univ) fun (i : ι) (_x : i ∈ set.univ) => Icc_mem_nhds (ha i) (hb i)

theorem pi_Icc_mem_nhds' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {ι : Type u_1} [fintype ι] {a' : ι → α} {b' : ι → α} {x' : ι → α} (ha : ∀ (i : ι), a' i < x' i) (hb : ∀ (i : ι), x' i < b' i) : set.Icc a' b' ∈ nhds x' :=
  pi_Icc_mem_nhds ha hb

theorem pi_Iio_mem_nhds {ι : Type u_1} {π : ι → Type u_2} [fintype ι] [(i : ι) → linear_order (π i)] [(i : ι) → topological_space (π i)] [∀ (i : ι), order_topology (π i)] {a : (i : ι) → π i} {x : (i : ι) → π i} [Nonempty ι] (ha : ∀ (i : ι), x i < a i) : set.Iio a ∈ nhds x :=
  filter.mem_sets_of_superset
    (set_pi_mem_nhds (set.finite.of_fintype set.univ) fun (i : ι) (_x : i ∈ set.univ) => Iio_mem_nhds (ha i))
    (set.pi_univ_Iio_subset a)

theorem pi_Iio_mem_nhds' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {ι : Type u_1} [fintype ι] {a' : ι → α} {x' : ι → α} [Nonempty ι] (ha : ∀ (i : ι), x' i < a' i) : set.Iio a' ∈ nhds x' :=
  pi_Iio_mem_nhds ha

theorem pi_Ioi_mem_nhds {ι : Type u_1} {π : ι → Type u_2} [fintype ι] [(i : ι) → linear_order (π i)] [(i : ι) → topological_space (π i)] [∀ (i : ι), order_topology (π i)] {a : (i : ι) → π i} {x : (i : ι) → π i} [Nonempty ι] (ha : ∀ (i : ι), a i < x i) : set.Ioi a ∈ nhds x :=
  pi_Iio_mem_nhds ha

theorem pi_Ioi_mem_nhds' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {ι : Type u_1} [fintype ι] {a' : ι → α} {x' : ι → α} [Nonempty ι] (ha : ∀ (i : ι), a' i < x' i) : set.Ioi a' ∈ nhds x' :=
  pi_Ioi_mem_nhds ha

theorem pi_Ioc_mem_nhds {ι : Type u_1} {π : ι → Type u_2} [fintype ι] [(i : ι) → linear_order (π i)] [(i : ι) → topological_space (π i)] [∀ (i : ι), order_topology (π i)] {a : (i : ι) → π i} {b : (i : ι) → π i} {x : (i : ι) → π i} [Nonempty ι] (ha : ∀ (i : ι), a i < x i) (hb : ∀ (i : ι), x i < b i) : set.Ioc a b ∈ nhds x :=
  filter.mem_sets_of_superset
    (set_pi_mem_nhds (set.finite.of_fintype set.univ) fun (i : ι) (_x : i ∈ set.univ) => Ioc_mem_nhds (ha i) (hb i))
    (set.pi_univ_Ioc_subset a b)

theorem pi_Ioc_mem_nhds' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {ι : Type u_1} [fintype ι] {a' : ι → α} {b' : ι → α} {x' : ι → α} [Nonempty ι] (ha : ∀ (i : ι), a' i < x' i) (hb : ∀ (i : ι), x' i < b' i) : set.Ioc a' b' ∈ nhds x' :=
  pi_Ioc_mem_nhds ha hb

theorem pi_Ico_mem_nhds {ι : Type u_1} {π : ι → Type u_2} [fintype ι] [(i : ι) → linear_order (π i)] [(i : ι) → topological_space (π i)] [∀ (i : ι), order_topology (π i)] {a : (i : ι) → π i} {b : (i : ι) → π i} {x : (i : ι) → π i} [Nonempty ι] (ha : ∀ (i : ι), a i < x i) (hb : ∀ (i : ι), x i < b i) : set.Ico a b ∈ nhds x :=
  filter.mem_sets_of_superset
    (set_pi_mem_nhds (set.finite.of_fintype set.univ) fun (i : ι) (_x : i ∈ set.univ) => Ico_mem_nhds (ha i) (hb i))
    (set.pi_univ_Ico_subset a b)

theorem pi_Ico_mem_nhds' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {ι : Type u_1} [fintype ι] {a' : ι → α} {b' : ι → α} {x' : ι → α} [Nonempty ι] (ha : ∀ (i : ι), a' i < x' i) (hb : ∀ (i : ι), x' i < b' i) : set.Ico a' b' ∈ nhds x' :=
  pi_Ico_mem_nhds ha hb

theorem pi_Ioo_mem_nhds {ι : Type u_1} {π : ι → Type u_2} [fintype ι] [(i : ι) → linear_order (π i)] [(i : ι) → topological_space (π i)] [∀ (i : ι), order_topology (π i)] {a : (i : ι) → π i} {b : (i : ι) → π i} {x : (i : ι) → π i} [Nonempty ι] (ha : ∀ (i : ι), a i < x i) (hb : ∀ (i : ι), x i < b i) : set.Ioo a b ∈ nhds x :=
  filter.mem_sets_of_superset
    (set_pi_mem_nhds (set.finite.of_fintype set.univ) fun (i : ι) (_x : i ∈ set.univ) => Ioo_mem_nhds (ha i) (hb i))
    (set.pi_univ_Ioo_subset a b)

theorem pi_Ioo_mem_nhds' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {ι : Type u_1} [fintype ι] {a' : ι → α} {b' : ι → α} {x' : ι → α} [Nonempty ι] (ha : ∀ (i : ι), a' i < x' i) (hb : ∀ (i : ι), x' i < b' i) : set.Ioo a' b' ∈ nhds x' :=
  pi_Ioo_mem_nhds ha hb

theorem disjoint_nhds_at_top {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_top_order α] (x : α) : disjoint (nhds x) filter.at_top := sorry

@[simp] theorem inf_nhds_at_top {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_top_order α] (x : α) : nhds x ⊓ filter.at_top = ⊥ :=
  iff.mp disjoint_iff (disjoint_nhds_at_top x)

theorem disjoint_nhds_at_bot {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_bot_order α] (x : α) : disjoint (nhds x) filter.at_bot :=
  disjoint_nhds_at_top x

@[simp] theorem inf_nhds_at_bot {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_bot_order α] (x : α) : nhds x ⊓ filter.at_bot = ⊥ :=
  inf_nhds_at_top x

theorem not_tendsto_nhds_of_tendsto_at_top {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_topology α] [no_top_order α] {F : filter β} [filter.ne_bot F] {f : β → α} (hf : filter.tendsto f F filter.at_top) (x : α) : ¬filter.tendsto f F (nhds x) :=
  filter.tendsto.not_tendsto hf (disjoint.symm (disjoint_nhds_at_top x))

theorem not_tendsto_at_top_of_tendsto_nhds {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_topology α] [no_top_order α] {F : filter β} [filter.ne_bot F] {f : β → α} {x : α} (hf : filter.tendsto f F (nhds x)) : ¬filter.tendsto f F filter.at_top :=
  filter.tendsto.not_tendsto hf (disjoint_nhds_at_top x)

theorem not_tendsto_nhds_of_tendsto_at_bot {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_topology α] [no_bot_order α] {F : filter β} [filter.ne_bot F] {f : β → α} (hf : filter.tendsto f F filter.at_bot) (x : α) : ¬filter.tendsto f F (nhds x) :=
  filter.tendsto.not_tendsto hf (disjoint.symm (disjoint_nhds_at_bot x))

theorem not_tendsto_at_bot_of_tendsto_nhds {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_topology α] [no_bot_order α] {F : filter β} [filter.ne_bot F] {f : β → α} {x : α} (hf : filter.tendsto f F (nhds x)) : ¬filter.tendsto f F filter.at_bot :=
  filter.tendsto.not_tendsto hf (disjoint_nhds_at_bot x)

/-!
### Neighborhoods to the left and to the right on an `order_topology`

We've seen some properties of left and right neighborhood of a point in an `order_closed_topology`.
In an `order_topology`, such neighborhoods can be characterized as the sets containing suitable
intervals to the right or to the left of `a`. We give now these characterizations. -/

-- NB: If you extend the list, append to the end please to avoid breaking the API

/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `(a, +∞)`
1. `s` is a neighborhood of `a` within `(a, b]`
2. `s` is a neighborhood of `a` within `(a, b)`
3. `s` includes `(a, u)` for some `u ∈ (a, b]`
4. `s` includes `(a, u)` for some `u > a` -/
theorem tfae_mem_nhds_within_Ioi {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {b : α} (hab : a < b) (s : set α) : tfae
  [s ∈ nhds_within a (set.Ioi a), s ∈ nhds_within a (set.Ioc a b), s ∈ nhds_within a (set.Ioo a b),
    ∃ (u : α), ∃ (H : u ∈ set.Ioc a b), set.Ioo a u ⊆ s, ∃ (u : α), ∃ (H : u ∈ set.Ioi a), set.Ioo a u ⊆ s] := sorry

theorem mem_nhds_within_Ioi_iff_exists_mem_Ioc_Ioo_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {u' : α} {s : set α} (hu' : a < u') : s ∈ nhds_within a (set.Ioi a) ↔ ∃ (u : α), ∃ (H : u ∈ set.Ioc a u'), set.Ioo a u ⊆ s :=
  list.tfae.out (tfae_mem_nhds_within_Ioi hu' s) 0 (bit1 1)

/-- A set is a neighborhood of `a` within `(a, +∞)` if and only if it contains an interval `(a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
theorem mem_nhds_within_Ioi_iff_exists_Ioo_subset' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {u' : α} {s : set α} (hu' : a < u') : s ∈ nhds_within a (set.Ioi a) ↔ ∃ (u : α), ∃ (H : u ∈ set.Ioi a), set.Ioo a u ⊆ s :=
  list.tfae.out (tfae_mem_nhds_within_Ioi hu' s) 0 (bit0 (bit0 1))

/-- A set is a neighborhood of `a` within `(a, +∞)` if and only if it contains an interval `(a, u)`
with `a < u`. -/
theorem mem_nhds_within_Ioi_iff_exists_Ioo_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_top_order α] {a : α} {s : set α} : s ∈ nhds_within a (set.Ioi a) ↔ ∃ (u : α), ∃ (H : u ∈ set.Ioi a), set.Ioo a u ⊆ s := sorry

/-- A set is a neighborhood of `a` within `(a, +∞)` if and only if it contains an interval `(a, u]`
with `a < u`. -/
theorem mem_nhds_within_Ioi_iff_exists_Ioc_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_top_order α] [densely_ordered α] {a : α} {s : set α} : s ∈ nhds_within a (set.Ioi a) ↔ ∃ (u : α), ∃ (H : u ∈ set.Ioi a), set.Ioc a u ⊆ s := sorry

/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-∞, b)`
1. `s` is a neighborhood of `b` within `[a, b)`
2. `s` is a neighborhood of `b` within `(a, b)`
3. `s` includes `(l, b)` for some `l ∈ [a, b)`
4. `s` includes `(l, b)` for some `l < b` -/
theorem tfae_mem_nhds_within_Iio {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {b : α} (h : a < b) (s : set α) : tfae
  [s ∈ nhds_within b (set.Iio b), s ∈ nhds_within b (set.Ico a b), s ∈ nhds_within b (set.Ioo a b),
    ∃ (l : α), ∃ (H : l ∈ set.Ico a b), set.Ioo l b ⊆ s, ∃ (l : α), ∃ (H : l ∈ set.Iio b), set.Ioo l b ⊆ s] := sorry

theorem mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {l' : α} {s : set α} (hl' : l' < a) : s ∈ nhds_within a (set.Iio a) ↔ ∃ (l : α), ∃ (H : l ∈ set.Ico l' a), set.Ioo l a ⊆ s :=
  list.tfae.out (tfae_mem_nhds_within_Iio hl' s) 0 (bit1 1)

/-- A set is a neighborhood of `a` within `(-∞, a)` if and only if it contains an interval `(l, a)`
with `l < a`, provided `a` is not a bottom element. -/
theorem mem_nhds_within_Iio_iff_exists_Ioo_subset' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {l' : α} {s : set α} (hl' : l' < a) : s ∈ nhds_within a (set.Iio a) ↔ ∃ (l : α), ∃ (H : l ∈ set.Iio a), set.Ioo l a ⊆ s :=
  list.tfae.out (tfae_mem_nhds_within_Iio hl' s) 0 (bit0 (bit0 1))

/-- A set is a neighborhood of `a` within `(-∞, a)` if and only if it contains an interval `(l, a)`
with `l < a`. -/
theorem mem_nhds_within_Iio_iff_exists_Ioo_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_bot_order α] {a : α} {s : set α} : s ∈ nhds_within a (set.Iio a) ↔ ∃ (l : α), ∃ (H : l ∈ set.Iio a), set.Ioo l a ⊆ s := sorry

/-- A set is a neighborhood of `a` within `(-∞, a)` if and only if it contains an interval `[l, a)`
with `l < a`. -/
theorem mem_nhds_within_Iio_iff_exists_Ico_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_bot_order α] [densely_ordered α] {a : α} {s : set α} : s ∈ nhds_within a (set.Iio a) ↔ ∃ (l : α), ∃ (H : l ∈ set.Iio a), set.Ico l a ⊆ s := sorry

/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `[a, +∞)`
1. `s` is a neighborhood of `a` within `[a, b]`
2. `s` is a neighborhood of `a` within `[a, b)`
3. `s` includes `[a, u)` for some `u ∈ (a, b]`
4. `s` includes `[a, u)` for some `u > a` -/
theorem tfae_mem_nhds_within_Ici {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {b : α} (hab : a < b) (s : set α) : tfae
  [s ∈ nhds_within a (set.Ici a), s ∈ nhds_within a (set.Icc a b), s ∈ nhds_within a (set.Ico a b),
    ∃ (u : α), ∃ (H : u ∈ set.Ioc a b), set.Ico a u ⊆ s, ∃ (u : α), ∃ (H : u ∈ set.Ioi a), set.Ico a u ⊆ s] := sorry

theorem mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {u' : α} {s : set α} (hu' : a < u') : s ∈ nhds_within a (set.Ici a) ↔ ∃ (u : α), ∃ (H : u ∈ set.Ioc a u'), set.Ico a u ⊆ s :=
  list.tfae.out (tfae_mem_nhds_within_Ici hu' s) 0 (bit1 1)

/-- A set is a neighborhood of `a` within `[a, +∞)` if and only if it contains an interval `[a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
theorem mem_nhds_within_Ici_iff_exists_Ico_subset' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {u' : α} {s : set α} (hu' : a < u') : s ∈ nhds_within a (set.Ici a) ↔ ∃ (u : α), ∃ (H : u ∈ set.Ioi a), set.Ico a u ⊆ s :=
  list.tfae.out (tfae_mem_nhds_within_Ici hu' s) 0 (bit0 (bit0 1))

/-- A set is a neighborhood of `a` within `[a, +∞)` if and only if it contains an interval `[a, u)`
with `a < u`. -/
theorem mem_nhds_within_Ici_iff_exists_Ico_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_top_order α] {a : α} {s : set α} : s ∈ nhds_within a (set.Ici a) ↔ ∃ (u : α), ∃ (H : u ∈ set.Ioi a), set.Ico a u ⊆ s := sorry

/-- A set is a neighborhood of `a` within `[a, +∞)` if and only if it contains an interval `[a, u]`
with `a < u`. -/
theorem mem_nhds_within_Ici_iff_exists_Icc_subset' {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_top_order α] [densely_ordered α] {a : α} {s : set α} : s ∈ nhds_within a (set.Ici a) ↔ ∃ (u : α), ∃ (H : u ∈ set.Ioi a), set.Icc a u ⊆ s := sorry

/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-∞, b]`
1. `s` is a neighborhood of `b` within `[a, b]`
2. `s` is a neighborhood of `b` within `(a, b]`
3. `s` includes `(l, b]` for some `l ∈ [a, b)`
4. `s` includes `(l, b]` for some `l < b` -/
theorem tfae_mem_nhds_within_Iic {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {b : α} (h : a < b) (s : set α) : tfae
  [s ∈ nhds_within b (set.Iic b), s ∈ nhds_within b (set.Icc a b), s ∈ nhds_within b (set.Ioc a b),
    ∃ (l : α), ∃ (H : l ∈ set.Ico a b), set.Ioc l b ⊆ s, ∃ (l : α), ∃ (H : l ∈ set.Iio b), set.Ioc l b ⊆ s] := sorry

theorem mem_nhds_within_Iic_iff_exists_mem_Ico_Ioc_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {l' : α} {s : set α} (hl' : l' < a) : s ∈ nhds_within a (set.Iic a) ↔ ∃ (l : α), ∃ (H : l ∈ set.Ico l' a), set.Ioc l a ⊆ s :=
  list.tfae.out (tfae_mem_nhds_within_Iic hl' s) 0 (bit1 1)

/-- A set is a neighborhood of `a` within `(-∞, a]` if and only if it contains an interval `(l, a]`
with `l < a`, provided `a` is not a bottom element. -/
theorem mem_nhds_within_Iic_iff_exists_Ioc_subset' {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {l' : α} {s : set α} (hl' : l' < a) : s ∈ nhds_within a (set.Iic a) ↔ ∃ (l : α), ∃ (H : l ∈ set.Iio a), set.Ioc l a ⊆ s :=
  list.tfae.out (tfae_mem_nhds_within_Iic hl' s) 0 (bit0 (bit0 1))

/-- A set is a neighborhood of `a` within `(-∞, a]` if and only if it contains an interval `(l, a]`
with `l < a`. -/
theorem mem_nhds_within_Iic_iff_exists_Ioc_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_bot_order α] {a : α} {s : set α} : s ∈ nhds_within a (set.Iic a) ↔ ∃ (l : α), ∃ (H : l ∈ set.Iio a), set.Ioc l a ⊆ s := sorry

/-- A set is a neighborhood of `a` within `(-∞, a]` if and only if it contains an interval `[l, a]`
with `l < a`. -/
theorem mem_nhds_within_Iic_iff_exists_Icc_subset' {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_bot_order α] [densely_ordered α] {a : α} {s : set α} : s ∈ nhds_within a (set.Iic a) ↔ ∃ (l : α), ∃ (H : l ∈ set.Iio a), set.Icc l a ⊆ s := sorry

/-- A set is a neighborhood of `a` within `[a, +∞)` if and only if it contains an interval `[a, u]`
with `a < u`. -/
theorem mem_nhds_within_Ici_iff_exists_Icc_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_top_order α] [densely_ordered α] {a : α} {s : set α} : s ∈ nhds_within a (set.Ici a) ↔ ∃ (u : α), a < u ∧ set.Icc a u ⊆ s := sorry

/-- A set is a neighborhood of `a` within `(-∞, a]` if and only if it contains an interval `[l, a]`
with `l < a`. -/
theorem mem_nhds_within_Iic_iff_exists_Icc_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [no_bot_order α] [densely_ordered α] {a : α} {s : set α} : s ∈ nhds_within a (set.Iic a) ↔ ∃ (l : α), l < a ∧ set.Icc l a ⊆ s := sorry

theorem nhds_eq_infi_abs_sub {α : Type u} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] (a : α) : nhds a = infi fun (r : α) => infi fun (H : r > 0) => filter.principal (set_of fun (b : α) => abs (a - b) < r) := sorry

theorem order_topology_of_nhds_abs {α : Type u_1} [topological_space α] [linear_ordered_add_comm_group α] (h_nhds : ∀ (a : α), nhds a = infi fun (r : α) => infi fun (H : r > 0) => filter.principal (set_of fun (b : α) => abs (a - b) < r)) : order_topology α := sorry

theorem linear_ordered_add_comm_group.tendsto_nhds {α : Type u} {β : Type v} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] {f : β → α} {x : filter β} {a : α} : filter.tendsto f x (nhds a) ↔ ∀ (ε : α), ε > 0 → filter.eventually (fun (b : β) => abs (f b - a) < ε) x := sorry

theorem eventually_abs_sub_lt {α : Type u} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] (a : α) {ε : α} (hε : 0 < ε) : filter.eventually (fun (x : α) => abs (x - a) < ε) (nhds a) := sorry

protected instance linear_ordered_add_comm_group.topological_add_group {α : Type u} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] : topological_add_group α :=
  topological_add_group.mk
    (iff.mpr continuous_iff_continuous_at
      fun (a : α) =>
        iff.mpr linear_ordered_add_comm_group.tendsto_nhds
          fun (ε : α) (ε0 : ε > 0) =>
            filter.eventually.mono (eventually_abs_sub_lt a ε0)
              fun (x : α) (hx : abs (x - a) < ε) =>
                eq.mpr (id (Eq._oldrec (Eq.refl (abs (-x - (fun (a : α) => -a) a) < ε)) (neg_sub_neg x a)))
                  (eq.mpr (id (Eq._oldrec (Eq.refl (abs (a - x) < ε)) (abs_sub a x))) hx))

theorem continuous_abs {α : Type u} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] : continuous abs :=
  continuous.max continuous_id continuous_neg

theorem filter.tendsto.abs {α : Type u} {β : Type v} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] {f : β → α} {a : α} {l : filter β} (h : filter.tendsto f l (nhds a)) : filter.tendsto (fun (x : β) => abs (f x)) l (nhds (abs a)) :=
  filter.tendsto.comp (continuous.tendsto continuous_abs a) h

theorem continuous.abs {α : Type u} {β : Type v} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] {f : β → α} [topological_space β] (h : continuous f) : continuous fun (x : β) => abs (f x) :=
  continuous.comp continuous_abs h

theorem continuous_at.abs {α : Type u} {β : Type v} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] {f : β → α} [topological_space β] {b : β} (h : continuous_at f b) : continuous_at (fun (x : β) => abs (f x)) b :=
  filter.tendsto.abs h

theorem continuous_within_at.abs {α : Type u} {β : Type v} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] {f : β → α} [topological_space β] {b : β} {s : set β} (h : continuous_within_at f s b) : continuous_within_at (fun (x : β) => abs (f x)) s b :=
  filter.tendsto.abs h

theorem continuous_on.abs {α : Type u} {β : Type v} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] {f : β → α} [topological_space β] {s : set β} (h : continuous_on f s) : continuous_on (fun (x : β) => abs (f x)) s :=
  fun (x : β) (hx : x ∈ s) => continuous_within_at.abs (h x hx)

theorem tendsto_abs_nhds_within_zero {α : Type u} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] : filter.tendsto abs (nhds_within 0 (singleton 0ᶜ)) (nhds_within 0 (set.Ioi 0)) :=
  filter.tendsto.inf (continuous.tendsto' continuous_abs 0 0 abs_zero)
    (iff.mpr filter.tendsto_principal_principal fun (x : α) => iff.mpr abs_pos)

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `at_top` then `f + g` tends to `at_top`. -/
theorem filter.tendsto.add_at_top {α : Type u} {β : Type v} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] {l : filter β} {f : β → α} {g : β → α} {C : α} (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_top) : filter.tendsto (fun (x : β) => f x + g x) l filter.at_top := sorry

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `at_bot` then `f + g` tends to `at_bot`. -/
theorem filter.tendsto.add_at_bot {α : Type u} {β : Type v} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] {l : filter β} {f : β → α} {g : β → α} {C : α} (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_bot) : filter.tendsto (fun (x : β) => f x + g x) l filter.at_bot :=
  filter.tendsto.add_at_top hf hg

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`at_top` and `g` tends to `C` then `f + g` tends to `at_top`. -/
theorem filter.tendsto.at_top_add {α : Type u} {β : Type v} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] {l : filter β} {f : β → α} {g : β → α} {C : α} (hf : filter.tendsto f l filter.at_top) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (fun (x : β) => f x + g x) l filter.at_top := sorry

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`at_bot` and `g` tends to `C` then `f + g` tends to `at_bot`. -/
theorem filter.tendsto.at_bot_add {α : Type u} {β : Type v} [topological_space α] [linear_ordered_add_comm_group α] [order_topology α] {l : filter β} {f : β → α} {g : β → α} {C : α} (hf : filter.tendsto f l filter.at_bot) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (fun (x : β) => f x + g x) l filter.at_bot := sorry

/-- In a linearly ordered field with the order topology, if `f` tends to `at_top` and `g` tends to
a positive constant `C` then `f * g` tends to `at_top`. -/
theorem filter.tendsto.at_top_mul {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f : β → α} {g : β → α} {C : α} (hC : 0 < C) (hf : filter.tendsto f l filter.at_top) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (fun (x : β) => f x * g x) l filter.at_top := sorry

/-- In a linearly ordered field with the order topology, if `f` tends to a positive constant `C` and
`g` tends to `at_top` then `f * g` tends to `at_top`. -/
theorem filter.tendsto.mul_at_top {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f : β → α} {g : β → α} {C : α} (hC : 0 < C) (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_top) : filter.tendsto (fun (x : β) => f x * g x) l filter.at_top := sorry

/-- In a linearly ordered field with the order topology, if `f` tends to `at_top` and `g` tends to
a negative constant `C` then `f * g` tends to `at_bot`. -/
theorem filter.tendsto.at_top_mul_neg {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f : β → α} {g : β → α} {C : α} (hC : C < 0) (hf : filter.tendsto f l filter.at_top) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (fun (x : β) => f x * g x) l filter.at_bot := sorry

/-- In a linearly ordered field with the order topology, if `f` tends to a negative constant `C` and
`g` tends to `at_top` then `f * g` tends to `at_bot`. -/
theorem filter.tendsto.neg_mul_at_top {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f : β → α} {g : β → α} {C : α} (hC : C < 0) (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_top) : filter.tendsto (fun (x : β) => f x * g x) l filter.at_bot := sorry

/-- In a linearly ordered field with the order topology, if `f` tends to `at_bot` and `g` tends to
a positive constant `C` then `f * g` tends to `at_bot`. -/
theorem filter.tendsto.at_bot_mul {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f : β → α} {g : β → α} {C : α} (hC : 0 < C) (hf : filter.tendsto f l filter.at_bot) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (fun (x : β) => f x * g x) l filter.at_bot := sorry

/-- In a linearly ordered field with the order topology, if `f` tends to `at_bot` and `g` tends to
a negative constant `C` then `f * g` tends to `at_top`. -/
theorem filter.tendsto.at_bot_mul_neg {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f : β → α} {g : β → α} {C : α} (hC : C < 0) (hf : filter.tendsto f l filter.at_bot) (hg : filter.tendsto g l (nhds C)) : filter.tendsto (fun (x : β) => f x * g x) l filter.at_top := sorry

/-- In a linearly ordered field with the order topology, if `f` tends to a positive constant `C` and
`g` tends to `at_bot` then `f * g` tends to `at_bot`. -/
theorem filter.tendsto.mul_at_bot {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f : β → α} {g : β → α} {C : α} (hC : 0 < C) (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_bot) : filter.tendsto (fun (x : β) => f x * g x) l filter.at_bot := sorry

/-- In a linearly ordered field with the order topology, if `f` tends to a negative constant `C` and
`g` tends to `at_bot` then `f * g` tends to `at_top`. -/
theorem filter.tendsto.neg_mul_at_bot {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f : β → α} {g : β → α} {C : α} (hC : C < 0) (hf : filter.tendsto f l (nhds C)) (hg : filter.tendsto g l filter.at_bot) : filter.tendsto (fun (x : β) => f x * g x) l filter.at_top := sorry

/-- The function `x ↦ x⁻¹` tends to `+∞` on the right of `0`. -/
theorem tendsto_inv_zero_at_top {α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] : filter.tendsto (fun (x : α) => x⁻¹) (nhds_within 0 (set.Ioi 0)) filter.at_top := sorry

/-- The function `r ↦ r⁻¹` tends to `0` on the right as `r → +∞`. -/
theorem tendsto_inv_at_top_zero' {α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] : filter.tendsto (fun (r : α) => r⁻¹) filter.at_top (nhds_within 0 (set.Ioi 0)) := sorry

theorem tendsto_inv_at_top_zero {α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] : filter.tendsto (fun (r : α) => r⁻¹) filter.at_top (nhds 0) :=
  filter.tendsto.mono_right tendsto_inv_at_top_zero' inf_le_left

theorem filter.tendsto.div_at_top {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] [has_continuous_mul α] {f : β → α} {g : β → α} {l : filter β} {a : α} (h : filter.tendsto f l (nhds a)) (hg : filter.tendsto g l filter.at_top) : filter.tendsto (fun (x : β) => f x / g x) l (nhds 0) := sorry

theorem tendsto.inv_tendsto_at_top {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f : β → α} (h : filter.tendsto f l filter.at_top) : filter.tendsto (f⁻¹) l (nhds 0) :=
  filter.tendsto.comp tendsto_inv_at_top_zero h

theorem tendsto.inv_tendsto_zero {α : Type u} {β : Type v} [linear_ordered_field α] [topological_space α] [order_topology α] {l : filter β} {f : β → α} (h : filter.tendsto f l (nhds_within 0 (set.Ioi 0))) : filter.tendsto (f⁻¹) l filter.at_top :=
  filter.tendsto.comp tendsto_inv_zero_at_top h

/-- The function `x^(-n)` tends to `0` at `+∞` for any positive natural `n`.
A version for positive real powers exists as `tendsto_rpow_neg_at_top`. -/
theorem tendsto_pow_neg_at_top {α : Type u} [linear_ordered_field α] [topological_space α] [order_topology α] {n : ℕ} (hn : 1 ≤ n) : filter.tendsto (fun (x : α) => x ^ (-↑n)) filter.at_top (nhds 0) :=
  filter.tendsto.congr (fun (x : α) => Eq.symm (fpow_neg x ↑n))
    (tendsto.inv_tendsto_at_top (filter.tendsto_pow_at_top hn))

theorem preimage_neg {α : Type u} [add_group α] : set.preimage Neg.neg = set.image Neg.neg :=
  Eq.symm (set.image_eq_preimage_of_inverse neg_neg neg_neg)

theorem filter.map_neg {α : Type u} [add_group α] : filter.map Neg.neg = filter.comap Neg.neg :=
  funext fun (f : filter α) => filter.map_eq_comap_of_inverse (funext neg_neg) (funext neg_neg)

theorem is_lub.nhds_within_ne_bot {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {s : set α} (ha : is_lub s a) (hs : set.nonempty s) : filter.ne_bot (nhds_within a s) := sorry

theorem is_glb.nhds_within_ne_bot {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {s : set α} : is_glb s a → set.nonempty s → filter.ne_bot (nhds_within a s) :=
  is_lub.nhds_within_ne_bot

theorem is_lub_of_mem_nhds {α : Type u} [topological_space α] [linear_order α] [order_topology α] {s : set α} {a : α} {f : filter α} (hsa : a ∈ upper_bounds s) (hsf : s ∈ f) [filter.ne_bot (f ⊓ nhds a)] : is_lub s a := sorry

theorem is_glb_of_mem_nhds {α : Type u} [topological_space α] [linear_order α] [order_topology α] {s : set α} {a : α} {f : filter α} : a ∈ lower_bounds s → s ∈ f → filter.ne_bot (f ⊓ nhds a) → is_glb s a :=
  is_lub_of_mem_nhds

theorem is_lub_of_is_lub_of_tendsto {α : Type u} {β : Type v} [topological_space α] [topological_space β] [linear_order α] [linear_order β] [order_topology α] [order_topology β] {f : α → β} {s : set α} {a : α} {b : β} (hf : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → f x ≤ f y) (ha : is_lub s a) (hs : set.nonempty s) (hb : filter.tendsto f (nhds_within a s) (nhds b)) : is_lub (f '' s) b := sorry

theorem is_glb_of_is_glb_of_tendsto {α : Type u} {β : Type v} [topological_space α] [topological_space β] [linear_order α] [linear_order β] [order_topology α] [order_topology β] {f : α → β} {s : set α} {a : α} {b : β} (hf : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → f x ≤ f y) : is_glb s a → set.nonempty s → filter.tendsto f (nhds_within a s) (nhds b) → is_glb (f '' s) b :=
  is_lub_of_is_lub_of_tendsto fun (x : order_dual α) (hx : x ∈ s) (y : order_dual α) (hy : y ∈ s) => hf y hy x hx

theorem is_glb_of_is_lub_of_tendsto {α : Type u} {β : Type v} [topological_space α] [topological_space β] [linear_order α] [linear_order β] [order_topology α] [order_topology β] {f : α → β} {s : set α} {a : α} {b : β} : (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → f y ≤ f x) →
  is_lub s a → set.nonempty s → filter.tendsto f (nhds_within a s) (nhds b) → is_glb (f '' s) b :=
  is_lub_of_is_lub_of_tendsto

theorem is_lub_of_is_glb_of_tendsto {α : Type u} {β : Type v} [topological_space α] [topological_space β] [linear_order α] [linear_order β] [order_topology α] [order_topology β] {f : α → β} {s : set α} {a : α} {b : β} : (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → f y ≤ f x) →
  is_glb s a → set.nonempty s → filter.tendsto f (nhds_within a s) (nhds b) → is_lub (f '' s) b :=
  is_glb_of_is_glb_of_tendsto

theorem mem_closure_of_is_lub {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {s : set α} (ha : is_lub s a) (hs : set.nonempty s) : a ∈ closure s :=
  eq.mpr (id (Eq._oldrec (Eq.refl (a ∈ closure s)) closure_eq_cluster_pts)) (is_lub.nhds_within_ne_bot ha hs)

theorem mem_of_is_lub_of_is_closed {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {s : set α} (ha : is_lub s a) (hs : set.nonempty s) (sc : is_closed s) : a ∈ s :=
  eq.mpr (id (Eq._oldrec (Eq.refl (a ∈ s)) (Eq.symm (is_closed.closure_eq sc)))) (mem_closure_of_is_lub ha hs)

theorem mem_closure_of_is_glb {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {s : set α} (ha : is_glb s a) (hs : set.nonempty s) : a ∈ closure s :=
  eq.mpr (id (Eq._oldrec (Eq.refl (a ∈ closure s)) closure_eq_cluster_pts)) (is_glb.nhds_within_ne_bot ha hs)

theorem mem_of_is_glb_of_is_closed {α : Type u} [topological_space α] [linear_order α] [order_topology α] {a : α} {s : set α} (ha : is_glb s a) (hs : set.nonempty s) (sc : is_closed s) : a ∈ s :=
  eq.mpr (id (Eq._oldrec (Eq.refl (a ∈ s)) (Eq.symm (is_closed.closure_eq sc)))) (mem_closure_of_is_glb ha hs)

/-- A compact set is bounded below -/
theorem is_compact.bdd_below {α : Type u} [topological_space α] [linear_order α] [order_closed_topology α] [Nonempty α] {s : set α} (hs : is_compact s) : bdd_below s := sorry

/-- A compact set is bounded above -/
theorem is_compact.bdd_above {α : Type u} [topological_space α] [linear_order α] [order_topology α] [Nonempty α] {s : set α} : is_compact s → bdd_above s :=
  is_compact.bdd_below

/-- The closure of the interval `(a, +∞)` is the closed interval `[a, +∞)`, unless `a` is a top
element. -/
theorem closure_Ioi' {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {b : α} (hab : a < b) : closure (set.Ioi a) = set.Ici a := sorry

/-- The closure of the interval `(a, +∞)` is the closed interval `[a, +∞)`. -/
@[simp] theorem closure_Ioi {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_top_order α] : closure (set.Ioi a) = set.Ici a :=
  (fun (_a : ∃ (a' : α), a < a') =>
      Exists.dcases_on _a fun (w : α) (h : a < w) => idRhs (closure (set.Ioi a) = set.Ici a) (closure_Ioi' h))
    (no_top a)

/-- The closure of the interval `(-∞, a)` is the closed interval `(-∞, a]`, unless `a` is a bottom
element. -/
theorem closure_Iio' {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {b : α} (hab : b < a) : closure (set.Iio a) = set.Iic a := sorry

/-- The closure of the interval `(-∞, a)` is the interval `(-∞, a]`. -/
@[simp] theorem closure_Iio {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) [no_bot_order α] : closure (set.Iio a) = set.Iic a :=
  (fun (_a : ∃ (a' : α), a' < a) =>
      Exists.dcases_on _a fun (w : α) (h : w < a) => idRhs (closure (set.Iio a) = set.Iic a) (closure_Iio' h))
    (no_bot a)

/-- The closure of the open interval `(a, b)` is the closed interval `[a, b]`. -/
@[simp] theorem closure_Ioo {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {b : α} (hab : a < b) : closure (set.Ioo a b) = set.Icc a b := sorry

/-- The closure of the interval `(a, b]` is the closed interval `[a, b]`. -/
@[simp] theorem closure_Ioc {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {b : α} (hab : a < b) : closure (set.Ioc a b) = set.Icc a b := sorry

/-- The closure of the interval `[a, b)` is the closed interval `[a, b]`. -/
@[simp] theorem closure_Ico {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {b : α} (hab : a < b) : closure (set.Ico a b) = set.Icc a b := sorry

@[simp] theorem interior_Ici {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [no_bot_order α] {a : α} : interior (set.Ici a) = set.Ioi a := sorry

@[simp] theorem interior_Iic {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [no_top_order α] {a : α} : interior (set.Iic a) = set.Iio a := sorry

@[simp] theorem interior_Icc {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [no_bot_order α] [no_top_order α] {a : α} {b : α} : interior (set.Icc a b) = set.Ioo a b := sorry

@[simp] theorem interior_Ico {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [no_bot_order α] {a : α} {b : α} : interior (set.Ico a b) = set.Ioo a b := sorry

@[simp] theorem interior_Ioc {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [no_top_order α] {a : α} {b : α} : interior (set.Ioc a b) = set.Ioo a b := sorry

@[simp] theorem frontier_Ici {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [no_bot_order α] {a : α} : frontier (set.Ici a) = singleton a := sorry

@[simp] theorem frontier_Iic {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [no_top_order α] {a : α} : frontier (set.Iic a) = singleton a := sorry

@[simp] theorem frontier_Ioi {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [no_top_order α] {a : α} : frontier (set.Ioi a) = singleton a := sorry

@[simp] theorem frontier_Iio {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [no_bot_order α] {a : α} : frontier (set.Iio a) = singleton a := sorry

@[simp] theorem frontier_Icc {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [no_bot_order α] [no_top_order α] {a : α} {b : α} (h : a < b) : frontier (set.Icc a b) = insert a (singleton b) := sorry

@[simp] theorem frontier_Ioo {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {b : α} (h : a < b) : frontier (set.Ioo a b) = insert a (singleton b) := sorry

@[simp] theorem frontier_Ico {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [no_bot_order α] {a : α} {b : α} (h : a < b) : frontier (set.Ico a b) = insert a (singleton b) := sorry

@[simp] theorem frontier_Ioc {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [no_top_order α] {a : α} {b : α} (h : a < b) : frontier (set.Ioc a b) = insert a (singleton b) := sorry

theorem nhds_within_Ioi_ne_bot' {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {b : α} {c : α} (H₁ : a < c) (H₂ : a ≤ b) : filter.ne_bot (nhds_within b (set.Ioi a)) :=
  iff.mp mem_closure_iff_nhds_within_ne_bot
    (eq.mpr (id (Eq._oldrec (Eq.refl (b ∈ closure (set.Ioi a))) (closure_Ioi' H₁))) H₂)

theorem nhds_within_Ioi_ne_bot {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [no_top_order α] {a : α} {b : α} (H : a ≤ b) : filter.ne_bot (nhds_within b (set.Ioi a)) := sorry

theorem nhds_within_Ioi_self_ne_bot' {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {b : α} (H : a < b) : filter.ne_bot (nhds_within a (set.Ioi a)) :=
  nhds_within_Ioi_ne_bot' H (le_refl a)

instance nhds_within_Ioi_self_ne_bot {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [no_top_order α] (a : α) : filter.ne_bot (nhds_within a (set.Ioi a)) :=
  nhds_within_Ioi_ne_bot (le_refl a)

theorem nhds_within_Iio_ne_bot' {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {b : α} {c : α} (H₁ : a < c) (H₂ : b ≤ c) : filter.ne_bot (nhds_within b (set.Iio c)) :=
  iff.mp mem_closure_iff_nhds_within_ne_bot
    (eq.mpr (id (Eq._oldrec (Eq.refl (b ∈ closure (set.Iio c))) (closure_Iio' H₁))) H₂)

theorem nhds_within_Iio_ne_bot {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [no_bot_order α] {a : α} {b : α} (H : a ≤ b) : filter.ne_bot (nhds_within a (set.Iio b)) := sorry

theorem nhds_within_Iio_self_ne_bot' {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {b : α} (H : a < b) : filter.ne_bot (nhds_within b (set.Iio b)) :=
  nhds_within_Iio_ne_bot' H (le_refl b)

instance nhds_within_Iio_self_ne_bot {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] [no_bot_order α] (a : α) : filter.ne_bot (nhds_within a (set.Iio a)) :=
  nhds_within_Iio_ne_bot (le_refl a)

theorem comap_coe_nhds_within_Iio_of_Ioo_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {b : α} {s : set α} (hb : s ⊆ set.Iio b) (hs : set.nonempty s → ∃ (a : α), ∃ (H : a < b), set.Ioo a b ⊆ s) : filter.comap coe (nhds_within b (set.Iio b)) = filter.at_top := sorry

theorem comap_coe_nhds_within_Ioi_of_Ioo_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {s : set α} (ha : s ⊆ set.Ioi a) (hs : set.nonempty s → ∃ (b : α), ∃ (H : b > a), set.Ioo a b ⊆ s) : filter.comap coe (nhds_within a (set.Ioi a)) = filter.at_bot := sorry

theorem map_coe_at_top_of_Ioo_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {b : α} {s : set α} (hb : s ⊆ set.Iio b) (hs : ∀ (a' : α) (H : a' < b), ∃ (a : α), ∃ (H : a < b), set.Ioo a b ⊆ s) : filter.map coe filter.at_top = nhds_within b (set.Iio b) := sorry

theorem map_coe_at_bot_of_Ioo_subset {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {s : set α} (ha : s ⊆ set.Ioi a) (hs : ∀ (b' : α) (H : b' > a), ∃ (b : α), ∃ (H : b > a), set.Ioo a b ⊆ s) : filter.map coe filter.at_bot = nhds_within a (set.Ioi a) := sorry

/-- The `at_top` filter for an open interval `Ioo a b` comes from the left-neighbourhoods filter at
the right endpoint in the ambient order. -/
theorem comap_coe_Ioo_nhds_within_Iio {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) (b : α) : filter.comap coe (nhds_within b (set.Iio b)) = filter.at_top :=
  comap_coe_nhds_within_Iio_of_Ioo_subset set.Ioo_subset_Iio_self
    fun (h : set.nonempty (set.Ioo a b)) =>
      Exists.intro a (Exists.intro (iff.mp set.nonempty_Ioo h) (set.subset.refl (set.Ioo a b)))

/-- The `at_bot` filter for an open interval `Ioo a b` comes from the right-neighbourhoods filter at
the left endpoint in the ambient order. -/
theorem comap_coe_Ioo_nhds_within_Ioi {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) (b : α) : filter.comap coe (nhds_within a (set.Ioi a)) = filter.at_bot :=
  comap_coe_nhds_within_Ioi_of_Ioo_subset set.Ioo_subset_Ioi_self
    fun (h : set.nonempty (set.Ioo a b)) =>
      Exists.intro b (Exists.intro (iff.mp set.nonempty_Ioo h) (set.subset.refl (set.Ioo a b)))

theorem comap_coe_Ioi_nhds_within_Ioi {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) : filter.comap coe (nhds_within a (set.Ioi a)) = filter.at_bot := sorry

theorem comap_coe_Iio_nhds_within_Iio {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) : filter.comap coe (nhds_within a (set.Iio a)) = filter.at_top :=
  comap_coe_Ioi_nhds_within_Ioi a

@[simp] theorem map_coe_Ioo_at_top {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {b : α} (h : a < b) : filter.map coe filter.at_top = nhds_within b (set.Iio b) :=
  map_coe_at_top_of_Ioo_subset set.Ioo_subset_Iio_self
    fun (_x : α) (_x : _x < b) => Exists.intro a (Exists.intro h (set.subset.refl (set.Ioo a b)))

@[simp] theorem map_coe_Ioo_at_bot {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {b : α} (h : a < b) : filter.map coe filter.at_bot = nhds_within a (set.Ioi a) :=
  map_coe_at_bot_of_Ioo_subset set.Ioo_subset_Ioi_self
    fun (_x : α) (_x : _x > a) => Exists.intro b (Exists.intro h (set.subset.refl (set.Ioo a b)))

@[simp] theorem map_coe_Ioi_at_bot {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) : filter.map coe filter.at_bot = nhds_within a (set.Ioi a) :=
  map_coe_at_bot_of_Ioo_subset (set.subset.refl (set.Ioi a))
    fun (b : α) (hb : b > a) => Exists.intro b (Exists.intro hb set.Ioo_subset_Ioi_self)

@[simp] theorem map_coe_Iio_at_top {α : Type u} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] (a : α) : filter.map coe filter.at_top = nhds_within a (set.Iio a) :=
  map_coe_Ioi_at_bot a

@[simp] theorem tendsto_comp_coe_Ioo_at_top {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {b : α} {l : filter β} {f : α → β} (h : a < b) : filter.tendsto (fun (x : ↥(set.Ioo a b)) => f ↑x) filter.at_top l ↔ filter.tendsto f (nhds_within b (set.Iio b)) l := sorry

@[simp] theorem tendsto_comp_coe_Ioo_at_bot {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {b : α} {l : filter β} {f : α → β} (h : a < b) : filter.tendsto (fun (x : ↥(set.Ioo a b)) => f ↑x) filter.at_bot l ↔ filter.tendsto f (nhds_within a (set.Ioi a)) l := sorry

@[simp] theorem tendsto_comp_coe_Ioi_at_bot {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {l : filter β} {f : α → β} : filter.tendsto (fun (x : ↥(set.Ioi a)) => f ↑x) filter.at_bot l ↔ filter.tendsto f (nhds_within a (set.Ioi a)) l := sorry

@[simp] theorem tendsto_comp_coe_Iio_at_top {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {l : filter β} {f : α → β} : filter.tendsto (fun (x : ↥(set.Iio a)) => f ↑x) filter.at_top l ↔ filter.tendsto f (nhds_within a (set.Iio a)) l := sorry

@[simp] theorem tendsto_Ioo_at_top {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {b : α} {l : filter β} {f : β → ↥(set.Ioo a b)} : filter.tendsto f l filter.at_top ↔ filter.tendsto (fun (x : β) => ↑(f x)) l (nhds_within b (set.Iio b)) := sorry

@[simp] theorem tendsto_Ioo_at_bot {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {b : α} {l : filter β} {f : β → ↥(set.Ioo a b)} : filter.tendsto f l filter.at_bot ↔ filter.tendsto (fun (x : β) => ↑(f x)) l (nhds_within a (set.Ioi a)) := sorry

@[simp] theorem tendsto_Ioi_at_bot {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {l : filter β} {f : β → ↥(set.Ioi a)} : filter.tendsto f l filter.at_bot ↔ filter.tendsto (fun (x : β) => ↑(f x)) l (nhds_within a (set.Ioi a)) := sorry

@[simp] theorem tendsto_Iio_at_top {α : Type u} {β : Type v} [topological_space α] [linear_order α] [order_topology α] [densely_ordered α] {a : α} {l : filter β} {f : β → ↥(set.Iio a)} : filter.tendsto f l filter.at_top ↔ filter.tendsto (fun (x : β) => ↑(f x)) l (nhds_within a (set.Iio a)) := sorry

theorem Sup_mem_closure {α : Type u} [topological_space α] [complete_linear_order α] [order_topology α] {s : set α} (hs : set.nonempty s) : Sup s ∈ closure s :=
  mem_closure_of_is_lub (is_lub_Sup s) hs

theorem Inf_mem_closure {α : Type u} [topological_space α] [complete_linear_order α] [order_topology α] {s : set α} (hs : set.nonempty s) : Inf s ∈ closure s :=
  mem_closure_of_is_glb (is_glb_Inf s) hs

theorem is_closed.Sup_mem {α : Type u} [topological_space α] [complete_linear_order α] [order_topology α] {s : set α} (hs : set.nonempty s) (hc : is_closed s) : Sup s ∈ s :=
  mem_of_is_lub_of_is_closed (is_lub_Sup s) hs hc

theorem is_closed.Inf_mem {α : Type u} [topological_space α] [complete_linear_order α] [order_topology α] {s : set α} (hs : set.nonempty s) (hc : is_closed s) : Inf s ∈ s :=
  mem_of_is_glb_of_is_closed (is_glb_Inf s) hs hc

/-- A monotone function continuous at the supremum of a nonempty set sends this supremum to
the supremum of the image of this set. -/
theorem map_Sup_of_continuous_at_of_monotone' {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (Sup s)) (Mf : monotone f) (hs : set.nonempty s) : f (Sup s) = Sup (f '' s) := sorry

--This is a particular case of the more general is_lub_of_is_lub_of_tendsto

/-- A monotone function `s` sending `bot` to `bot` and continuous at the supremum of a set sends
this supremum to the supremum of the image of this set. -/
theorem map_Sup_of_continuous_at_of_monotone {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (Sup s)) (Mf : monotone f) (fbot : f ⊥ = ⊥) : f (Sup s) = Sup (f '' s) := sorry

/-- A monotone function continuous at the indexed supremum over a nonempty `Sort` sends this indexed
supremum to the indexed supremum of the composition. -/
theorem map_supr_of_continuous_at_of_monotone' {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {ι : Sort u_1} [Nonempty ι] {f : α → β} {g : ι → α} (Cf : continuous_at f (supr g)) (Mf : monotone f) : f (supr fun (i : ι) => g i) = supr fun (i : ι) => f (g i) := sorry

/-- If a monotone function sending `bot` to `bot` is continuous at the indexed supremum over
a `Sort`, then it sends this indexed supremum to the indexed supremum of the composition. -/
theorem map_supr_of_continuous_at_of_monotone {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {ι : Sort u_1} {f : α → β} {g : ι → α} (Cf : continuous_at f (supr g)) (Mf : monotone f) (fbot : f ⊥ = ⊥) : f (supr fun (i : ι) => g i) = supr fun (i : ι) => f (g i) := sorry

/-- A monotone function continuous at the infimum of a nonempty set sends this infimum to
the infimum of the image of this set. -/
theorem map_Inf_of_continuous_at_of_monotone' {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (Inf s)) (Mf : monotone f) (hs : set.nonempty s) : f (Inf s) = Inf (f '' s) :=
  map_Sup_of_continuous_at_of_monotone' Cf (monotone.order_dual Mf) hs

/-- A monotone function `s` sending `top` to `top` and continuous at the infimum of a set sends
this infimum to the infimum of the image of this set. -/
theorem map_Inf_of_continuous_at_of_monotone {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (Inf s)) (Mf : monotone f) (ftop : f ⊤ = ⊤) : f (Inf s) = Inf (f '' s) :=
  map_Sup_of_continuous_at_of_monotone Cf (monotone.order_dual Mf) ftop

/-- A monotone function continuous at the indexed infimum over a nonempty `Sort` sends this indexed
infimum to the indexed infimum of the composition. -/
theorem map_infi_of_continuous_at_of_monotone' {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {ι : Sort u_1} [Nonempty ι] {f : α → β} {g : ι → α} (Cf : continuous_at f (infi g)) (Mf : monotone f) : f (infi fun (i : ι) => g i) = infi fun (i : ι) => f (g i) :=
  map_supr_of_continuous_at_of_monotone' Cf (monotone.order_dual Mf)

/-- If a monotone function sending `top` to `top` is continuous at the indexed infimum over
a `Sort`, then it sends this indexed infimum to the indexed infimum of the composition. -/
theorem map_infi_of_continuous_at_of_monotone {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] [complete_linear_order β] [topological_space β] [order_topology β] {ι : Sort u_1} {f : α → β} {g : ι → α} (Cf : continuous_at f (infi g)) (Mf : monotone f) (ftop : f ⊤ = ⊤) : f (infi g) = infi (f ∘ g) :=
  map_supr_of_continuous_at_of_monotone Cf (monotone.order_dual Mf) ftop

theorem cSup_mem_closure {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : set.nonempty s) (B : bdd_above s) : Sup s ∈ closure s :=
  mem_closure_of_is_lub (is_lub_cSup hs B) hs

theorem cInf_mem_closure {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : set.nonempty s) (B : bdd_below s) : Inf s ∈ closure s :=
  mem_closure_of_is_glb (is_glb_cInf hs B) hs

theorem is_closed.cSup_mem {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hc : is_closed s) (hs : set.nonempty s) (B : bdd_above s) : Sup s ∈ s :=
  mem_of_is_lub_of_is_closed (is_lub_cSup hs B) hs hc

theorem is_closed.cInf_mem {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hc : is_closed s) (hs : set.nonempty s) (B : bdd_below s) : Inf s ∈ s :=
  mem_of_is_glb_of_is_closed (is_glb_cInf hs B) hs hc

/-- If a monotone function is continuous at the supremum of a nonempty bounded above set `s`,
then it sends this supremum to the supremum of the image of `s`. -/
theorem map_cSup_of_continuous_at_of_monotone {α : Type u} {β : Type v} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [conditionally_complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (Sup s)) (Mf : monotone f) (ne : set.nonempty s) (H : bdd_above s) : f (Sup s) = Sup (f '' s) := sorry

/-- If a monotone function is continuous at the indexed supremum of a bounded function on
a nonempty `Sort`, then it sends this supremum to the supremum of the composition. -/
theorem map_csupr_of_continuous_at_of_monotone {α : Type u} {β : Type v} {γ : Type w} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [conditionally_complete_linear_order β] [topological_space β] [order_topology β] [Nonempty γ] {f : α → β} {g : γ → α} (Cf : continuous_at f (supr fun (i : γ) => g i)) (Mf : monotone f) (H : bdd_above (set.range g)) : f (supr fun (i : γ) => g i) = supr fun (i : γ) => f (g i) := sorry

/-- If a monotone function is continuous at the infimum of a nonempty bounded below set `s`,
then it sends this infimum to the infimum of the image of `s`. -/
theorem map_cInf_of_continuous_at_of_monotone {α : Type u} {β : Type v} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [conditionally_complete_linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} (Cf : continuous_at f (Inf s)) (Mf : monotone f) (ne : set.nonempty s) (H : bdd_below s) : f (Inf s) = Inf (f '' s) :=
  map_cSup_of_continuous_at_of_monotone Cf (monotone.order_dual Mf) ne H

/-- A continuous monotone function sends indexed infimum to indexed infimum in conditionally
complete linear order, under a boundedness assumption. -/
theorem map_cinfi_of_continuous_at_of_monotone {α : Type u} {β : Type v} {γ : Type w} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [conditionally_complete_linear_order β] [topological_space β] [order_topology β] [Nonempty γ] {f : α → β} {g : γ → α} (Cf : continuous_at f (infi fun (i : γ) => g i)) (Mf : monotone f) (H : bdd_below (set.range g)) : f (infi fun (i : γ) => g i) = infi fun (i : γ) => f (g i) :=
  map_csupr_of_continuous_at_of_monotone Cf (monotone.order_dual Mf) H

/-- A bounded connected subset of a conditionally complete linear order includes the open interval
`(Inf s, Sup s)`. -/
theorem is_connected.Ioo_cInf_cSup_subset {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : is_connected s) (hb : bdd_below s) (ha : bdd_above s) : set.Ioo (Inf s) (Sup s) ⊆ s := sorry

theorem eq_Icc_cInf_cSup_of_connected_bdd_closed {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hc : is_connected s) (hb : bdd_below s) (ha : bdd_above s) (hcl : is_closed s) : s = set.Icc (Inf s) (Sup s) :=
  set.subset.antisymm (subset_Icc_cInf_cSup hb ha)
    (is_connected.Icc_subset hc (is_closed.cInf_mem hcl (is_connected.nonempty hc) hb)
      (is_closed.cSup_mem hcl (is_connected.nonempty hc) ha))

theorem is_preconnected.Ioi_cInf_subset {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : is_preconnected s) (hb : bdd_below s) (ha : ¬bdd_above s) : set.Ioi (Inf s) ⊆ s := sorry

theorem is_preconnected.Iio_cSup_subset {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : is_preconnected s) (hb : ¬bdd_below s) (ha : bdd_above s) : set.Iio (Sup s) ⊆ s :=
  is_preconnected.Ioi_cInf_subset hs ha hb

/-- A preconnected set in a conditionally complete linear order is either one of the intervals
`[Inf s, Sup s]`, `[Inf s, Sup s)`, `(Inf s, Sup s]`, `(Inf s, Sup s)`, `[Inf s, +∞)`,
`(Inf s, +∞)`, `(-∞, Sup s]`, `(-∞, Sup s)`, `(-∞, +∞)`, or `∅`. The converse statement requires
`α` to be densely ordererd. -/
theorem is_preconnected.mem_intervals {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : is_preconnected s) : s ∈
  insert (set.Icc (Inf s) (Sup s))
    (insert (set.Ico (Inf s) (Sup s))
      (insert (set.Ioc (Inf s) (Sup s))
        (insert (set.Ioo (Inf s) (Sup s))
          (insert (set.Ici (Inf s))
            (insert (set.Ioi (Inf s))
              (insert (set.Iic (Sup s)) (insert (set.Iio (Sup s)) (insert set.univ (singleton ∅))))))))) := sorry

/-- A preconnected set is either one of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`,
`Iic`, `Iio`, or `univ`, or `∅`. The converse statement requires `α` to be densely ordererd. Though
one can represent `∅` as `(Inf s, Inf s)`, we include it into the list of possible cases to improve
readability. -/
theorem set_of_is_preconnected_subset_of_ordered {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] : (set_of fun (s : set α) => is_preconnected s) ⊆
  set.range (function.uncurry set.Icc) ∪ set.range (function.uncurry set.Ico) ∪ set.range (function.uncurry set.Ioc) ∪
      set.range (function.uncurry set.Ioo) ∪
    (set.range set.Ici ∪ set.range set.Ioi ∪ set.range set.Iic ∪ set.range set.Iio ∪ insert set.univ (singleton ∅)) := sorry

/-- A "continuous induction principle" for a closed interval: if a set `s` meets `[a, b]`
on a closed subset, contains `a`, and the set `s ∩ [a, b)` has no maximal point, then `b ∈ s`. -/
theorem is_closed.mem_of_ge_of_forall_exists_gt {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {a : α} {b : α} {s : set α} (hs : is_closed (s ∩ set.Icc a b)) (ha : a ∈ s) (hab : a ≤ b) (hgt : ∀ (x : α), x ∈ s ∩ set.Ico a b → set.nonempty (s ∩ set.Ioc x b)) : b ∈ s := sorry

/-- A "continuous induction principle" for a closed interval: if a set `s` meets `[a, b]`
on a closed subset, contains `a`, and for any `a ≤ x < y ≤ b`, `x ∈ s`, the set `s ∩ (x, y]`
is not empty, then `[a, b] ⊆ s`. -/
theorem is_closed.Icc_subset_of_forall_exists_gt {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {a : α} {b : α} {s : set α} (hs : is_closed (s ∩ set.Icc a b)) (ha : a ∈ s) (hgt : ∀ (x : α), x ∈ s ∩ set.Ico a b → ∀ (y : α), y ∈ set.Ioi x → set.nonempty (s ∩ set.Ioc x y)) : set.Icc a b ⊆ s := sorry

/-- A "continuous induction principle" for a closed interval: if a set `s` meets `[a, b]`
on a closed subset, contains `a`, and for any `x ∈ s ∩ [a, b)` the set `s` includes some open
neighborhood of `x` within `(x, +∞)`, then `[a, b] ⊆ s`. -/
theorem is_closed.Icc_subset_of_forall_mem_nhds_within {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a : α} {b : α} {s : set α} (hs : is_closed (s ∩ set.Icc a b)) (ha : a ∈ s) (hgt : ∀ (x : α), x ∈ s ∩ set.Ico a b → s ∈ nhds_within x (set.Ioi x)) : set.Icc a b ⊆ s := sorry

/-- A closed interval in a densely ordered conditionally complete linear order is preconnected. -/
theorem is_preconnected_Icc {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a : α} {b : α} : is_preconnected (set.Icc a b) := sorry

theorem is_preconnected_interval {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a : α} {b : α} : is_preconnected (set.interval a b) :=
  is_preconnected_Icc

theorem is_preconnected_iff_ord_connected {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {s : set α} : is_preconnected s ↔ set.ord_connected s := sorry

theorem is_preconnected.ord_connected {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {s : set α} : is_preconnected s → set.ord_connected s :=
  iff.mp is_preconnected_iff_ord_connected

theorem is_preconnected_Ici {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a : α} : is_preconnected (set.Ici a) :=
  set.ord_connected.is_preconnected set.ord_connected_Ici

theorem is_preconnected_Iic {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a : α} : is_preconnected (set.Iic a) :=
  set.ord_connected.is_preconnected set.ord_connected_Iic

theorem is_preconnected_Iio {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a : α} : is_preconnected (set.Iio a) :=
  set.ord_connected.is_preconnected set.ord_connected_Iio

theorem is_preconnected_Ioi {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a : α} : is_preconnected (set.Ioi a) :=
  set.ord_connected.is_preconnected set.ord_connected_Ioi

theorem is_preconnected_Ioo {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a : α} {b : α} : is_preconnected (set.Ioo a b) :=
  set.ord_connected.is_preconnected set.ord_connected_Ioo

theorem is_preconnected_Ioc {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a : α} {b : α} : is_preconnected (set.Ioc a b) :=
  set.ord_connected.is_preconnected set.ord_connected_Ioc

theorem is_preconnected_Ico {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {a : α} {b : α} : is_preconnected (set.Ico a b) :=
  set.ord_connected.is_preconnected set.ord_connected_Ico

protected instance ordered_connected_space {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] : preconnected_space α :=
  preconnected_space.mk (set.ord_connected.is_preconnected set.ord_connected_univ)

/-- In a dense conditionally complete linear order, the set of preconnected sets is exactly
the set of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`, `Iic`, `Iio`, `(-∞, +∞)`,
or `∅`. Though one can represent `∅` as `(Inf s, Inf s)`, we include it into the list of
possible cases to improve readability. -/
theorem set_of_is_preconnected_eq_of_ordered {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] : (set_of fun (s : set α) => is_preconnected s) =
  set.range (function.uncurry set.Icc) ∪ set.range (function.uncurry set.Ico) ∪ set.range (function.uncurry set.Ioc) ∪
      set.range (function.uncurry set.Ioo) ∪
    (set.range set.Ici ∪ set.range set.Ioi ∪ set.range set.Iic ∪ set.range set.Iio ∪ insert set.univ (singleton ∅)) := sorry

/--Intermediate Value Theorem for continuous functions on closed intervals, case `f a ≤ t ≤ f b`.-/
theorem intermediate_value_Icc {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {δ : Type u_1} [linear_order δ] [topological_space δ] [order_closed_topology δ] {a : α} {b : α} (hab : a ≤ b) {f : α → δ} (hf : continuous_on f (set.Icc a b)) : set.Icc (f a) (f b) ⊆ f '' set.Icc a b :=
  is_preconnected.intermediate_value is_preconnected_Icc (iff.mpr set.left_mem_Icc hab) (iff.mpr set.right_mem_Icc hab) hf

/--Intermediate Value Theorem for continuous functions on closed intervals, case `f a ≥ t ≥ f b`.-/
theorem intermediate_value_Icc' {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {δ : Type u_1} [linear_order δ] [topological_space δ] [order_closed_topology δ] {a : α} {b : α} (hab : a ≤ b) {f : α → δ} (hf : continuous_on f (set.Icc a b)) : set.Icc (f b) (f a) ⊆ f '' set.Icc a b :=
  is_preconnected.intermediate_value is_preconnected_Icc (iff.mpr set.right_mem_Icc hab) (iff.mpr set.left_mem_Icc hab) hf

/-- A continuous function which tendsto `at_top` `at_top` and to `at_bot` `at_bot` is surjective. -/
theorem continuous.surjective {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {δ : Type u_1} [linear_order δ] [topological_space δ] [order_closed_topology δ] {f : α → δ} (hf : continuous f) (h_top : filter.tendsto f filter.at_top filter.at_top) (h_bot : filter.tendsto f filter.at_bot filter.at_bot) : function.surjective f := sorry

/-- A continuous function which tendsto `at_bot` `at_top` and to `at_top` `at_bot` is surjective. -/
theorem continuous.surjective' {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [densely_ordered α] {δ : Type u_1} [linear_order δ] [topological_space δ] [order_closed_topology δ] {f : α → δ} (hf : continuous f) (h_top : filter.tendsto f filter.at_bot filter.at_top) (h_bot : filter.tendsto f filter.at_top filter.at_bot) : function.surjective f :=
  continuous.surjective hf h_top h_bot

/-- If a function `f : α → β` is continuous on a nonempty interval `s`, its restriction to `s`
tends to `at_bot : filter β` along `at_bot : filter ↥s` and tends to `at_top : filter β` along
`at_top : filter ↥s`, then the restriction of `f` to `s` is surjective. We formulate the
conclusion as `surj_on f s univ`. -/
theorem continuous_on.surj_on_of_tendsto {α : Type u} {β : Type v} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [conditionally_complete_linear_order β] [topological_space β] [order_topology β] [densely_ordered α] {f : α → β} {s : set α} [set.ord_connected s] (hs : set.nonempty s) (hf : continuous_on f s) (hbot : filter.tendsto (fun (x : ↥s) => f ↑x) filter.at_bot filter.at_bot) (htop : filter.tendsto (fun (x : ↥s) => f ↑x) filter.at_top filter.at_top) : set.surj_on f s set.univ :=
  iff.mpr set.surj_on_iff_surjective (continuous.surjective (iff.mp continuous_on_iff_continuous_restrict hf) htop hbot)

/-- If a function `f : α → β` is continuous on a nonempty interval `s`, its restriction to `s`
tends to `at_top : filter β` along `at_bot : filter ↥s` and tends to `at_bot : filter β` along
`at_top : filter ↥s`, then the restriction of `f` to `s` is surjective. We formulate the
conclusion as `surj_on f s univ`. -/
theorem continuous_on.surj_on_of_tendsto' {α : Type u} {β : Type v} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] [conditionally_complete_linear_order β] [topological_space β] [order_topology β] [densely_ordered α] {f : α → β} {s : set α} [set.ord_connected s] (hs : set.nonempty s) (hf : continuous_on f s) (hbot : filter.tendsto (fun (x : ↥s) => f ↑x) filter.at_bot filter.at_top) (htop : filter.tendsto (fun (x : ↥s) => f ↑x) filter.at_top filter.at_bot) : set.surj_on f s set.univ :=
  continuous_on.surj_on_of_tendsto hs hf hbot htop

theorem is_compact.Inf_mem {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : is_compact s) (ne_s : set.nonempty s) : Inf s ∈ s :=
  is_closed.cInf_mem (is_compact.is_closed hs) ne_s (is_compact.bdd_below hs)

theorem is_compact.Sup_mem {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : is_compact s) (ne_s : set.nonempty s) : Sup s ∈ s :=
  is_compact.Inf_mem hs ne_s

theorem is_compact.is_glb_Inf {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : is_compact s) (ne_s : set.nonempty s) : is_glb s (Inf s) :=
  is_glb_cInf ne_s (is_compact.bdd_below hs)

theorem is_compact.is_lub_Sup {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : is_compact s) (ne_s : set.nonempty s) : is_lub s (Sup s) :=
  is_compact.is_glb_Inf hs ne_s

theorem is_compact.is_least_Inf {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : is_compact s) (ne_s : set.nonempty s) : is_least s (Inf s) :=
  { left := is_compact.Inf_mem hs ne_s, right := and.left (is_compact.is_glb_Inf hs ne_s) }

theorem is_compact.is_greatest_Sup {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : is_compact s) (ne_s : set.nonempty s) : is_greatest s (Sup s) :=
  is_compact.is_least_Inf hs ne_s

theorem is_compact.exists_is_least {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : is_compact s) (ne_s : set.nonempty s) : ∃ (x : α), is_least s x :=
  Exists.intro (Inf s) (is_compact.is_least_Inf hs ne_s)

theorem is_compact.exists_is_greatest {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : is_compact s) (ne_s : set.nonempty s) : ∃ (x : α), is_greatest s x :=
  Exists.intro (Sup s) (is_compact.is_greatest_Sup hs ne_s)

theorem is_compact.exists_is_glb {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : is_compact s) (ne_s : set.nonempty s) : ∃ (x : α), ∃ (H : x ∈ s), is_glb s x :=
  Exists.intro (Inf s) (Exists.intro (is_compact.Inf_mem hs ne_s) (is_compact.is_glb_Inf hs ne_s))

theorem is_compact.exists_is_lub {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (hs : is_compact s) (ne_s : set.nonempty s) : ∃ (x : α), ∃ (H : x ∈ s), is_lub s x :=
  Exists.intro (Sup s) (Exists.intro (is_compact.Sup_mem hs ne_s) (is_compact.is_lub_Sup hs ne_s))

theorem is_compact.exists_Inf_image_eq {β : Type v} [conditionally_complete_linear_order β] [topological_space β] [order_topology β] {α : Type u} [topological_space α] {s : set α} (hs : is_compact s) (ne_s : set.nonempty s) {f : α → β} (hf : continuous_on f s) : ∃ (x : α), ∃ (H : x ∈ s), Inf (f '' s) = f x := sorry

theorem is_compact.exists_Sup_image_eq {β : Type v} [conditionally_complete_linear_order β] [topological_space β] [order_topology β] {α : Type u} [topological_space α] {s : set α} : is_compact s → set.nonempty s → ∀ {f : α → β}, continuous_on f s → ∃ (x : α), ∃ (H : x ∈ s), Sup (f '' s) = f x :=
  is_compact.exists_Inf_image_eq

theorem eq_Icc_of_connected_compact {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {s : set α} (h₁ : is_connected s) (h₂ : is_compact s) : s = set.Icc (Inf s) (Sup s) :=
  eq_Icc_cInf_cSup_of_connected_bdd_closed h₁ (is_compact.bdd_below h₂) (is_compact.bdd_above h₂)
    (is_compact.is_closed h₂)

/-- The extreme value theorem: a continuous function realizes its minimum on a compact set -/
theorem is_compact.exists_forall_le {β : Type v} [conditionally_complete_linear_order β] [topological_space β] [order_topology β] {α : Type u} [topological_space α] {s : set α} (hs : is_compact s) (ne_s : set.nonempty s) {f : α → β} (hf : continuous_on f s) : ∃ (x : α), ∃ (H : x ∈ s), ∀ (y : α), y ∈ s → f x ≤ f y := sorry

/-- The extreme value theorem: a continuous function realizes its maximum on a compact set -/
theorem is_compact.exists_forall_ge {β : Type v} [conditionally_complete_linear_order β] [topological_space β] [order_topology β] {α : Type u} [topological_space α] {s : set α} : is_compact s →
  set.nonempty s → ∀ {f : α → β}, continuous_on f s → ∃ (x : α), ∃ (H : x ∈ s), ∀ (y : α), y ∈ s → f y ≤ f x :=
  is_compact.exists_forall_le

/-- The extreme value theorem: if a continuous function `f` tends to infinity away from compact
sets, then it has a global minimum. -/
theorem continuous.exists_forall_le {β : Type v} [conditionally_complete_linear_order β] [topological_space β] [order_topology β] {α : Type u_1} [topological_space α] [Nonempty α] {f : α → β} (hf : continuous f) (hlim : filter.tendsto f (filter.cocompact α) filter.at_top) : ∃ (x : α), ∀ (y : α), f x ≤ f y := sorry

/-- The extreme value theorem: if a continuous function `f` tends to negative infinity away from
compactx sets, then it has a global maximum. -/
theorem continuous.exists_forall_ge {β : Type v} [conditionally_complete_linear_order β] [topological_space β] [order_topology β] {α : Type u_1} [topological_space α] [Nonempty α] {f : α → β} (hf : continuous f) (hlim : filter.tendsto f (filter.cocompact α) filter.at_bot) : ∃ (x : α), ∀ (y : α), f y ≤ f x :=
  continuous.exists_forall_le hf hlim

theorem is_bounded_le_nhds {α : Type u} [semilattice_sup α] [topological_space α] [order_topology α] (a : α) : filter.is_bounded LessEq (nhds a) := sorry

theorem filter.tendsto.is_bounded_under_le {α : Type u} {β : Type v} [semilattice_sup α] [topological_space α] [order_topology α] {f : filter β} {u : β → α} {a : α} (h : filter.tendsto u f (nhds a)) : filter.is_bounded_under LessEq f u :=
  filter.is_bounded.mono h (is_bounded_le_nhds a)

theorem is_cobounded_ge_nhds {α : Type u} [semilattice_sup α] [topological_space α] [order_topology α] (a : α) : filter.is_cobounded ge (nhds a) :=
  filter.is_bounded.is_cobounded_flip (is_bounded_le_nhds a)

theorem filter.tendsto.is_cobounded_under_ge {α : Type u} {β : Type v} [semilattice_sup α] [topological_space α] [order_topology α] {f : filter β} {u : β → α} {a : α} [filter.ne_bot f] (h : filter.tendsto u f (nhds a)) : filter.is_cobounded_under ge f u :=
  filter.is_bounded.is_cobounded_flip (filter.tendsto.is_bounded_under_le h)

theorem is_bounded_ge_nhds {α : Type u} [semilattice_inf α] [topological_space α] [order_topology α] (a : α) : filter.is_bounded ge (nhds a) :=
  is_bounded_le_nhds a

theorem filter.tendsto.is_bounded_under_ge {α : Type u} {β : Type v} [semilattice_inf α] [topological_space α] [order_topology α] {f : filter β} {u : β → α} {a : α} (h : filter.tendsto u f (nhds a)) : filter.is_bounded_under ge f u :=
  filter.is_bounded.mono h (is_bounded_ge_nhds a)

theorem is_cobounded_le_nhds {α : Type u} [semilattice_inf α] [topological_space α] [order_topology α] (a : α) : filter.is_cobounded LessEq (nhds a) :=
  filter.is_bounded.is_cobounded_flip (is_bounded_ge_nhds a)

theorem filter.tendsto.is_cobounded_under_le {α : Type u} {β : Type v} [semilattice_inf α] [topological_space α] [order_topology α] {f : filter β} {u : β → α} {a : α} [filter.ne_bot f] (h : filter.tendsto u f (nhds a)) : filter.is_cobounded_under LessEq f u :=
  filter.is_bounded.is_cobounded_flip (filter.tendsto.is_bounded_under_ge h)

theorem lt_mem_sets_of_Limsup_lt {α : Type u} [conditionally_complete_linear_order α] {f : filter α} {b : α} (h : filter.is_bounded LessEq f) (l : filter.Limsup f < b) : filter.eventually (fun (a : α) => a < b) f := sorry

theorem gt_mem_sets_of_Liminf_gt {α : Type u} [conditionally_complete_linear_order α] {f : filter α} {b : α} : filter.is_bounded ge f → b < filter.Liminf f → filter.eventually (fun (a : α) => b < a) f :=
  lt_mem_sets_of_Limsup_lt

/-- If the liminf and the limsup of a filter coincide, then this filter converges to
their common value, at least if the filter is eventually bounded above and below. -/
theorem le_nhds_of_Limsup_eq_Liminf {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {f : filter α} {a : α} (hl : filter.is_bounded LessEq f) (hg : filter.is_bounded ge f) (hs : filter.Limsup f = a) (hi : filter.Liminf f = a) : f ≤ nhds a :=
  iff.mpr tendsto_order
    { left := fun (b : α) (hb : b < a) => gt_mem_sets_of_Liminf_gt hg (Eq.symm hi ▸ hb),
      right := fun (b : α) (hb : b > a) => lt_mem_sets_of_Limsup_lt hl (Eq.symm hs ▸ hb) }

theorem Limsup_nhds {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] (a : α) : filter.Limsup (nhds a) = a := sorry

theorem Liminf_nhds {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] (a : α) : filter.Liminf (nhds a) = a :=
  Limsup_nhds

/-- If a filter is converging, its limsup coincides with its limit. -/
theorem Liminf_eq_of_le_nhds {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {f : filter α} {a : α} [filter.ne_bot f] (h : f ≤ nhds a) : filter.Liminf f = a := sorry

/-- If a filter is converging, its liminf coincides with its limit. -/
theorem Limsup_eq_of_le_nhds {α : Type u} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {f : filter α} {a : α} [filter.ne_bot f] : f ≤ nhds a → filter.Limsup f = a :=
  Liminf_eq_of_le_nhds

/-- If a function has a limit, then its limsup coincides with its limit. -/
theorem filter.tendsto.limsup_eq {α : Type u} {β : Type v} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {f : filter β} {u : β → α} {a : α} [filter.ne_bot f] (h : filter.tendsto u f (nhds a)) : filter.limsup f u = a :=
  Limsup_eq_of_le_nhds h

/-- If a function has a limit, then its liminf coincides with its limit. -/
theorem filter.tendsto.liminf_eq {α : Type u} {β : Type v} [conditionally_complete_linear_order α] [topological_space α] [order_topology α] {f : filter β} {u : β → α} {a : α} [filter.ne_bot f] (h : filter.tendsto u f (nhds a)) : filter.liminf f u = a :=
  Liminf_eq_of_le_nhds h

-- In complete_linear_order, the above theorems take a simpler form

/-- If the liminf and the limsup of a function coincide, then the limit of the function
exists and has the same value -/
theorem tendsto_of_liminf_eq_limsup {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] {f : filter β} {u : β → α} {a : α} (hinf : filter.liminf f u = a) (hsup : filter.limsup f u = a) : filter.tendsto u f (nhds a) :=
  le_nhds_of_Limsup_eq_Liminf filter.is_bounded_le_of_top filter.is_bounded_ge_of_bot hsup hinf

/-- If a number `a` is less than or equal to the `liminf` of a function `f` at some filter
and is greater than or equal to the `limsup` of `f`, then `f` tends to `a` along this filter. -/
theorem tendsto_of_le_liminf_of_limsup_le {α : Type u} {β : Type v} [complete_linear_order α] [topological_space α] [order_topology α] {f : filter β} {u : β → α} {a : α} (hinf : a ≤ filter.liminf f u) (hsup : filter.limsup f u ≤ a) : filter.tendsto u f (nhds a) := sorry

/-!
Here is a counter-example to a version of the following with `conditionally_complete_lattice α`.
Take `α = [0, 1) → ℝ` with the natural lattice structure, `ι = ℕ`. Put `f n x = -x^n`. Then
`⨆ n, f n = 0` while none of `f n` is strictly greater than the constant function `-0.5`.
-/

theorem tendsto_at_top_csupr {ι : Type u_1} {α : Type u_2} [preorder ι] [topological_space α] [conditionally_complete_linear_order α] [order_topology α] {f : ι → α} (h_mono : monotone f) (hbdd : bdd_above (set.range f)) : filter.tendsto f filter.at_top (nhds (supr fun (i : ι) => f i)) := sorry

theorem tendsto_at_top_cinfi {ι : Type u_1} {α : Type u_2} [preorder ι] [topological_space α] [conditionally_complete_linear_order α] [order_topology α] {f : ι → α} (h_mono : ∀ {i j : ι}, i ≤ j → f j ≤ f i) (hbdd : bdd_below (set.range f)) : filter.tendsto f filter.at_top (nhds (infi fun (i : ι) => f i)) :=
  tendsto_at_top_csupr h_mono hbdd

theorem tendsto_at_top_supr {ι : Type u_1} {α : Type u_2} [preorder ι] [topological_space α] [complete_linear_order α] [order_topology α] {f : ι → α} (h_mono : monotone f) : filter.tendsto f filter.at_top (nhds (supr fun (i : ι) => f i)) :=
  tendsto_at_top_csupr h_mono (order_top.bdd_above (set.range f))

theorem tendsto_at_top_infi {ι : Type u_1} {α : Type u_2} [preorder ι] [topological_space α] [complete_linear_order α] [order_topology α] {f : ι → α} (h_mono : ∀ {i j : ι}, i ≤ j → f j ≤ f i) : filter.tendsto f filter.at_top (nhds (infi fun (i : ι) => f i)) :=
  tendsto_at_top_cinfi h_mono (order_bot.bdd_below (set.range f))

theorem tendsto_of_monotone {ι : Type u_1} {α : Type u_2} [preorder ι] [topological_space α] [conditionally_complete_linear_order α] [order_topology α] {f : ι → α} (h_mono : monotone f) : filter.tendsto f filter.at_top filter.at_top ∨ ∃ (l : α), filter.tendsto f filter.at_top (nhds l) :=
  dite (bdd_above (set.range f))
    (fun (H : bdd_above (set.range f)) => Or.inr (Exists.intro (supr fun (i : ι) => f i) (tendsto_at_top_csupr h_mono H)))
    fun (H : ¬bdd_above (set.range f)) => Or.inl (filter.tendsto_at_top_at_top_of_monotone' h_mono H)

theorem supr_eq_of_tendsto {α : Type u_1} {β : Type u_2} [topological_space α] [complete_linear_order α] [order_topology α] [Nonempty β] [semilattice_sup β] {f : β → α} {a : α} (hf : monotone f) : filter.tendsto f filter.at_top (nhds a) → supr f = a :=
  tendsto_nhds_unique (tendsto_at_top_supr hf)

theorem infi_eq_of_tendsto {β : Type v} {α : Type u_1} [topological_space α] [complete_linear_order α] [order_topology α] [Nonempty β] [semilattice_sup β] {f : β → α} {a : α} (hf : ∀ (n m : β), n ≤ m → f m ≤ f n) : filter.tendsto f filter.at_top (nhds a) → infi f = a :=
  tendsto_nhds_unique (tendsto_at_top_infi hf)

theorem tendsto_neg_nhds_within_Ioi {α : Type u} [ordered_add_comm_group α] [topological_space α] [topological_add_group α] {a : α} : filter.tendsto Neg.neg (nhds_within a (set.Ioi a)) (nhds_within (-a) (set.Iio (-a))) := sorry

theorem tendsto_inv_nhds_within_Iio {α : Type u} [ordered_comm_group α] [topological_space α] [topological_group α] {a : α} : filter.tendsto has_inv.inv (nhds_within a (set.Iio a)) (nhds_within (a⁻¹) (set.Ioi (a⁻¹))) := sorry

theorem tendsto_neg_nhds_within_Ioi_neg {α : Type u} [ordered_add_comm_group α] [topological_space α] [topological_add_group α] {a : α} : filter.tendsto Neg.neg (nhds_within (-a) (set.Ioi (-a))) (nhds_within a (set.Iio a)) := sorry

theorem tendsto_neg_nhds_within_Iio_neg {α : Type u} [ordered_add_comm_group α] [topological_space α] [topological_add_group α] {a : α} : filter.tendsto Neg.neg (nhds_within (-a) (set.Iio (-a))) (nhds_within a (set.Ioi a)) := sorry

theorem tendsto_neg_nhds_within_Ici {α : Type u} [ordered_add_comm_group α] [topological_space α] [topological_add_group α] {a : α} : filter.tendsto Neg.neg (nhds_within a (set.Ici a)) (nhds_within (-a) (set.Iic (-a))) := sorry

theorem tendsto_inv_nhds_within_Iic {α : Type u} [ordered_comm_group α] [topological_space α] [topological_group α] {a : α} : filter.tendsto has_inv.inv (nhds_within a (set.Iic a)) (nhds_within (a⁻¹) (set.Ici (a⁻¹))) := sorry

theorem tendsto_inv_nhds_within_Ici_inv {α : Type u} [ordered_comm_group α] [topological_space α] [topological_group α] {a : α} : filter.tendsto has_inv.inv (nhds_within (a⁻¹) (set.Ici (a⁻¹))) (nhds_within a (set.Iic a)) := sorry

theorem tendsto_inv_nhds_within_Iic_inv {α : Type u} [ordered_comm_group α] [topological_space α] [topological_group α] {a : α} : filter.tendsto has_inv.inv (nhds_within (a⁻¹) (set.Iic (a⁻¹))) (nhds_within a (set.Ici a)) := sorry

theorem nhds_left_sup_nhds_right {α : Type u} (a : α) [topological_space α] [linear_order α] : nhds_within a (set.Iic a) ⊔ nhds_within a (set.Ici a) = nhds a := sorry

theorem nhds_left'_sup_nhds_right {α : Type u} (a : α) [topological_space α] [linear_order α] : nhds_within a (set.Iio a) ⊔ nhds_within a (set.Ici a) = nhds a := sorry

theorem nhds_left_sup_nhds_right' {α : Type u} (a : α) [topological_space α] [linear_order α] : nhds_within a (set.Iic a) ⊔ nhds_within a (set.Ioi a) = nhds a := sorry

theorem continuous_at_iff_continuous_left_right {α : Type u} {β : Type v} [topological_space α] [linear_order α] [topological_space β] {a : α} {f : α → β} : continuous_at f a ↔ continuous_within_at f (set.Iic a) a ∧ continuous_within_at f (set.Ici a) a := sorry

theorem continuous_on_Icc_extend_from_Ioo {α : Type u} {β : Type v} [topological_space α] [linear_order α] [densely_ordered α] [order_topology α] [topological_space β] [regular_space β] {f : α → β} {a : α} {b : α} {la : β} {lb : β} (hab : a < b) (hf : continuous_on f (set.Ioo a b)) (ha : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds la)) (hb : filter.tendsto f (nhds_within b (set.Iio b)) (nhds lb)) : continuous_on (extend_from (set.Ioo a b) f) (set.Icc a b) := sorry

theorem eq_lim_at_left_extend_from_Ioo {α : Type u} {β : Type v} [topological_space α] [linear_order α] [densely_ordered α] [order_topology α] [topological_space β] [t2_space β] {f : α → β} {a : α} {b : α} {la : β} (hab : a < b) (ha : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds la)) : extend_from (set.Ioo a b) f a = la := sorry

theorem eq_lim_at_right_extend_from_Ioo {α : Type u} {β : Type v} [topological_space α] [linear_order α] [densely_ordered α] [order_topology α] [topological_space β] [t2_space β] {f : α → β} {a : α} {b : α} {lb : β} (hab : a < b) (hb : filter.tendsto f (nhds_within b (set.Iio b)) (nhds lb)) : extend_from (set.Ioo a b) f b = lb := sorry

theorem continuous_on_Ico_extend_from_Ioo {α : Type u} {β : Type v} [topological_space α] [linear_order α] [densely_ordered α] [order_topology α] [topological_space β] [regular_space β] {f : α → β} {a : α} {b : α} {la : β} (hab : a < b) (hf : continuous_on f (set.Ioo a b)) (ha : filter.tendsto f (nhds_within a (set.Ioi a)) (nhds la)) : continuous_on (extend_from (set.Ioo a b) f) (set.Ico a b) := sorry

theorem continuous_on_Ioc_extend_from_Ioo {α : Type u} {β : Type v} [topological_space α] [linear_order α] [densely_ordered α] [order_topology α] [topological_space β] [regular_space β] {f : α → β} {a : α} {b : α} {lb : β} (hab : a < b) (hf : continuous_on f (set.Ioo a b)) (hb : filter.tendsto f (nhds_within b (set.Iio b)) (nhds lb)) : continuous_on (extend_from (set.Ioo a b) f) (set.Ioc a b) := sorry

theorem continuous_within_at_Ioi_iff_Ici {α : Type u_1} {β : Type u_2} [topological_space α] [partial_order α] [topological_space β] {a : α} {f : α → β} : continuous_within_at f (set.Ioi a) a ↔ continuous_within_at f (set.Ici a) a := sorry

theorem continuous_within_at_Iio_iff_Iic {α : Type u_1} {β : Type u_2} [topological_space α] [linear_order α] [topological_space β] {a : α} {f : α → β} : continuous_within_at f (set.Iio a) a ↔ continuous_within_at f (set.Iic a) a := sorry

theorem continuous_at_iff_continuous_left'_right' {α : Type u} {β : Type v} [topological_space α] [linear_order α] [topological_space β] {a : α} {f : α → β} : continuous_at f a ↔ continuous_within_at f (set.Iio a) a ∧ continuous_within_at f (set.Ioi a) a := sorry

/-!
### Continuity of monotone functions

In this section we prove the following fact: if `f` is a monotone function on a neighborhood of `a`
and the image of this neighborhood is a neighborhood of `f a`, then `f` is continuous at `a`, see
`continuous_at_of_mono_incr_on_of_image_mem_nhds`, as well as several similar facts.
-/

/-- If `f` is a function strictly monotonically increasing on a right neighborhood of `a` and the
image of this neighborhood under `f` meets every interval `(f a, b]`, `b > f a`, then `f` is
continuous at `a` from the right.

The assumption `hfs : ∀ b > f a, ∃ c ∈ s, f c ∈ Ioc (f a) b` is required because otherwise the
function `f : ℝ → ℝ` given by `f x = if x ≤ 0 then x else x + 1` would be a counter-example at
`a = 0`. -/
theorem strict_mono_incr_on.continuous_at_right_of_exists_between {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_incr_on f s) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : ∀ (b : β) (H : b > f a), ∃ (c : α), ∃ (H : c ∈ s), f c ∈ set.Ioc (f a) b) : continuous_within_at f (set.Ici a) a := sorry

/-- If `f` is a function monotonically increasing function on a right neighborhood of `a` and the
image of this neighborhood under `f` meets every interval `(f a, b)`, `b > f a`, then `f` is
continuous at `a` from the right.

The assumption `hfs : ∀ b > f a, ∃ c ∈ s, f c ∈ Ioo (f a) b` cannot be replaced by the weaker
assumption `hfs : ∀ b > f a, ∃ c ∈ s, f c ∈ Ioc (f a) b` we use for strictly monotone functions
because otherwise the function `ceil : ℝ → ℤ` would be a counter-example at `a = 0`. -/
theorem continuous_at_right_of_mono_incr_on_of_exists_between {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} {a : α} (h_mono : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → f x ≤ f y) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : ∀ (b : β) (H : b > f a), ∃ (c : α), ∃ (H : c ∈ s), f c ∈ set.Ioo (f a) b) : continuous_within_at f (set.Ici a) a := sorry

/-- If a function `f` with a densely ordered codomain is monotonically increasing on a right
neighborhood of `a` and the closure of the image of this neighborhood under `f` is a right
neighborhood of `f a`, then `f` is continuous at `a` from the right. -/
theorem continuous_at_right_of_mono_incr_on_of_closure_image_mem_nhds_within {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → f x ≤ f y) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : closure (f '' s) ∈ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a := sorry

/-- If a function `f` with a densely ordered codomain is monotonically increasing on a right
neighborhood of `a` and the image of this neighborhood under `f` is a right neighborhood of `f a`,
then `f` is continuous at `a` from the right. -/
theorem continuous_at_right_of_mono_incr_on_of_image_mem_nhds_within {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → f x ≤ f y) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : f '' s ∈ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a :=
  continuous_at_right_of_mono_incr_on_of_closure_image_mem_nhds_within h_mono hs
    (filter.mem_sets_of_superset hfs subset_closure)

/-- If a function `f` with a densely ordered codomain is strictly monotonically increasing on a
right neighborhood of `a` and the closure of the image of this neighborhood under `f` is a right
neighborhood of `f a`, then `f` is continuous at `a` from the right. -/
theorem strict_mono_incr_on.continuous_at_right_of_closure_image_mem_nhds_within {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_incr_on f s) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : closure (f '' s) ∈ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a :=
  continuous_at_right_of_mono_incr_on_of_closure_image_mem_nhds_within
    (fun (x : α) (hx : x ∈ s) (y : α) (hy : y ∈ s) => iff.mpr (strict_mono_incr_on.le_iff_le h_mono hx hy)) hs hfs

/-- If a function `f` with a densely ordered codomain is strictly monotonically increasing on a
right neighborhood of `a` and the image of this neighborhood under `f` is a right neighborhood of
`f a`, then `f` is continuous at `a` from the right. -/
theorem strict_mono_incr_on.continuous_at_right_of_image_mem_nhds_within {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_incr_on f s) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : f '' s ∈ nhds_within (f a) (set.Ici (f a))) : continuous_within_at f (set.Ici a) a :=
  strict_mono_incr_on.continuous_at_right_of_closure_image_mem_nhds_within h_mono hs
    (filter.mem_sets_of_superset hfs subset_closure)

/-- If a function `f` is strictly monotonically increasing on a right neighborhood of `a` and the
image of this neighborhood under `f` includes `Ioi (f a)`, then `f` is continuous at `a` from the
right. -/
theorem strict_mono_incr_on.continuous_at_right_of_surj_on {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_incr_on f s) (hs : s ∈ nhds_within a (set.Ici a)) (hfs : set.surj_on f s (set.Ioi (f a))) : continuous_within_at f (set.Ici a) a := sorry

/-- If `f` is a function strictly monotonically increasing on a left neighborhood of `a` and the
image of this neighborhood under `f` meets every interval `[b, f a)`, `b < f a`, then `f` is
continuous at `a` from the left.

The assumption `hfs : ∀ b < f a, ∃ c ∈ s, f c ∈ Ico b (f a)` is required because otherwise the
function `f : ℝ → ℝ` given by `f x = if x < 0 then x else x + 1` would be a counter-example at
`a = 0`. -/
theorem strict_mono_incr_on.continuous_at_left_of_exists_between {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_incr_on f s) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : ∀ (b : β) (H : b < f a), ∃ (c : α), ∃ (H : c ∈ s), f c ∈ set.Ico b (f a)) : continuous_within_at f (set.Iic a) a := sorry

/-- If `f` is a function monotonically increasing function on a left neighborhood of `a` and the
image of this neighborhood under `f` meets every interval `(b, f a)`, `b < f a`, then `f` is
continuous at `a` from the left.

The assumption `hfs : ∀ b < f a, ∃ c ∈ s, f c ∈ Ioo b (f a)` cannot be replaced by the weaker
assumption `hfs : ∀ b < f a, ∃ c ∈ s, f c ∈ Ico b (f a)` we use for strictly monotone functions
because otherwise the function `floor : ℝ → ℤ` would be a counter-example at `a = 0`. -/
theorem continuous_at_left_of_mono_incr_on_of_exists_between {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} {a : α} (h_mono : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → f x ≤ f y) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : ∀ (b : β) (H : b < f a), ∃ (c : α), ∃ (H : c ∈ s), f c ∈ set.Ioo b (f a)) : continuous_within_at f (set.Iic a) a := sorry

/-- If a function `f` with a densely ordered codomain is monotonically increasing on a left
neighborhood of `a` and the closure of the image of this neighborhood under `f` is a left
neighborhood of `f a`, then `f` is continuous at `a` from the left -/
theorem continuous_at_left_of_mono_incr_on_of_closure_image_mem_nhds_within {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → f x ≤ f y) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : closure (f '' s) ∈ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a :=
  continuous_at_right_of_mono_incr_on_of_closure_image_mem_nhds_within
    (fun (x : order_dual α) (hx : x ∈ s) (y : order_dual α) (hy : y ∈ s) => h_mono y hy x hx) hs hfs

/-- If a function `f` with a densely ordered codomain is monotonically increasing on a left
neighborhood of `a` and the image of this neighborhood under `f` is a left neighborhood of `f a`,
then `f` is continuous at `a` from the left. -/
theorem continuous_at_left_of_mono_incr_on_of_image_mem_nhds_within {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → f x ≤ f y) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : f '' s ∈ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a :=
  continuous_at_left_of_mono_incr_on_of_closure_image_mem_nhds_within h_mono hs
    (filter.mem_sets_of_superset hfs subset_closure)

/-- If a function `f` with a densely ordered codomain is strictly monotonically increasing on a
left neighborhood of `a` and the closure of the image of this neighborhood under `f` is a left
neighborhood of `f a`, then `f` is continuous at `a` from the left. -/
theorem strict_mono_incr_on.continuous_at_left_of_closure_image_mem_nhds_within {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_incr_on f s) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : closure (f '' s) ∈ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a :=
  strict_mono_incr_on.continuous_at_right_of_closure_image_mem_nhds_within (strict_mono_incr_on.dual h_mono) hs hfs

/-- If a function `f` with a densely ordered codomain is strictly monotonically increasing on a
left neighborhood of `a` and the image of this neighborhood under `f` is a left neighborhood of
`f a`, then `f` is continuous at `a` from the left. -/
theorem strict_mono_incr_on.continuous_at_left_of_image_mem_nhds_within {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_incr_on f s) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : f '' s ∈ nhds_within (f a) (set.Iic (f a))) : continuous_within_at f (set.Iic a) a :=
  strict_mono_incr_on.continuous_at_right_of_image_mem_nhds_within (strict_mono_incr_on.dual h_mono) hs hfs

/-- If a function `f` is strictly monotonically increasing on a left neighborhood of `a` and the
image of this neighborhood under `f` includes `Iio (f a)`, then `f` is continuous at `a` from the
left. -/
theorem strict_mono_incr_on.continuous_at_left_of_surj_on {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_incr_on f s) (hs : s ∈ nhds_within a (set.Iic a)) (hfs : set.surj_on f s (set.Iio (f a))) : continuous_within_at f (set.Iic a) a :=
  strict_mono_incr_on.continuous_at_right_of_surj_on (strict_mono_incr_on.dual h_mono) hs hfs

/-- If a function `f` is strictly monotonically increasing on a neighborhood of `a` and the image of
this neighborhood under `f` meets every interval `[b, f a)`, `b < f a`, and every interval
`(f a, b]`, `b > f a`, then `f` is continuous at `a`. -/
theorem strict_mono_incr_on.continuous_at_of_exists_between {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_incr_on f s) (hs : s ∈ nhds a) (hfs_l : ∀ (b : β) (H : b < f a), ∃ (c : α), ∃ (H : c ∈ s), f c ∈ set.Ico b (f a)) (hfs_r : ∀ (b : β) (H : b > f a), ∃ (c : α), ∃ (H : c ∈ s), f c ∈ set.Ioc (f a) b) : continuous_at f a :=
  iff.mpr continuous_at_iff_continuous_left_right
    { left := strict_mono_incr_on.continuous_at_left_of_exists_between h_mono (mem_nhds_within_of_mem_nhds hs) hfs_l,
      right := strict_mono_incr_on.continuous_at_right_of_exists_between h_mono (mem_nhds_within_of_mem_nhds hs) hfs_r }

/-- If a function `f` with a densely ordered codomain is strictly monotonically increasing on a
neighborhood of `a` and the closure of the image of this neighborhood under `f` is a neighborhood of
`f a`, then `f` is continuous at `a`. -/
theorem strict_mono_incr_on.continuous_at_of_closure_image_mem_nhds {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_incr_on f s) (hs : s ∈ nhds a) (hfs : closure (f '' s) ∈ nhds (f a)) : continuous_at f a := sorry

/-- If a function `f` with a densely ordered codomain is strictly monotonically increasing on a
neighborhood of `a` and the image of this set under `f` is a neighborhood of `f a`, then `f` is
continuous at `a`. -/
theorem strict_mono_incr_on.continuous_at_of_image_mem_nhds {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : strict_mono_incr_on f s) (hs : s ∈ nhds a) (hfs : f '' s ∈ nhds (f a)) : continuous_at f a :=
  strict_mono_incr_on.continuous_at_of_closure_image_mem_nhds h_mono hs (filter.mem_sets_of_superset hfs subset_closure)

/-- If `f` is a function monotonically increasing function on a neighborhood of `a` and the image of
this neighborhood under `f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a,
b)`, `b > f a`, then `f` is continuous at `a`. -/
theorem continuous_at_of_mono_incr_on_of_exists_between {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] {f : α → β} {s : set α} {a : α} (h_mono : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → f x ≤ f y) (hs : s ∈ nhds a) (hfs_l : ∀ (b : β) (H : b < f a), ∃ (c : α), ∃ (H : c ∈ s), f c ∈ set.Ioo b (f a)) (hfs_r : ∀ (b : β) (H : b > f a), ∃ (c : α), ∃ (H : c ∈ s), f c ∈ set.Ioo (f a) b) : continuous_at f a :=
  iff.mpr continuous_at_iff_continuous_left_right
    { left := continuous_at_left_of_mono_incr_on_of_exists_between h_mono (mem_nhds_within_of_mem_nhds hs) hfs_l,
      right := continuous_at_right_of_mono_incr_on_of_exists_between h_mono (mem_nhds_within_of_mem_nhds hs) hfs_r }

/-- If a function `f` with a densely ordered codomain is monotonically increasing on a neighborhood
of `a` and the closure of the image of this neighborhood under `f` is a neighborhood of `f a`, then
`f` is continuous at `a`. -/
theorem continuous_at_of_mono_incr_on_of_closure_image_mem_nhds {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → f x ≤ f y) (hs : s ∈ nhds a) (hfs : closure (f '' s) ∈ nhds (f a)) : continuous_at f a := sorry

/-- If a function `f` with a densely ordered codomain is monotonically increasing on a neighborhood
of `a` and the image of this neighborhood under `f` is a neighborhood of `f a`, then `f` is
continuous at `a`. -/
theorem continuous_at_of_mono_incr_on_of_image_mem_nhds {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} {s : set α} {a : α} (h_mono : ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → f x ≤ f y) (hs : s ∈ nhds a) (hfs : f '' s ∈ nhds (f a)) : continuous_at f a :=
  continuous_at_of_mono_incr_on_of_closure_image_mem_nhds h_mono hs (filter.mem_sets_of_superset hfs subset_closure)

/-- A monotone function with densely ordered codomain and a dense range is continuous. -/
theorem monotone.continuous_of_dense_range {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} (h_mono : monotone f) (h_dense : dense_range f) : continuous f := sorry

/-- A monotone surjective function with a densely ordered codomain is surjective. -/
theorem monotone.continuous_of_surjective {α : Type u} {β : Type v} [linear_order α] [topological_space α] [order_topology α] [linear_order β] [topological_space β] [order_topology β] [densely_ordered β] {f : α → β} (h_mono : monotone f) (h_surj : function.surjective f) : continuous f :=
  monotone.continuous_of_dense_range h_mono (function.surjective.dense_range h_surj)

/-!
### Continuity of order isomorphisms

In this section we prove that an `order_iso` is continuous, hence it is a `homeomorph`. We prove
this for an `order_iso` between to partial orders with order topology.
-/

namespace order_iso


protected theorem continuous {α : Type u} {β : Type v} [partial_order α] [partial_order β] [topological_space α] [topological_space β] [order_topology α] [order_topology β] (e : α ≃o β) : continuous ⇑e := sorry

/-- An order isomorphism between two linear order `order_topology` spaces is a homeomorphism. -/
def to_homeomorph {α : Type u} {β : Type v} [partial_order α] [partial_order β] [topological_space α] [topological_space β] [order_topology α] [order_topology β] (e : α ≃o β) : α ≃ₜ β :=
  homeomorph.mk (rel_iso.to_equiv e)

@[simp] theorem coe_to_homeomorph {α : Type u} {β : Type v} [partial_order α] [partial_order β] [topological_space α] [topological_space β] [order_topology α] [order_topology β] (e : α ≃o β) : ⇑(to_homeomorph e) = ⇑e :=
  rfl

@[simp] theorem coe_to_homeomorph_symm {α : Type u} {β : Type v} [partial_order α] [partial_order β] [topological_space α] [topological_space β] [order_topology α] [order_topology β] (e : α ≃o β) : ⇑(homeomorph.symm (to_homeomorph e)) = ⇑(symm e) :=
  rfl

