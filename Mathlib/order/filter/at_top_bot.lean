/-
Copyright (c) 2017 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Jeremy Avigad, Yury Kudryashov, Patrick Massot
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.order.filter.bases
import Mathlib.data.finset.preimage
import Mathlib.PostPort

universes u_3 u_1 u_4 u_5 u_2 u_6 

namespace Mathlib

/-!
# `at_top` and `at_bot` filters on preorded sets, monoids and groups.

In this file we define the filters

* `at_top`: corresponds to `n → +∞`;
* `at_bot`: corresponds to `n → -∞`.

Then we prove many lemmas like “if `f → +∞`, then `f ± c → +∞`”.
-/

namespace filter


/-- `at_top` is the filter representing the limit `→ ∞` on an ordered set.
  It is generated by the collection of up-sets `{b | a ≤ b}`.
  (The preorder need not have a top element for this to be well defined,
  and indeed is trivial when a top element exists.) -/
def at_top {α : Type u_3} [preorder α] : filter α :=
  infi fun (a : α) => principal (set.Ici a)

/-- `at_bot` is the filter representing the limit `→ -∞` on an ordered set.
  It is generated by the collection of down-sets `{b | b ≤ a}`.
  (The preorder need not have a bottom element for this to be well defined,
  and indeed is trivial when a bottom element exists.) -/
def at_bot {α : Type u_3} [preorder α] : filter α :=
  infi fun (a : α) => principal (set.Iic a)

theorem mem_at_top {α : Type u_3} [preorder α] (a : α) : (set_of fun (b : α) => a ≤ b) ∈ at_top :=
  mem_infi_sets a (set.subset.refl (set.Ici a))

theorem Ioi_mem_at_top {α : Type u_3} [preorder α] [no_top_order α] (x : α) : set.Ioi x ∈ at_top := sorry

theorem mem_at_bot {α : Type u_3} [preorder α] (a : α) : (set_of fun (b : α) => b ≤ a) ∈ at_bot :=
  mem_infi_sets a (set.subset.refl (set.Iic a))

theorem Iio_mem_at_bot {α : Type u_3} [preorder α] [no_bot_order α] (x : α) : set.Iio x ∈ at_bot := sorry

theorem at_top_basis {α : Type u_3} [Nonempty α] [semilattice_sup α] : has_basis at_top (fun (_x : α) => True) set.Ici :=
  has_basis_infi_principal (directed_of_sup fun (a b : α) => iff.mpr set.Ici_subset_Ici)

theorem at_top_basis' {α : Type u_3} [semilattice_sup α] (a : α) : has_basis at_top (fun (x : α) => a ≤ x) set.Ici := sorry

theorem at_bot_basis {α : Type u_3} [Nonempty α] [semilattice_inf α] : has_basis at_bot (fun (_x : α) => True) set.Iic :=
  at_top_basis

theorem at_bot_basis' {α : Type u_3} [semilattice_inf α] (a : α) : has_basis at_bot (fun (x : α) => x ≤ a) set.Iic :=
  at_top_basis' a

instance at_top_ne_bot {α : Type u_3} [Nonempty α] [semilattice_sup α] : ne_bot at_top :=
  iff.mpr (has_basis.ne_bot_iff at_top_basis) fun (a : α) (_x : True) => set.nonempty_Ici

instance at_bot_ne_bot {α : Type u_3} [Nonempty α] [semilattice_inf α] : ne_bot at_bot :=
  at_top_ne_bot

@[simp] theorem mem_at_top_sets {α : Type u_3} [Nonempty α] [semilattice_sup α] {s : set α} : s ∈ at_top ↔ ∃ (a : α), ∀ (b : α), b ≥ a → b ∈ s :=
  iff.trans (has_basis.mem_iff at_top_basis) (exists_congr fun (_x : α) => exists_const True)

@[simp] theorem mem_at_bot_sets {α : Type u_3} [Nonempty α] [semilattice_inf α] {s : set α} : s ∈ at_bot ↔ ∃ (a : α), ∀ (b : α), b ≤ a → b ∈ s :=
  mem_at_top_sets

@[simp] theorem eventually_at_top {α : Type u_3} [semilattice_sup α] [Nonempty α] {p : α → Prop} : filter.eventually (fun (x : α) => p x) at_top ↔ ∃ (a : α), ∀ (b : α), b ≥ a → p b :=
  mem_at_top_sets

@[simp] theorem eventually_at_bot {α : Type u_3} [semilattice_inf α] [Nonempty α] {p : α → Prop} : filter.eventually (fun (x : α) => p x) at_bot ↔ ∃ (a : α), ∀ (b : α), b ≤ a → p b :=
  mem_at_bot_sets

theorem eventually_ge_at_top {α : Type u_3} [preorder α] (a : α) : filter.eventually (fun (x : α) => a ≤ x) at_top :=
  mem_at_top a

theorem eventually_le_at_bot {α : Type u_3} [preorder α] (a : α) : filter.eventually (fun (x : α) => x ≤ a) at_bot :=
  mem_at_bot a

theorem eventually_gt_at_top {α : Type u_3} [preorder α] [no_top_order α] (a : α) : filter.eventually (fun (x : α) => a < x) at_top :=
  Ioi_mem_at_top a

theorem eventually_lt_at_bot {α : Type u_3} [preorder α] [no_bot_order α] (a : α) : filter.eventually (fun (x : α) => x < a) at_bot :=
  Iio_mem_at_bot a

theorem at_top_basis_Ioi {α : Type u_3} [Nonempty α] [semilattice_sup α] [no_top_order α] : has_basis at_top (fun (_x : α) => True) set.Ioi := sorry

theorem at_top_countable_basis {α : Type u_3} [Nonempty α] [semilattice_sup α] [encodable α] : has_countable_basis at_top (fun (_x : α) => True) set.Ici :=
  has_countable_basis.mk (has_basis.mk (has_basis.mem_iff' at_top_basis))
    (set.countable_encodable (set_of fun (_x : α) => True))

theorem at_bot_countable_basis {α : Type u_3} [Nonempty α] [semilattice_inf α] [encodable α] : has_countable_basis at_bot (fun (_x : α) => True) set.Iic :=
  has_countable_basis.mk (has_basis.mk (has_basis.mem_iff' at_bot_basis))
    (set.countable_encodable (set_of fun (_x : α) => True))

theorem is_countably_generated_at_top {α : Type u_3} [Nonempty α] [semilattice_sup α] [encodable α] : is_countably_generated at_top :=
  has_countable_basis.is_countably_generated at_top_countable_basis

theorem is_countably_generated_at_bot {α : Type u_3} [Nonempty α] [semilattice_inf α] [encodable α] : is_countably_generated at_bot :=
  has_countable_basis.is_countably_generated at_bot_countable_basis

theorem order_top.at_top_eq (α : Type u_1) [order_top α] : at_top = pure ⊤ :=
  le_antisymm (iff.mpr le_pure_iff (eventually.mono (eventually_ge_at_top ⊤) fun (b : α) => top_unique))
    (le_infi fun (b : α) => iff.mpr le_principal_iff le_top)

theorem order_bot.at_bot_eq (α : Type u_1) [order_bot α] : at_bot = pure ⊥ :=
  order_top.at_top_eq (order_dual α)

theorem subsingleton.at_top_eq (α : Type u_1) [subsingleton α] [preorder α] : at_top = ⊤ := sorry

theorem subsingleton.at_bot_eq (α : Type u_1) [subsingleton α] [preorder α] : at_bot = ⊤ :=
  subsingleton.at_top_eq (order_dual α)

theorem tendsto_at_top_pure {α : Type u_3} {β : Type u_4} [order_top α] (f : α → β) : tendsto f at_top (pure (f ⊤)) :=
  Eq.symm (order_top.at_top_eq α) ▸ tendsto_pure_pure f ⊤

theorem tendsto_at_bot_pure {α : Type u_3} {β : Type u_4} [order_bot α] (f : α → β) : tendsto f at_bot (pure (f ⊥)) :=
  tendsto_at_top_pure f

theorem eventually.exists_forall_of_at_top {α : Type u_3} [semilattice_sup α] [Nonempty α] {p : α → Prop} (h : filter.eventually (fun (x : α) => p x) at_top) : ∃ (a : α), ∀ (b : α), b ≥ a → p b :=
  iff.mp eventually_at_top h

theorem eventually.exists_forall_of_at_bot {α : Type u_3} [semilattice_inf α] [Nonempty α] {p : α → Prop} (h : filter.eventually (fun (x : α) => p x) at_bot) : ∃ (a : α), ∀ (b : α), b ≤ a → p b :=
  iff.mp eventually_at_bot h

theorem frequently_at_top {α : Type u_3} [semilattice_sup α] [Nonempty α] {p : α → Prop} : filter.frequently (fun (x : α) => p x) at_top ↔ ∀ (a : α), ∃ (b : α), ∃ (H : b ≥ a), p b := sorry

theorem frequently_at_bot {α : Type u_3} [semilattice_inf α] [Nonempty α] {p : α → Prop} : filter.frequently (fun (x : α) => p x) at_bot ↔ ∀ (a : α), ∃ (b : α), ∃ (H : b ≤ a), p b :=
  frequently_at_top

theorem frequently_at_top' {α : Type u_3} [semilattice_sup α] [Nonempty α] [no_top_order α] {p : α → Prop} : filter.frequently (fun (x : α) => p x) at_top ↔ ∀ (a : α), ∃ (b : α), ∃ (H : b > a), p b := sorry

theorem frequently_at_bot' {α : Type u_3} [semilattice_inf α] [Nonempty α] [no_bot_order α] {p : α → Prop} : filter.frequently (fun (x : α) => p x) at_bot ↔ ∀ (a : α), ∃ (b : α), ∃ (H : b < a), p b :=
  frequently_at_top'

theorem frequently.forall_exists_of_at_top {α : Type u_3} [semilattice_sup α] [Nonempty α] {p : α → Prop} (h : filter.frequently (fun (x : α) => p x) at_top) (a : α) : ∃ (b : α), ∃ (H : b ≥ a), p b :=
  iff.mp frequently_at_top h

theorem frequently.forall_exists_of_at_bot {α : Type u_3} [semilattice_inf α] [Nonempty α] {p : α → Prop} (h : filter.frequently (fun (x : α) => p x) at_bot) (a : α) : ∃ (b : α), ∃ (H : b ≤ a), p b :=
  iff.mp frequently_at_bot h

theorem map_at_top_eq {α : Type u_3} {β : Type u_4} [Nonempty α] [semilattice_sup α] {f : α → β} : map f at_top = infi fun (a : α) => principal (f '' set_of fun (a' : α) => a ≤ a') :=
  has_basis.eq_infi (has_basis.map f at_top_basis)

theorem map_at_bot_eq {α : Type u_3} {β : Type u_4} [Nonempty α] [semilattice_inf α] {f : α → β} : map f at_bot = infi fun (a : α) => principal (f '' set_of fun (a' : α) => a' ≤ a) :=
  map_at_top_eq

theorem tendsto_at_top {α : Type u_3} {β : Type u_4} [preorder β] {m : α → β} {f : filter α} : tendsto m f at_top ↔ ∀ (b : β), filter.eventually (fun (a : α) => b ≤ m a) f := sorry

theorem tendsto_at_bot {α : Type u_3} {β : Type u_4} [preorder β] {m : α → β} {f : filter α} : tendsto m f at_bot ↔ ∀ (b : β), filter.eventually (fun (a : α) => m a ≤ b) f :=
  tendsto_at_top

theorem tendsto_at_top_mono' {α : Type u_3} {β : Type u_4} [preorder β] (l : filter α) {f₁ : α → β} {f₂ : α → β} (h : eventually_le l f₁ f₂) : tendsto f₁ l at_top → tendsto f₂ l at_top := sorry

theorem tendsto_at_bot_mono' {α : Type u_3} {β : Type u_4} [preorder β] (l : filter α) {f₁ : α → β} {f₂ : α → β} (h : eventually_le l f₁ f₂) : tendsto f₂ l at_bot → tendsto f₁ l at_bot :=
  tendsto_at_top_mono' l h

theorem tendsto_at_top_mono {α : Type u_3} {β : Type u_4} [preorder β] {l : filter α} {f : α → β} {g : α → β} (h : ∀ (n : α), f n ≤ g n) : tendsto f l at_top → tendsto g l at_top :=
  tendsto_at_top_mono' l (eventually_of_forall h)

theorem tendsto_at_bot_mono {α : Type u_3} {β : Type u_4} [preorder β] {l : filter α} {f : α → β} {g : α → β} (h : ∀ (n : α), f n ≤ g n) : tendsto g l at_bot → tendsto f l at_bot :=
  tendsto_at_top_mono h

/-!
### Sequences
-/

theorem inf_map_at_top_ne_bot_iff {α : Type u_3} {β : Type u_4} [semilattice_sup α] [Nonempty α] {F : filter β} {u : α → β} : ne_bot (F ⊓ map u at_top) ↔ ∀ (U : set β) (H : U ∈ F) (N : α), ∃ (n : α), ∃ (H : n ≥ N), u n ∈ U := sorry

theorem inf_map_at_bot_ne_bot_iff {α : Type u_3} {β : Type u_4} [semilattice_inf α] [Nonempty α] {F : filter β} {u : α → β} : ne_bot (F ⊓ map u at_bot) ↔ ∀ (U : set β) (H : U ∈ F) (N : α), ∃ (n : α), ∃ (H : n ≤ N), u n ∈ U :=
  inf_map_at_top_ne_bot_iff

theorem extraction_of_frequently_at_top' {P : ℕ → Prop} (h : ∀ (N : ℕ), ∃ (n : ℕ), ∃ (H : n > N), P n) : ∃ (φ : ℕ → ℕ), strict_mono φ ∧ ∀ (n : ℕ), P (φ n) := sorry

theorem extraction_of_frequently_at_top {P : ℕ → Prop} (h : filter.frequently (fun (n : ℕ) => P n) at_top) : ∃ (φ : ℕ → ℕ), strict_mono φ ∧ ∀ (n : ℕ), P (φ n) :=
  extraction_of_frequently_at_top'
    (eq.mp (Eq._oldrec (Eq.refl (filter.frequently (fun (n : ℕ) => P n) at_top)) (propext frequently_at_top')) h)

theorem extraction_of_eventually_at_top {P : ℕ → Prop} (h : filter.eventually (fun (n : ℕ) => P n) at_top) : ∃ (φ : ℕ → ℕ), strict_mono φ ∧ ∀ (n : ℕ), P (φ n) :=
  extraction_of_frequently_at_top (eventually.frequently h)

theorem exists_le_of_tendsto_at_top {α : Type u_3} {β : Type u_4} [semilattice_sup α] [preorder β] {u : α → β} (h : tendsto u at_top at_top) (a : α) (b : β) : ∃ (a' : α), ∃ (H : a' ≥ a), b ≤ u a' := sorry

theorem exists_le_of_tendsto_at_bot {α : Type u_3} {β : Type u_4} [semilattice_sup α] [preorder β] {u : α → β} (h : tendsto u at_top at_bot) (a : α) (b : β) : ∃ (a' : α), ∃ (H : a' ≥ a), u a' ≤ b :=
  exists_le_of_tendsto_at_top h

theorem exists_lt_of_tendsto_at_top {α : Type u_3} {β : Type u_4} [semilattice_sup α] [preorder β] [no_top_order β] {u : α → β} (h : tendsto u at_top at_top) (a : α) (b : β) : ∃ (a' : α), ∃ (H : a' ≥ a), b < u a' := sorry

theorem exists_lt_of_tendsto_at_bot {α : Type u_3} {β : Type u_4} [semilattice_sup α] [preorder β] [no_bot_order β] {u : α → β} (h : tendsto u at_top at_bot) (a : α) (b : β) : ∃ (a' : α), ∃ (H : a' ≥ a), u a' < b :=
  exists_lt_of_tendsto_at_top h

/--
If `u` is a sequence which is unbounded above,
then after any point, it reaches a value strictly greater than all previous values.
-/
theorem high_scores {β : Type u_4} [linear_order β] [no_top_order β] {u : ℕ → β} (hu : tendsto u at_top at_top) (N : ℕ) : ∃ (n : ℕ), ∃ (H : n ≥ N), ∀ (k : ℕ), k < n → u k < u n := sorry

/--
If `u` is a sequence which is unbounded below,
then after any point, it reaches a value strictly smaller than all previous values.
-/
theorem low_scores {β : Type u_4} [linear_order β] [no_bot_order β] {u : ℕ → β} (hu : tendsto u at_top at_bot) (N : ℕ) : ∃ (n : ℕ), ∃ (H : n ≥ N), ∀ (k : ℕ), k < n → u n < u k :=
  high_scores hu

/--
If `u` is a sequence which is unbounded above,
then it `frequently` reaches a value strictly greater than all previous values.
-/
theorem frequently_high_scores {β : Type u_4} [linear_order β] [no_top_order β] {u : ℕ → β} (hu : tendsto u at_top at_top) : filter.frequently (fun (n : ℕ) => ∀ (k : ℕ), k < n → u k < u n) at_top := sorry

/--
If `u` is a sequence which is unbounded below,
then it `frequently` reaches a value strictly smaller than all previous values.
-/
theorem frequently_low_scores {β : Type u_4} [linear_order β] [no_bot_order β] {u : ℕ → β} (hu : tendsto u at_top at_bot) : filter.frequently (fun (n : ℕ) => ∀ (k : ℕ), k < n → u n < u k) at_top :=
  frequently_high_scores hu

theorem strict_mono_subseq_of_tendsto_at_top {β : Type u_1} [linear_order β] [no_top_order β] {u : ℕ → β} (hu : tendsto u at_top at_top) : ∃ (φ : ℕ → ℕ), strict_mono φ ∧ strict_mono (u ∘ φ) := sorry

theorem strict_mono_subseq_of_id_le {u : ℕ → ℕ} (hu : ∀ (n : ℕ), n ≤ u n) : ∃ (φ : ℕ → ℕ), strict_mono φ ∧ strict_mono (u ∘ φ) :=
  strict_mono_subseq_of_tendsto_at_top (tendsto_at_top_mono hu tendsto_id)

theorem strict_mono_tendsto_at_top {φ : ℕ → ℕ} (h : strict_mono φ) : tendsto φ at_top at_top :=
  tendsto_at_top_mono (strict_mono.id_le h) tendsto_id

theorem tendsto_at_top_add_nonneg_left' {α : Type u_3} {β : Type u_4} [ordered_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (hf : filter.eventually (fun (x : α) => 0 ≤ f x) l) (hg : tendsto g l at_top) : tendsto (fun (x : α) => f x + g x) l at_top :=
  tendsto_at_top_mono' l (eventually.mono hf fun (x : α) => le_add_of_nonneg_left) hg

theorem tendsto_at_bot_add_nonpos_left' {α : Type u_3} {β : Type u_4} [ordered_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (hf : filter.eventually (fun (x : α) => f x ≤ 0) l) (hg : tendsto g l at_bot) : tendsto (fun (x : α) => f x + g x) l at_bot :=
  tendsto_at_top_add_nonneg_left' hf hg

theorem tendsto_at_top_add_nonneg_left {α : Type u_3} {β : Type u_4} [ordered_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (hf : ∀ (x : α), 0 ≤ f x) (hg : tendsto g l at_top) : tendsto (fun (x : α) => f x + g x) l at_top :=
  tendsto_at_top_add_nonneg_left' (eventually_of_forall hf) hg

theorem tendsto_at_bot_add_nonpos_left {α : Type u_3} {β : Type u_4} [ordered_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (hf : ∀ (x : α), f x ≤ 0) (hg : tendsto g l at_bot) : tendsto (fun (x : α) => f x + g x) l at_bot :=
  tendsto_at_top_add_nonneg_left hf hg

theorem tendsto_at_top_add_nonneg_right' {α : Type u_3} {β : Type u_4} [ordered_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (hf : tendsto f l at_top) (hg : filter.eventually (fun (x : α) => 0 ≤ g x) l) : tendsto (fun (x : α) => f x + g x) l at_top :=
  tendsto_at_top_mono' l (monotone_mem_sets (fun (x : α) => le_add_of_nonneg_right) hg) hf

theorem tendsto_at_bot_add_nonpos_right' {α : Type u_3} {β : Type u_4} [ordered_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (hf : tendsto f l at_bot) (hg : filter.eventually (fun (x : α) => g x ≤ 0) l) : tendsto (fun (x : α) => f x + g x) l at_bot :=
  tendsto_at_top_add_nonneg_right' hf hg

theorem tendsto_at_top_add_nonneg_right {α : Type u_3} {β : Type u_4} [ordered_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (hf : tendsto f l at_top) (hg : ∀ (x : α), 0 ≤ g x) : tendsto (fun (x : α) => f x + g x) l at_top :=
  tendsto_at_top_add_nonneg_right' hf (eventually_of_forall hg)

theorem tendsto_at_bot_add_nonpos_right {α : Type u_3} {β : Type u_4} [ordered_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (hf : tendsto f l at_bot) (hg : ∀ (x : α), g x ≤ 0) : tendsto (fun (x : α) => f x + g x) l at_bot :=
  tendsto_at_top_add_nonneg_right hf hg

theorem tendsto_at_top_add {α : Type u_3} {β : Type u_4} [ordered_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (hf : tendsto f l at_top) (hg : tendsto g l at_top) : tendsto (fun (x : α) => f x + g x) l at_top :=
  tendsto_at_top_add_nonneg_left' (iff.mp tendsto_at_top hf 0) hg

theorem tendsto_at_bot_add {α : Type u_3} {β : Type u_4} [ordered_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (hf : tendsto f l at_bot) (hg : tendsto g l at_bot) : tendsto (fun (x : α) => f x + g x) l at_bot :=
  tendsto_at_top_add hf hg

theorem tendsto.nsmul_at_top {α : Type u_3} {β : Type u_4} [ordered_add_comm_monoid β] {l : filter α} {f : α → β} (hf : tendsto f l at_top) {n : ℕ} (hn : 0 < n) : tendsto (fun (x : α) => n •ℕ f x) l at_top := sorry

theorem tendsto.nsmul_at_bot {α : Type u_3} {β : Type u_4} [ordered_add_comm_monoid β] {l : filter α} {f : α → β} (hf : tendsto f l at_bot) {n : ℕ} (hn : 0 < n) : tendsto (fun (x : α) => n •ℕ f x) l at_bot :=
  tendsto.nsmul_at_top hf hn

theorem tendsto_bit0_at_top {β : Type u_4} [ordered_add_comm_monoid β] : tendsto bit0 at_top at_top :=
  tendsto_at_top_add tendsto_id tendsto_id

theorem tendsto_bit0_at_bot {β : Type u_4} [ordered_add_comm_monoid β] : tendsto bit0 at_bot at_bot :=
  tendsto_at_bot_add tendsto_id tendsto_id

theorem tendsto_at_top_of_add_const_left {α : Type u_3} {β : Type u_4} [ordered_cancel_add_comm_monoid β] {l : filter α} {f : α → β} (C : β) (hf : tendsto (fun (x : α) => C + f x) l at_top) : tendsto f l at_top :=
  iff.mpr tendsto_at_top
    fun (b : β) => eventually.mono (iff.mp tendsto_at_top hf (C + b)) fun (x : α) => le_of_add_le_add_left

theorem tendsto_at_bot_of_add_const_left {α : Type u_3} {β : Type u_4} [ordered_cancel_add_comm_monoid β] {l : filter α} {f : α → β} (C : β) (hf : tendsto (fun (x : α) => C + f x) l at_bot) : tendsto f l at_bot :=
  tendsto_at_top_of_add_const_left C hf

theorem tendsto_at_top_of_add_const_right {α : Type u_3} {β : Type u_4} [ordered_cancel_add_comm_monoid β] {l : filter α} {f : α → β} (C : β) (hf : tendsto (fun (x : α) => f x + C) l at_top) : tendsto f l at_top :=
  iff.mpr tendsto_at_top
    fun (b : β) => eventually.mono (iff.mp tendsto_at_top hf (b + C)) fun (x : α) => le_of_add_le_add_right

theorem tendsto_at_bot_of_add_const_right {α : Type u_3} {β : Type u_4} [ordered_cancel_add_comm_monoid β] {l : filter α} {f : α → β} (C : β) (hf : tendsto (fun (x : α) => f x + C) l at_bot) : tendsto f l at_bot :=
  tendsto_at_top_of_add_const_right C hf

theorem tendsto_at_top_of_add_bdd_above_left' {α : Type u_3} {β : Type u_4} [ordered_cancel_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (C : β) (hC : filter.eventually (fun (x : α) => f x ≤ C) l) (h : tendsto (fun (x : α) => f x + g x) l at_top) : tendsto g l at_top :=
  tendsto_at_top_of_add_const_left C
    (tendsto_at_top_mono' l (eventually.mono hC fun (x : α) (hx : f x ≤ C) => add_le_add_right hx (g x)) h)

theorem tendsto_at_bot_of_add_bdd_below_left' {α : Type u_3} {β : Type u_4} [ordered_cancel_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (C : β) (hC : filter.eventually (fun (x : α) => C ≤ f x) l) (h : tendsto (fun (x : α) => f x + g x) l at_bot) : tendsto g l at_bot :=
  tendsto_at_top_of_add_bdd_above_left' C hC h

theorem tendsto_at_top_of_add_bdd_above_left {α : Type u_3} {β : Type u_4} [ordered_cancel_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (C : β) (hC : ∀ (x : α), f x ≤ C) : tendsto (fun (x : α) => f x + g x) l at_top → tendsto g l at_top :=
  tendsto_at_top_of_add_bdd_above_left' C (univ_mem_sets' hC)

theorem tendsto_at_bot_of_add_bdd_below_left {α : Type u_3} {β : Type u_4} [ordered_cancel_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (C : β) (hC : ∀ (x : α), C ≤ f x) : tendsto (fun (x : α) => f x + g x) l at_bot → tendsto g l at_bot :=
  tendsto_at_top_of_add_bdd_above_left C hC

theorem tendsto_at_top_of_add_bdd_above_right' {α : Type u_3} {β : Type u_4} [ordered_cancel_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (C : β) (hC : filter.eventually (fun (x : α) => g x ≤ C) l) (h : tendsto (fun (x : α) => f x + g x) l at_top) : tendsto f l at_top :=
  tendsto_at_top_of_add_const_right C
    (tendsto_at_top_mono' l (eventually.mono hC fun (x : α) (hx : g x ≤ C) => add_le_add_left hx (f x)) h)

theorem tendsto_at_bot_of_add_bdd_below_right' {α : Type u_3} {β : Type u_4} [ordered_cancel_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (C : β) (hC : filter.eventually (fun (x : α) => C ≤ g x) l) (h : tendsto (fun (x : α) => f x + g x) l at_bot) : tendsto f l at_bot :=
  tendsto_at_top_of_add_bdd_above_right' C hC h

theorem tendsto_at_top_of_add_bdd_above_right {α : Type u_3} {β : Type u_4} [ordered_cancel_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (C : β) (hC : ∀ (x : α), g x ≤ C) : tendsto (fun (x : α) => f x + g x) l at_top → tendsto f l at_top :=
  tendsto_at_top_of_add_bdd_above_right' C (univ_mem_sets' hC)

theorem tendsto_at_bot_of_add_bdd_below_right {α : Type u_3} {β : Type u_4} [ordered_cancel_add_comm_monoid β] {l : filter α} {f : α → β} {g : α → β} (C : β) (hC : ∀ (x : α), C ≤ g x) : tendsto (fun (x : α) => f x + g x) l at_bot → tendsto f l at_bot :=
  tendsto_at_top_of_add_bdd_above_right C hC

theorem tendsto_at_top_add_left_of_le' {α : Type u_3} {β : Type u_4} [ordered_add_comm_group β] (l : filter α) {f : α → β} {g : α → β} (C : β) (hf : filter.eventually (fun (x : α) => C ≤ f x) l) (hg : tendsto g l at_top) : tendsto (fun (x : α) => f x + g x) l at_top := sorry

theorem tendsto_at_bot_add_left_of_ge' {α : Type u_3} {β : Type u_4} [ordered_add_comm_group β] (l : filter α) {f : α → β} {g : α → β} (C : β) (hf : filter.eventually (fun (x : α) => f x ≤ C) l) (hg : tendsto g l at_bot) : tendsto (fun (x : α) => f x + g x) l at_bot :=
  tendsto_at_top_add_left_of_le' l C hf hg

theorem tendsto_at_top_add_left_of_le {α : Type u_3} {β : Type u_4} [ordered_add_comm_group β] (l : filter α) {f : α → β} {g : α → β} (C : β) (hf : ∀ (x : α), C ≤ f x) (hg : tendsto g l at_top) : tendsto (fun (x : α) => f x + g x) l at_top :=
  tendsto_at_top_add_left_of_le' l C (univ_mem_sets' hf) hg

theorem tendsto_at_bot_add_left_of_ge {α : Type u_3} {β : Type u_4} [ordered_add_comm_group β] (l : filter α) {f : α → β} {g : α → β} (C : β) (hf : ∀ (x : α), f x ≤ C) (hg : tendsto g l at_bot) : tendsto (fun (x : α) => f x + g x) l at_bot :=
  tendsto_at_top_add_left_of_le l C hf hg

theorem tendsto_at_top_add_right_of_le' {α : Type u_3} {β : Type u_4} [ordered_add_comm_group β] (l : filter α) {f : α → β} {g : α → β} (C : β) (hf : tendsto f l at_top) (hg : filter.eventually (fun (x : α) => C ≤ g x) l) : tendsto (fun (x : α) => f x + g x) l at_top := sorry

theorem tendsto_at_bot_add_right_of_ge' {α : Type u_3} {β : Type u_4} [ordered_add_comm_group β] (l : filter α) {f : α → β} {g : α → β} (C : β) (hf : tendsto f l at_bot) (hg : filter.eventually (fun (x : α) => g x ≤ C) l) : tendsto (fun (x : α) => f x + g x) l at_bot :=
  tendsto_at_top_add_right_of_le' l C hf hg

theorem tendsto_at_top_add_right_of_le {α : Type u_3} {β : Type u_4} [ordered_add_comm_group β] (l : filter α) {f : α → β} {g : α → β} (C : β) (hf : tendsto f l at_top) (hg : ∀ (x : α), C ≤ g x) : tendsto (fun (x : α) => f x + g x) l at_top :=
  tendsto_at_top_add_right_of_le' l C hf (univ_mem_sets' hg)

theorem tendsto_at_bot_add_right_of_ge {α : Type u_3} {β : Type u_4} [ordered_add_comm_group β] (l : filter α) {f : α → β} {g : α → β} (C : β) (hf : tendsto f l at_bot) (hg : ∀ (x : α), g x ≤ C) : tendsto (fun (x : α) => f x + g x) l at_bot :=
  tendsto_at_top_add_right_of_le l C hf hg

theorem tendsto_at_top_add_const_left {α : Type u_3} {β : Type u_4} [ordered_add_comm_group β] (l : filter α) {f : α → β} (C : β) (hf : tendsto f l at_top) : tendsto (fun (x : α) => C + f x) l at_top :=
  tendsto_at_top_add_left_of_le' l C (univ_mem_sets' fun (_x : α) => le_refl C) hf

theorem tendsto_at_bot_add_const_left {α : Type u_3} {β : Type u_4} [ordered_add_comm_group β] (l : filter α) {f : α → β} (C : β) (hf : tendsto f l at_bot) : tendsto (fun (x : α) => C + f x) l at_bot :=
  tendsto_at_top_add_const_left l C hf

theorem tendsto_at_top_add_const_right {α : Type u_3} {β : Type u_4} [ordered_add_comm_group β] (l : filter α) {f : α → β} (C : β) (hf : tendsto f l at_top) : tendsto (fun (x : α) => f x + C) l at_top :=
  tendsto_at_top_add_right_of_le' l C hf (univ_mem_sets' fun (_x : α) => le_refl C)

theorem tendsto_at_bot_add_const_right {α : Type u_3} {β : Type u_4} [ordered_add_comm_group β] (l : filter α) {f : α → β} (C : β) (hf : tendsto f l at_bot) : tendsto (fun (x : α) => f x + C) l at_bot :=
  tendsto_at_top_add_const_right l C hf

theorem tendsto_neg_at_top_at_bot {β : Type u_4} [ordered_add_comm_group β] : tendsto Neg.neg at_top at_bot := sorry

theorem tendsto_neg_at_bot_at_top {β : Type u_4} [ordered_add_comm_group β] : tendsto Neg.neg at_bot at_top :=
  tendsto_neg_at_top_at_bot

theorem tendsto_bit1_at_top {α : Type u_3} [ordered_semiring α] : tendsto bit1 at_top at_top :=
  tendsto_at_top_add_nonneg_right tendsto_bit0_at_top fun (_x : α) => zero_le_one

theorem tendsto.at_top_mul_at_top {α : Type u_3} {β : Type u_4} [ordered_semiring α] {l : filter β} {f : β → α} {g : β → α} (hf : tendsto f l at_top) (hg : tendsto g l at_top) : tendsto (fun (x : β) => f x * g x) l at_top := sorry

theorem tendsto_mul_self_at_top {α : Type u_3} [ordered_semiring α] : tendsto (fun (x : α) => x * x) at_top at_top :=
  tendsto.at_top_mul_at_top tendsto_id tendsto_id

/-- The monomial function `x^n` tends to `+∞` at `+∞` for any positive natural `n`.
A version for positive real powers exists as `tendsto_rpow_at_top`. -/
theorem tendsto_pow_at_top {α : Type u_3} [ordered_semiring α] {n : ℕ} (hn : 1 ≤ n) : tendsto (fun (x : α) => x ^ n) at_top at_top := sorry

theorem zero_pow_eventually_eq {α : Type u_3} [monoid_with_zero α] : eventually_eq at_top (fun (n : ℕ) => 0 ^ n) fun (n : ℕ) => 0 :=
  iff.mpr eventually_at_top (Exists.intro 1 fun (n : ℕ) (hn : n ≥ 1) => zero_pow (has_lt.lt.trans_le zero_lt_one hn))

theorem tendsto.at_top_mul_at_bot {α : Type u_3} {β : Type u_4} [ordered_ring α] {l : filter β} {f : β → α} {g : β → α} (hf : tendsto f l at_top) (hg : tendsto g l at_bot) : tendsto (fun (x : β) => f x * g x) l at_bot := sorry

theorem tendsto.at_bot_mul_at_top {α : Type u_3} {β : Type u_4} [ordered_ring α] {l : filter β} {f : β → α} {g : β → α} (hf : tendsto f l at_bot) (hg : tendsto g l at_top) : tendsto (fun (x : β) => f x * g x) l at_bot := sorry

theorem tendsto.at_bot_mul_at_bot {α : Type u_3} {β : Type u_4} [ordered_ring α] {l : filter β} {f : β → α} {g : β → α} (hf : tendsto f l at_bot) (hg : tendsto g l at_bot) : tendsto (fun (x : β) => f x * g x) l at_top := sorry

/-- $\lim_{x\to+\infty}|x|=+\infty$ -/
theorem tendsto_abs_at_top_at_top {α : Type u_3} [linear_ordered_add_comm_group α] : tendsto abs at_top at_top :=
  tendsto_at_top_mono le_abs_self tendsto_id

/-- $\lim_{x\to-\infty}|x|=+\infty$ -/
theorem tendsto_abs_at_bot_at_top {α : Type u_3} [linear_ordered_add_comm_group α] : tendsto abs at_bot at_top :=
  tendsto_at_top_mono neg_le_abs_self tendsto_neg_at_bot_at_top

theorem tendsto.at_top_of_const_mul {α : Type u_3} {β : Type u_4} [linear_ordered_semiring α] {l : filter β} {f : β → α} {c : α} (hc : 0 < c) (hf : tendsto (fun (x : β) => c * f x) l at_top) : tendsto f l at_top :=
  iff.mpr tendsto_at_top
    fun (b : α) =>
      eventually.mono (iff.mp tendsto_at_top hf (c * b)) fun (x : β) (hx : c * b ≤ c * f x) => le_of_mul_le_mul_left hx hc

theorem tendsto.at_top_of_mul_const {α : Type u_3} {β : Type u_4} [linear_ordered_semiring α] {l : filter β} {f : β → α} {c : α} (hc : 0 < c) (hf : tendsto (fun (x : β) => f x * c) l at_top) : tendsto f l at_top := sorry

theorem nonneg_of_eventually_pow_nonneg {α : Type u_3} [linear_ordered_ring α] {a : α} (h : filter.eventually (fun (n : ℕ) => 0 ≤ a ^ n) at_top) : 0 ≤ a :=
  (fun (_a : ∃ (x : ℕ), (fun (x : ℕ) => 0 ≤ a ^ bit1 x) x) =>
      Exists.dcases_on _a fun (w : ℕ) (h_1 : 0 ≤ a ^ bit1 w) => idRhs (0 ≤ a) (iff.mp pow_bit1_nonneg_iff h_1))
    (eventually.exists (tendsto.eventually tendsto_bit1_at_top h))

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the left) also tends to infinity. For a version working in `ℕ` or `ℤ`, use
`filter.tendsto.const_mul_at_top'` instead. -/
theorem tendsto.const_mul_at_top {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : 0 < r) (hf : tendsto f l at_top) : tendsto (fun (x : β) => r * f x) l at_top := sorry

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the right) also tends to infinity. For a version working in `ℕ` or `ℤ`, use
`filter.tendsto.at_top_mul_const'` instead. -/
theorem tendsto.at_top_mul_const {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : 0 < r) (hf : tendsto f l at_top) : tendsto (fun (x : β) => f x * r) l at_top := sorry

/-- If a function tends to infinity along a filter, then this function divided by a positive
constant also tends to infinity. -/
theorem tendsto.at_top_div_const {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : 0 < r) (hf : tendsto f l at_top) : tendsto (fun (x : β) => f x / r) l at_top :=
  tendsto.at_top_mul_const (iff.mpr inv_pos hr) hf

/-- If a function tends to infinity along a filter, then this function multiplied by a negative
constant (on the left) tends to negative infinity. -/
theorem tendsto.neg_const_mul_at_top {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : r < 0) (hf : tendsto f l at_top) : tendsto (fun (x : β) => r * f x) l at_bot := sorry

/-- If a function tends to infinity along a filter, then this function multiplied by a negative
constant (on the right) tends to negative infinity. -/
theorem tendsto.at_top_mul_neg_const {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : r < 0) (hf : tendsto f l at_top) : tendsto (fun (x : β) => f x * r) l at_bot := sorry

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a positive constant (on the left) also tends to negative infinity. -/
theorem tendsto.const_mul_at_bot {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : 0 < r) (hf : tendsto f l at_bot) : tendsto (fun (x : β) => r * f x) l at_bot := sorry

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a positive constant (on the right) also tends to negative infinity. -/
theorem tendsto.at_bot_mul_const {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : 0 < r) (hf : tendsto f l at_bot) : tendsto (fun (x : β) => f x * r) l at_bot := sorry

/-- If a function tends to negative infinity along a filter, then this function divided by
a positive constant also tends to negative infinity. -/
theorem tendsto.at_bot_div_const {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : 0 < r) (hf : tendsto f l at_bot) : tendsto (fun (x : β) => f x / r) l at_bot :=
  tendsto.at_bot_mul_const (iff.mpr inv_pos hr) hf

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a negative constant (on the left) tends to positive infinity. -/
theorem tendsto.neg_const_mul_at_bot {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : r < 0) (hf : tendsto f l at_bot) : tendsto (fun (x : β) => r * f x) l at_top := sorry

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a negative constant (on the right) tends to positive infinity. -/
theorem tendsto.at_bot_mul_neg_const {α : Type u_3} {β : Type u_4} [linear_ordered_field α] {l : filter β} {f : β → α} {r : α} (hr : r < 0) (hf : tendsto f l at_bot) : tendsto (fun (x : β) => f x * r) l at_top := sorry

theorem tendsto_at_top' {α : Type u_3} {β : Type u_4} [Nonempty α] [semilattice_sup α] {f : α → β} {l : filter β} : tendsto f at_top l ↔ ∀ (s : set β), s ∈ l → ∃ (a : α), ∀ (b : α), b ≥ a → f b ∈ s := sorry

theorem tendsto_at_bot' {α : Type u_3} {β : Type u_4} [Nonempty α] [semilattice_inf α] {f : α → β} {l : filter β} : tendsto f at_bot l ↔ ∀ (s : set β), s ∈ l → ∃ (a : α), ∀ (b : α), b ≤ a → f b ∈ s :=
  tendsto_at_top'

theorem tendsto_at_top_principal {α : Type u_3} {β : Type u_4} [Nonempty β] [semilattice_sup β] {f : β → α} {s : set α} : tendsto f at_top (principal s) ↔ ∃ (N : β), ∀ (n : β), n ≥ N → f n ∈ s := sorry

theorem tendsto_at_bot_principal {α : Type u_3} {β : Type u_4} [Nonempty β] [semilattice_inf β] {f : β → α} {s : set α} : tendsto f at_bot (principal s) ↔ ∃ (N : β), ∀ (n : β), n ≤ N → f n ∈ s :=
  tendsto_at_top_principal

/-- A function `f` grows to `+∞` independent of an order-preserving embedding `e`. -/
theorem tendsto_at_top_at_top {α : Type u_3} {β : Type u_4} [Nonempty α] [semilattice_sup α] [preorder β] {f : α → β} : tendsto f at_top at_top ↔ ∀ (b : β), ∃ (i : α), ∀ (a : α), i ≤ a → b ≤ f a :=
  iff.trans tendsto_infi (forall_congr fun (b : β) => tendsto_at_top_principal)

theorem tendsto_at_top_at_bot {α : Type u_3} {β : Type u_4} [Nonempty α] [semilattice_sup α] [preorder β] {f : α → β} : tendsto f at_top at_bot ↔ ∀ (b : β), ∃ (i : α), ∀ (a : α), i ≤ a → f a ≤ b :=
  tendsto_at_top_at_top

theorem tendsto_at_bot_at_top {α : Type u_3} {β : Type u_4} [Nonempty α] [semilattice_inf α] [preorder β] {f : α → β} : tendsto f at_bot at_top ↔ ∀ (b : β), ∃ (i : α), ∀ (a : α), a ≤ i → b ≤ f a :=
  tendsto_at_top_at_top

theorem tendsto_at_bot_at_bot {α : Type u_3} {β : Type u_4} [Nonempty α] [semilattice_inf α] [preorder β] {f : α → β} : tendsto f at_bot at_bot ↔ ∀ (b : β), ∃ (i : α), ∀ (a : α), a ≤ i → f a ≤ b :=
  tendsto_at_top_at_top

theorem tendsto_at_top_at_top_of_monotone {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] {f : α → β} (hf : monotone f) (h : ∀ (b : β), ∃ (a : α), b ≤ f a) : tendsto f at_top at_top := sorry

theorem tendsto_at_bot_at_bot_of_monotone {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] {f : α → β} (hf : monotone f) (h : ∀ (b : β), ∃ (a : α), f a ≤ b) : tendsto f at_bot at_bot := sorry

theorem tendsto_at_top_at_top_iff_of_monotone {α : Type u_3} {β : Type u_4} [Nonempty α] [semilattice_sup α] [preorder β] {f : α → β} (hf : monotone f) : tendsto f at_top at_top ↔ ∀ (b : β), ∃ (a : α), b ≤ f a := sorry

theorem tendsto_at_bot_at_bot_iff_of_monotone {α : Type u_3} {β : Type u_4} [Nonempty α] [semilattice_inf α] [preorder β] {f : α → β} (hf : monotone f) : tendsto f at_bot at_bot ↔ ∀ (b : β), ∃ (a : α), f a ≤ b := sorry

theorem Mathlib.monotone.tendsto_at_top_at_top {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] {f : α → β} (hf : monotone f) (h : ∀ (b : β), ∃ (a : α), b ≤ f a) : tendsto f at_top at_top :=
  tendsto_at_top_at_top_of_monotone

theorem Mathlib.monotone.tendsto_at_bot_at_bot {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] {f : α → β} (hf : monotone f) (h : ∀ (b : β), ∃ (a : α), f a ≤ b) : tendsto f at_bot at_bot :=
  tendsto_at_bot_at_bot_of_monotone

theorem Mathlib.monotone.tendsto_at_top_at_top_iff {α : Type u_3} {β : Type u_4} [Nonempty α] [semilattice_sup α] [preorder β] {f : α → β} (hf : monotone f) : tendsto f at_top at_top ↔ ∀ (b : β), ∃ (a : α), b ≤ f a :=
  tendsto_at_top_at_top_iff_of_monotone

theorem Mathlib.monotone.tendsto_at_bot_at_bot_iff {α : Type u_3} {β : Type u_4} [Nonempty α] [semilattice_inf α] [preorder β] {f : α → β} (hf : monotone f) : tendsto f at_bot at_bot ↔ ∀ (b : β), ∃ (a : α), f a ≤ b :=
  tendsto_at_bot_at_bot_iff_of_monotone

theorem tendsto_at_top_embedding {α : Type u_3} {β : Type u_4} {γ : Type u_5} [preorder β] [preorder γ] {f : α → β} {e : β → γ} {l : filter α} (hm : ∀ (b₁ b₂ : β), e b₁ ≤ e b₂ ↔ b₁ ≤ b₂) (hu : ∀ (c : γ), ∃ (b : β), c ≤ e b) : tendsto (e ∘ f) l at_top ↔ tendsto f l at_top := sorry

/-- A function `f` goes to `-∞` independent of an order-preserving embedding `e`. -/
theorem tendsto_at_bot_embedding {α : Type u_3} {β : Type u_4} {γ : Type u_5} [preorder β] [preorder γ] {f : α → β} {e : β → γ} {l : filter α} (hm : ∀ (b₁ b₂ : β), e b₁ ≤ e b₂ ↔ b₁ ≤ b₂) (hu : ∀ (c : γ), ∃ (b : β), e b ≤ c) : tendsto (e ∘ f) l at_bot ↔ tendsto f l at_bot :=
  tendsto_at_top_embedding (function.swap hm) hu

theorem tendsto_finset_range : tendsto finset.range at_top at_top :=
  monotone.tendsto_at_top_at_top finset.range_mono finset.exists_nat_subset_range

theorem at_top_finset_eq_infi {α : Type u_3} : at_top = infi fun (x : α) => principal (set.Ici (singleton x)) := sorry

/-- If `f` is a monotone sequence of `finset`s and each `x` belongs to one of `f n`, then
`tendsto f at_top at_top`. -/
theorem tendsto_at_top_finset_of_monotone {α : Type u_3} {β : Type u_4} [preorder β] {f : β → finset α} (h : monotone f) (h' : ∀ (x : α), ∃ (n : β), x ∈ f n) : tendsto f at_top at_top := sorry

theorem Mathlib.monotone.tendsto_at_top_finset {α : Type u_3} {β : Type u_4} [preorder β] {f : β → finset α} (h : monotone f) (h' : ∀ (x : α), ∃ (n : β), x ∈ f n) : tendsto f at_top at_top :=
  tendsto_at_top_finset_of_monotone

theorem tendsto_finset_image_at_top_at_top {β : Type u_4} {γ : Type u_5} {i : β → γ} {j : γ → β} (h : function.left_inverse j i) : tendsto (finset.image j) at_top at_top := sorry

theorem tendsto_finset_preimage_at_top_at_top {α : Type u_3} {β : Type u_4} {f : α → β} (hf : function.injective f) : tendsto (fun (s : finset β) => finset.preimage s f (function.injective.inj_on hf (f ⁻¹' ↑s))) at_top at_top :=
  monotone.tendsto_at_top_finset (finset.monotone_preimage hf)
    fun (x : α) => Exists.intro (singleton (f x)) (iff.mpr finset.mem_preimage (finset.mem_singleton_self (f x)))

theorem prod_at_top_at_top_eq {β₁ : Type u_1} {β₂ : Type u_2} [semilattice_sup β₁] [semilattice_sup β₂] : filter.prod at_top at_top = at_top := sorry

theorem prod_at_bot_at_bot_eq {β₁ : Type u_1} {β₂ : Type u_2} [semilattice_inf β₁] [semilattice_inf β₂] : filter.prod at_bot at_bot = at_bot :=
  prod_at_top_at_top_eq

theorem prod_map_at_top_eq {α₁ : Type u_1} {α₂ : Type u_2} {β₁ : Type u_3} {β₂ : Type u_4} [semilattice_sup β₁] [semilattice_sup β₂] (u₁ : β₁ → α₁) (u₂ : β₂ → α₂) : filter.prod (map u₁ at_top) (map u₂ at_top) = map (prod.map u₁ u₂) at_top := sorry

theorem prod_map_at_bot_eq {α₁ : Type u_1} {α₂ : Type u_2} {β₁ : Type u_3} {β₂ : Type u_4} [semilattice_inf β₁] [semilattice_inf β₂] (u₁ : β₁ → α₁) (u₂ : β₂ → α₂) : filter.prod (map u₁ at_bot) (map u₂ at_bot) = map (prod.map u₁ u₂) at_bot :=
  prod_map_at_top_eq u₁ u₂

/-- A function `f` maps upwards closed sets (at_top sets) to upwards closed sets when it is a
Galois insertion. The Galois "insertion" and "connection" is weakened to only require it to be an
insertion and a connetion above `b'`. -/
theorem map_at_top_eq_of_gc {α : Type u_3} {β : Type u_4} [semilattice_sup α] [semilattice_sup β] {f : α → β} (g : β → α) (b' : β) (hf : monotone f) (gc : ∀ (a : α) (b : β), b ≥ b' → (f a ≤ b ↔ a ≤ g b)) (hgi : ∀ (b : β), b ≥ b' → b ≤ f (g b)) : map f at_top = at_top := sorry

theorem map_at_bot_eq_of_gc {α : Type u_3} {β : Type u_4} [semilattice_inf α] [semilattice_inf β] {f : α → β} (g : β → α) (b' : β) (hf : monotone f) (gc : ∀ (a : α) (b : β), b ≤ b' → (b ≤ f a ↔ g b ≤ a)) (hgi : ∀ (b : β), b ≤ b' → f (g b) ≤ b) : map f at_bot = at_bot :=
  map_at_top_eq_of_gc (fun (b : β) => g b) b' (monotone.order_dual hf) gc hgi

theorem map_coe_at_top_of_Ici_subset {α : Type u_3} [semilattice_sup α] {a : α} {s : set α} (h : set.Ici a ⊆ s) : map coe at_top = at_top := sorry

/-- The image of the filter `at_top` on `Ici a` under the coercion equals `at_top`. -/
@[simp] theorem map_coe_Ici_at_top {α : Type u_3} [semilattice_sup α] (a : α) : map coe at_top = at_top :=
  map_coe_at_top_of_Ici_subset (set.subset.refl (set.Ici a))

/-- The image of the filter `at_top` on `Ioi a` under the coercion equals `at_top`. -/
@[simp] theorem map_coe_Ioi_at_top {α : Type u_3} [semilattice_sup α] [no_top_order α] (a : α) : map coe at_top = at_top :=
  Exists.dcases_on (no_top a) fun (b : α) (hb : a < b) => map_coe_at_top_of_Ici_subset (iff.mpr set.Ici_subset_Ioi hb)

/-- The `at_top` filter for an open interval `Ioi a` comes from the `at_top` filter in the ambient
order. -/
theorem at_top_Ioi_eq {α : Type u_3} [semilattice_sup α] (a : α) : at_top = comap coe at_top := sorry

/-- The `at_top` filter for an open interval `Ici a` comes from the `at_top` filter in the ambient
order. -/
theorem at_top_Ici_eq {α : Type u_3} [semilattice_sup α] (a : α) : at_top = comap coe at_top :=
  eq.mpr (id (Eq._oldrec (Eq.refl (at_top = comap coe at_top)) (Eq.symm (map_coe_Ici_at_top a))))
    (eq.mpr (id (Eq._oldrec (Eq.refl (at_top = comap coe (map coe at_top))) (comap_map subtype.coe_injective)))
      (Eq.refl at_top))

/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient
order. -/
@[simp] theorem map_coe_Iio_at_bot {α : Type u_3} [semilattice_inf α] [no_bot_order α] (a : α) : map coe at_bot = at_bot :=
  map_coe_Ioi_at_top a

/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient
order. -/
theorem at_bot_Iio_eq {α : Type u_3} [semilattice_inf α] (a : α) : at_bot = comap coe at_bot :=
  at_top_Ioi_eq a

/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient
order. -/
@[simp] theorem map_coe_Iic_at_bot {α : Type u_3} [semilattice_inf α] (a : α) : map coe at_bot = at_bot :=
  map_coe_Ici_at_top a

/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient
order. -/
theorem at_bot_Iic_eq {α : Type u_3} [semilattice_inf α] (a : α) : at_bot = comap coe at_bot :=
  at_top_Ici_eq a

theorem tendsto_Ioi_at_top {α : Type u_3} {β : Type u_4} [semilattice_sup α] {a : α} {f : β → ↥(set.Ioi a)} {l : filter β} : tendsto f l at_top ↔ tendsto (fun (x : β) => ↑(f x)) l at_top := sorry

theorem tendsto_Iio_at_bot {α : Type u_3} {β : Type u_4} [semilattice_inf α] {a : α} {f : β → ↥(set.Iio a)} {l : filter β} : tendsto f l at_bot ↔ tendsto (fun (x : β) => ↑(f x)) l at_bot := sorry

theorem tendsto_Ici_at_top {α : Type u_3} {β : Type u_4} [semilattice_sup α] {a : α} {f : β → ↥(set.Ici a)} {l : filter β} : tendsto f l at_top ↔ tendsto (fun (x : β) => ↑(f x)) l at_top := sorry

theorem tendsto_Iic_at_bot {α : Type u_3} {β : Type u_4} [semilattice_inf α] {a : α} {f : β → ↥(set.Iic a)} {l : filter β} : tendsto f l at_bot ↔ tendsto (fun (x : β) => ↑(f x)) l at_bot := sorry

@[simp] theorem tendsto_comp_coe_Ioi_at_top {α : Type u_3} {β : Type u_4} [semilattice_sup α] [no_top_order α] {a : α} {f : α → β} {l : filter β} : tendsto (fun (x : ↥(set.Ioi a)) => f ↑x) at_top l ↔ tendsto f at_top l := sorry

@[simp] theorem tendsto_comp_coe_Ici_at_top {α : Type u_3} {β : Type u_4} [semilattice_sup α] {a : α} {f : α → β} {l : filter β} : tendsto (fun (x : ↥(set.Ici a)) => f ↑x) at_top l ↔ tendsto f at_top l := sorry

@[simp] theorem tendsto_comp_coe_Iio_at_bot {α : Type u_3} {β : Type u_4} [semilattice_inf α] [no_bot_order α] {a : α} {f : α → β} {l : filter β} : tendsto (fun (x : ↥(set.Iio a)) => f ↑x) at_bot l ↔ tendsto f at_bot l := sorry

@[simp] theorem tendsto_comp_coe_Iic_at_bot {α : Type u_3} {β : Type u_4} [semilattice_inf α] {a : α} {f : α → β} {l : filter β} : tendsto (fun (x : ↥(set.Iic a)) => f ↑x) at_bot l ↔ tendsto f at_bot l := sorry

theorem map_add_at_top_eq_nat (k : ℕ) : map (fun (a : ℕ) => a + k) at_top = at_top :=
  map_at_top_eq_of_gc (fun (a : ℕ) => a - k) k (fun (a b : ℕ) (h : a ≤ b) => add_le_add_right h k)
    (fun (a b : ℕ) (h : b ≥ k) => iff.symm (nat.le_sub_right_iff_add_le h))
    fun (a : ℕ) (h : a ≥ k) => eq.mpr (id (Eq._oldrec (Eq.refl (a ≤ a - k + k)) (nat.sub_add_cancel h))) (le_refl a)

theorem map_sub_at_top_eq_nat (k : ℕ) : map (fun (a : ℕ) => a - k) at_top = at_top :=
  map_at_top_eq_of_gc (fun (a : ℕ) => a + k) 0 (fun (a b : ℕ) (h : a ≤ b) => nat.sub_le_sub_right h k)
    (fun (a b : ℕ) (_x : b ≥ 0) => nat.sub_le_right_iff_le_add)
    fun (b : ℕ) (_x : b ≥ 0) => eq.mpr (id (Eq._oldrec (Eq.refl (b ≤ b + k - k)) (nat.add_sub_cancel b k))) (le_refl b)

theorem tendsto_add_at_top_nat (k : ℕ) : tendsto (fun (a : ℕ) => a + k) at_top at_top :=
  le_of_eq (map_add_at_top_eq_nat k)

theorem tendsto_sub_at_top_nat (k : ℕ) : tendsto (fun (a : ℕ) => a - k) at_top at_top :=
  le_of_eq (map_sub_at_top_eq_nat k)

theorem tendsto_add_at_top_iff_nat {α : Type u_3} {f : ℕ → α} {l : filter α} (k : ℕ) : tendsto (fun (n : ℕ) => f (n + k)) at_top l ↔ tendsto f at_top l := sorry

theorem map_div_at_top_eq_nat (k : ℕ) (hk : 0 < k) : map (fun (a : ℕ) => a / k) at_top = at_top := sorry

/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
above, then `tendsto u at_top at_top`. -/
theorem tendsto_at_top_at_top_of_monotone' {ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_above (set.range u)) : tendsto u at_top at_top := sorry

/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
below, then `tendsto u at_bot at_bot`. -/
theorem tendsto_at_bot_at_bot_of_monotone' {ι : Type u_1} {α : Type u_3} [preorder ι] [linear_order α] {u : ι → α} (h : monotone u) (H : ¬bdd_below (set.range u)) : tendsto u at_bot at_bot :=
  tendsto_at_top_at_top_of_monotone' (monotone.order_dual h) H

theorem unbounded_of_tendsto_at_top {α : Type u_3} {β : Type u_4} [Nonempty α] [semilattice_sup α] [preorder β] [no_top_order β] {f : α → β} (h : tendsto f at_top at_top) : ¬bdd_above (set.range f) := sorry

theorem unbounded_of_tendsto_at_bot {α : Type u_3} {β : Type u_4} [Nonempty α] [semilattice_sup α] [preorder β] [no_bot_order β] {f : α → β} (h : tendsto f at_top at_bot) : ¬bdd_below (set.range f) :=
  unbounded_of_tendsto_at_top h

theorem unbounded_of_tendsto_at_top' {α : Type u_3} {β : Type u_4} [Nonempty α] [semilattice_inf α] [preorder β] [no_top_order β] {f : α → β} (h : tendsto f at_bot at_top) : ¬bdd_above (set.range f) :=
  unbounded_of_tendsto_at_top h

theorem unbounded_of_tendsto_at_bot' {α : Type u_3} {β : Type u_4} [Nonempty α] [semilattice_inf α] [preorder β] [no_bot_order β] {f : α → β} (h : tendsto f at_bot at_bot) : ¬bdd_below (set.range f) :=
  unbounded_of_tendsto_at_top h

/-- If a monotone function `u : ι → α` tends to `at_top` along *some* non-trivial filter `l`, then
it tends to `at_top` along `at_top`. -/
theorem tendsto_at_top_of_monotone_of_filter {ι : Type u_1} {α : Type u_3} [preorder ι] [preorder α] {l : filter ι} {u : ι → α} (h : monotone u) [ne_bot l] (hu : tendsto u l at_top) : tendsto u at_top at_top :=
  monotone.tendsto_at_top_at_top h fun (b : α) => eventually.exists (tendsto.eventually hu (mem_at_top b))

/-- If a monotone function `u : ι → α` tends to `at_bot` along *some* non-trivial filter `l`, then
it tends to `at_bot` along `at_bot`. -/
theorem tendsto_at_bot_of_monotone_of_filter {ι : Type u_1} {α : Type u_3} [preorder ι] [preorder α] {l : filter ι} {u : ι → α} (h : monotone u) [ne_bot l] (hu : tendsto u l at_bot) : tendsto u at_bot at_bot :=
  tendsto_at_top_of_monotone_of_filter (monotone.order_dual h) hu

theorem tendsto_at_top_of_monotone_of_subseq {ι : Type u_1} {ι' : Type u_2} {α : Type u_3} [preorder ι] [preorder α] {u : ι → α} {φ : ι' → ι} (h : monotone u) {l : filter ι'} [ne_bot l] (H : tendsto (u ∘ φ) l at_top) : tendsto u at_top at_top :=
  tendsto_at_top_of_monotone_of_filter h (tendsto_map' H)

theorem tendsto_at_bot_of_monotone_of_subseq {ι : Type u_1} {ι' : Type u_2} {α : Type u_3} [preorder ι] [preorder α] {u : ι → α} {φ : ι' → ι} (h : monotone u) {l : filter ι'} [ne_bot l] (H : tendsto (u ∘ φ) l at_bot) : tendsto u at_bot at_bot :=
  tendsto_at_bot_of_monotone_of_filter h (tendsto_map' H)

/-- Let `f` and `g` be two maps to the same commutative monoid. This lemma gives a sufficient
condition for comparison of the filter `at_top.map (λ s, ∏ b in s, f b)` with
`at_top.map (λ s, ∏ b in s, g b)`. This is useful to compare the set of limit points of
`Π b in s, f b` as `s → at_top` with the similar set for `g`. -/
theorem map_at_top_finset_prod_le_of_prod_eq {α : Type u_3} {β : Type u_4} {γ : Type u_5} [comm_monoid α] {f : β → α} {g : γ → α} (h_eq : ∀ (u : finset γ),
  ∃ (v : finset β),
    ∀ (v' : finset β),
      v ⊆ v' → ∃ (u' : finset γ), u ⊆ u' ∧ (finset.prod u' fun (x : γ) => g x) = finset.prod v' fun (b : β) => f b) : map (fun (s : finset β) => finset.prod s fun (b : β) => f b) at_top ≤
  map (fun (s : finset γ) => finset.prod s fun (x : γ) => g x) at_top := sorry

theorem has_antimono_basis.tendsto {ι : Type u_1} {α : Type u_3} [semilattice_sup ι] [Nonempty ι] {l : filter α} {p : ι → Prop} {s : ι → set α} (hl : has_antimono_basis l p s) {φ : ι → α} (h : ∀ (i : ι), φ i ∈ s i) : tendsto φ at_top l := sorry

namespace is_countably_generated


/-- An abstract version of continuity of sequentially continuous functions on metric spaces:
if a filter `k` is countably generated then `tendsto f k l` iff for every sequence `u`
converging to `k`, `f ∘ u` tends to `l`. -/
theorem tendsto_iff_seq_tendsto {α : Type u_3} {β : Type u_4} {f : α → β} {k : filter α} {l : filter β} (hcb : is_countably_generated k) : tendsto f k l ↔ ∀ (x : ℕ → α), tendsto x at_top k → tendsto (f ∘ x) at_top l := sorry

theorem tendsto_of_seq_tendsto {α : Type u_3} {β : Type u_4} {f : α → β} {k : filter α} {l : filter β} (hcb : is_countably_generated k) : (∀ (x : ℕ → α), tendsto x at_top k → tendsto (f ∘ x) at_top l) → tendsto f k l :=
  iff.mpr (tendsto_iff_seq_tendsto hcb)

theorem subseq_tendsto {α : Type u_3} {f : filter α} (hf : is_countably_generated f) {u : ℕ → α} (hx : ne_bot (f ⊓ map u at_top)) : ∃ (θ : ℕ → ℕ), strict_mono θ ∧ tendsto (u ∘ θ) at_top f := sorry

end is_countably_generated


end filter


theorem exists_lt_mul_self {R : Type u_6} [linear_ordered_semiring R] (a : R) : ∃ (x : R), ∃ (H : x ≥ 0), a < x * x := sorry

theorem exists_le_mul_self {R : Type u_6} [linear_ordered_semiring R] (a : R) : ∃ (x : R), ∃ (H : x ≥ 0), a ≤ x * x := sorry

namespace order_iso


@[simp] theorem comap_at_top {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (e : α ≃o β) : filter.comap (⇑e) filter.at_top = filter.at_top := sorry

@[simp] theorem comap_at_bot {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (e : α ≃o β) : filter.comap (⇑e) filter.at_bot = filter.at_bot :=
  comap_at_top (order_iso.dual e)

@[simp] theorem map_at_top {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (e : α ≃o β) : filter.map (⇑e) filter.at_top = filter.at_top := sorry

@[simp] theorem map_at_bot {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (e : α ≃o β) : filter.map (⇑e) filter.at_bot = filter.at_bot :=
  map_at_top (order_iso.dual e)

theorem tendsto_at_top {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (e : α ≃o β) : filter.tendsto (⇑e) filter.at_top filter.at_top :=
  eq.le (map_at_top e)

theorem tendsto_at_bot {α : Type u_3} {β : Type u_4} [preorder α] [preorder β] (e : α ≃o β) : filter.tendsto (⇑e) filter.at_bot filter.at_bot :=
  eq.le (map_at_bot e)

@[simp] theorem tendsto_at_top_iff {α : Type u_3} {β : Type u_4} {γ : Type u_5} [preorder α] [preorder β] {l : filter γ} {f : γ → α} (e : α ≃o β) : filter.tendsto (fun (x : γ) => coe_fn e (f x)) l filter.at_top ↔ filter.tendsto f l filter.at_top := sorry

@[simp] theorem tendsto_at_bot_iff {α : Type u_3} {β : Type u_4} {γ : Type u_5} [preorder α] [preorder β] {l : filter γ} {f : γ → α} (e : α ≃o β) : filter.tendsto (fun (x : γ) => coe_fn e (f x)) l filter.at_bot ↔ filter.tendsto f l filter.at_bot :=
  tendsto_at_top_iff (order_iso.dual e)

end order_iso


/-- Let `g : γ → β` be an injective function and `f : β → α` be a function from the codomain of `g`
to a commutative monoid. Suppose that `f x = 1` outside of the range of `g`. Then the filters
`at_top.map (λ s, ∏ i in s, f (g i))` and `at_top.map (λ s, ∏ i in s, f i)` coincide.

The additive version of this lemma is used to prove the equality `∑' x, f (g x) = ∑' y, f y` under
the same assumptions.-/
theorem function.injective.map_at_top_finset_sum_eq {α : Type u_3} {β : Type u_4} {γ : Type u_5} [add_comm_monoid α] {g : γ → β} (hg : function.injective g) {f : β → α} (hf : ∀ (x : β), ¬x ∈ set.range g → f x = 0) : filter.map (fun (s : finset γ) => finset.sum s fun (i : γ) => f (g i)) filter.at_top =
  filter.map (fun (s : finset β) => finset.sum s fun (i : β) => f i) filter.at_top := sorry

