/-
Copyright (c) 2020 Joseph Myers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Myers, Yury Kudryashov.
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.linear_algebra.affine_space.midpoint
import Mathlib.topology.metric_space.isometry
import Mathlib.topology.instances.real_vector_space
import Mathlib.PostPort

universes u_1 u_2 l u_3 u_4 u_5 u_6 

namespace Mathlib

/-!
# Torsors of additive normed group actions.

This file defines torsors of additive normed group actions, with a
metric space structure.  The motivating case is Euclidean affine
spaces.

-/

/-- A `normed_add_torsor V P` is a torsor of an additive normed group
action by a `normed_group V` on points `P`. We bundle the metric space
structure and require the distance to be the same as results from the
norm (which in fact implies the distance yields a metric space, but
bundling just the distance and using an instance for the metric space
results in type class problems). -/
class normed_add_torsor (V : outParam (Type u_1)) (P : Type u_2) [outParam (normed_group V)] [metric_space P] 
extends add_torsor V P
where
  dist_eq_norm' : ‚àÄ (x y : P), dist x y = norm (x -·µ• y)

/-- The distance equals the norm of subtracting two points. In this
lemma, it is necessary to have `V` as an explicit argument; otherwise
`rw dist_eq_norm_vsub` sometimes doesn't work. -/
theorem dist_eq_norm_vsub (V : Type u_2) {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (x : P) (y : P) : dist x y = norm (x -·µ• y) :=
  normed_add_torsor.dist_eq_norm' x y

/-- A `normed_group` is a `normed_add_torsor` over itself. -/
protected instance normed_group.normed_add_torsor (V : Type u_2) [normed_group V] : normed_add_torsor V V :=
  normed_add_torsor.mk dist_eq_norm

@[simp] theorem dist_vadd_cancel_left {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (v : V) (x : P) (y : P) : dist (v +·µ• x) (v +·µ• y) = dist x y := sorry

@[simp] theorem dist_vadd_cancel_right {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (v‚ÇÅ : V) (v‚ÇÇ : V) (x : P) : dist (v‚ÇÅ +·µ• x) (v‚ÇÇ +·µ• x) = dist v‚ÇÅ v‚ÇÇ := sorry

@[simp] theorem dist_vadd_left {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (v : V) (x : P) : dist (v +·µ• x) x = norm v := sorry

@[simp] theorem dist_vadd_right {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (v : V) (x : P) : dist x (v +·µ• x) = norm v :=
  eq.mpr (id (Eq._oldrec (Eq.refl (dist x (v +·µ• x) = norm v)) (dist_comm x (v +·µ• x))))
    (eq.mpr (id (Eq._oldrec (Eq.refl (dist (v +·µ• x) x = norm v)) (dist_vadd_left v x))) (Eq.refl (norm v)))

@[simp] theorem dist_vsub_cancel_left {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (x : P) (y : P) (z : P) : dist (x -·µ• y) (x -·µ• z) = dist y z := sorry

@[simp] theorem dist_vsub_cancel_right {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (x : P) (y : P) (z : P) : dist (x -·µ• z) (y -·µ• z) = dist x y :=
  eq.mpr (id (Eq._oldrec (Eq.refl (dist (x -·µ• z) (y -·µ• z) = dist x y)) (dist_eq_norm (x -·µ• z) (y -·µ• z))))
    (eq.mpr (id (Eq._oldrec (Eq.refl (norm (x -·µ• z - (y -·µ• z)) = dist x y)) (vsub_sub_vsub_cancel_right x y z)))
      (eq.mpr (id (Eq._oldrec (Eq.refl (norm (x -·µ• y) = dist x y)) (dist_eq_norm_vsub V x y))) (Eq.refl (norm (x -·µ• y)))))

theorem dist_vadd_vadd_le {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (v : V) (v' : V) (p : P) (p' : P) : dist (v +·µ• p) (v' +·µ• p') ‚â§ dist v v' + dist p p' := sorry

theorem dist_vsub_vsub_le {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (p‚ÇÅ : P) (p‚ÇÇ : P) (p‚ÇÉ : P) (p‚ÇÑ : P) : dist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ dist p‚ÇÅ p‚ÇÉ + dist p‚ÇÇ p‚ÇÑ := sorry

theorem nndist_vadd_vadd_le {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (v : V) (v' : V) (p : P) (p' : P) : nndist (v +·µ• p) (v' +·µ• p') ‚â§ nndist v v' + nndist p p' := sorry

theorem nndist_vsub_vsub_le {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (p‚ÇÅ : P) (p‚ÇÇ : P) (p‚ÇÉ : P) (p‚ÇÑ : P) : nndist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ nndist p‚ÇÅ p‚ÇÉ + nndist p‚ÇÇ p‚ÇÑ := sorry

theorem edist_vadd_vadd_le {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (v : V) (v' : V) (p : P) (p' : P) : edist (v +·µ• p) (v' +·µ• p') ‚â§ edist v v' + edist p p' := sorry

theorem edist_vsub_vsub_le {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (p‚ÇÅ : P) (p‚ÇÇ : P) (p‚ÇÉ : P) (p‚ÇÑ : P) : edist (p‚ÇÅ -·µ• p‚ÇÇ) (p‚ÇÉ -·µ• p‚ÇÑ) ‚â§ edist p‚ÇÅ p‚ÇÉ + edist p‚ÇÇ p‚ÇÑ := sorry

/-- The distance defines a metric space structure on the torsor. This
is not an instance because it depends on `V` to define a `metric_space
P`. -/
def metric_space_of_normed_group_of_add_torsor (V : Type u_1) (P : Type u_2) [normed_group V] [add_torsor V P] : metric_space P :=
  metric_space.mk sorry sorry sorry sorry (fun (x y : P) => ennreal.of_real ((fun (x y : P) => norm (x -·µ• y)) x y))
    (uniform_space_of_dist (fun (x y : P) => norm (x -·µ• y)) sorry sorry sorry)

namespace isometric


/-- The map `v ‚Ü¶ v +·µ• p` as an isometric equivalence between `V` and `P`. -/
def vadd_const {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (p : P) : V ‚âÉ·µ¢ P :=
  mk (equiv.vadd_const p) sorry

@[simp] theorem coe_vadd_const {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (p : P) : ‚áë(vadd_const p) = fun (v : V) => v +·µ• p :=
  rfl

@[simp] theorem coe_vadd_const_symm {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (p : P) : ‚áë(isometric.symm (vadd_const p)) = fun (p' : P) => p' -·µ• p :=
  rfl

@[simp] theorem vadd_const_to_equiv {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (p : P) : to_equiv (vadd_const p) = equiv.vadd_const p :=
  rfl

/-- `p' ‚Ü¶ p -·µ• p'` as an equivalence. -/
def const_vsub {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (p : P) : P ‚âÉ·µ¢ V :=
  mk (equiv.const_vsub p) sorry

@[simp] theorem coe_const_vsub {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (p : P) : ‚áë(const_vsub p) = has_vsub.vsub p :=
  rfl

@[simp] theorem coe_const_vsub_symm {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (p : P) : ‚áë(isometric.symm (const_vsub p)) = fun (v : V) => -v +·µ• p :=
  rfl

/-- The map `p ‚Ü¶ v +·µ• p` as an isometric automorphism of `P`. -/
def const_vadd {V : Type u_2} (P : Type u_3) [normed_group V] [metric_space P] [normed_add_torsor V P] (v : V) : P ‚âÉ·µ¢ P :=
  mk (equiv.const_vadd P v) sorry

@[simp] theorem coe_const_vadd {V : Type u_2} (P : Type u_3) [normed_group V] [metric_space P] [normed_add_torsor V P] (v : V) : ‚áë(const_vadd P v) = has_vadd.vadd v :=
  rfl

@[simp] theorem const_vadd_zero (V : Type u_2) (P : Type u_3) [normed_group V] [metric_space P] [normed_add_torsor V P] : const_vadd P 0 = isometric.refl P :=
  to_equiv_inj (equiv.const_vadd_zero V P)

/-- Point reflection in `x` as an `isometric` homeomorphism. -/
def point_reflection {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (x : P) : P ‚âÉ·µ¢ P :=
  isometric.trans (const_vsub x) (vadd_const x)

theorem point_reflection_apply {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (x : P) (y : P) : coe_fn (point_reflection x) y = x -·µ• y +·µ• x :=
  rfl

@[simp] theorem point_reflection_to_equiv {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (x : P) : to_equiv (point_reflection x) = equiv.point_reflection x :=
  rfl

@[simp] theorem point_reflection_self {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (x : P) : coe_fn (point_reflection x) x = x :=
  equiv.point_reflection_self x

theorem point_reflection_involutive {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (x : P) : function.involutive ‚áë(point_reflection x) :=
  equiv.point_reflection_involutive x

@[simp] theorem point_reflection_symm {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (x : P) : isometric.symm (point_reflection x) = point_reflection x :=
  to_equiv_inj (equiv.point_reflection_symm x)

@[simp] theorem dist_point_reflection_fixed {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (x : P) (y : P) : dist (coe_fn (point_reflection x) y) x = dist y x := sorry

theorem dist_point_reflection_self' {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (x : P) (y : P) : dist (coe_fn (point_reflection x) y) y = norm (bit0 (x -·µ• y)) := sorry

theorem dist_point_reflection_self {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (ùïú : Type u_1) [normed_field ùïú] [normed_space ùïú V] (x : P) (y : P) : dist (coe_fn (point_reflection x) y) y = norm (bit0 1) * dist x y := sorry

theorem point_reflection_fixed_iff {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] (ùïú : Type u_1) [normed_field ùïú] [normed_space ùïú V] [invertible (bit0 1)] {x : P} {y : P} : coe_fn (point_reflection x) y = y ‚Üî y = x :=
  affine_equiv.point_reflection_fixed_iff_of_module ùïú

theorem dist_point_reflection_self_real {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] [normed_space ‚Ñù V] (x : P) (y : P) : dist (coe_fn (point_reflection x) y) y = bit0 1 * dist x y := sorry

@[simp] theorem point_reflection_midpoint_left {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] [normed_space ‚Ñù V] (x : P) (y : P) : coe_fn (point_reflection (midpoint ‚Ñù x y)) x = y :=
  affine_equiv.point_reflection_midpoint_left x y

@[simp] theorem point_reflection_midpoint_right {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] [normed_space ‚Ñù V] (x : P) (y : P) : coe_fn (point_reflection (midpoint ‚Ñù x y)) y = x :=
  affine_equiv.point_reflection_midpoint_right x y

end isometric


theorem lipschitz_with.vadd {Œ± : Type u_1} {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] [emetric_space Œ±] {f : Œ± ‚Üí V} {g : Œ± ‚Üí P} {Kf : nnreal} {Kg : nnreal} (hf : lipschitz_with Kf f) (hg : lipschitz_with Kg g) : lipschitz_with (Kf + Kg) (f +·µ• g) :=
  fun (x y : Œ±) =>
    trans_rel_left LessEq (le_trans (edist_vadd_vadd_le (f x) (f y) (g x) (g y)) (add_le_add (hf x y) (hg x y)))
      (Eq.symm (add_mul (‚ÜëKf) (‚ÜëKg) (edist x y)))

theorem lipschitz_with.vsub {Œ± : Type u_1} {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] [emetric_space Œ±] {f : Œ± ‚Üí P} {g : Œ± ‚Üí P} {Kf : nnreal} {Kg : nnreal} (hf : lipschitz_with Kf f) (hg : lipschitz_with Kg g) : lipschitz_with (Kf + Kg) (f -·µ• g) :=
  fun (x y : Œ±) =>
    trans_rel_left LessEq (le_trans (edist_vsub_vsub_le (f x) (g x) (f y) (g y)) (add_le_add (hf x y) (hg x y)))
      (Eq.symm (add_mul (‚ÜëKf) (‚ÜëKg) (edist x y)))

theorem uniform_continuous_vadd {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] : uniform_continuous fun (x : V √ó P) => prod.fst x +·µ• prod.snd x :=
  lipschitz_with.uniform_continuous (lipschitz_with.vadd lipschitz_with.prod_fst lipschitz_with.prod_snd)

theorem uniform_continuous_vsub {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] : uniform_continuous fun (x : P √ó P) => prod.fst x -·µ• prod.snd x :=
  lipschitz_with.uniform_continuous (lipschitz_with.vsub lipschitz_with.prod_fst lipschitz_with.prod_snd)

theorem continuous_vadd {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] : continuous fun (x : V √ó P) => prod.fst x +·µ• prod.snd x :=
  uniform_continuous.continuous uniform_continuous_vadd

theorem continuous_vsub {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] : continuous fun (x : P √ó P) => prod.fst x -·µ• prod.snd x :=
  uniform_continuous.continuous uniform_continuous_vsub

theorem filter.tendsto.vadd {Œ± : Type u_1} {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] {l : filter Œ±} {f : Œ± ‚Üí V} {g : Œ± ‚Üí P} {v : V} {p : P} (hf : filter.tendsto f l (nhds v)) (hg : filter.tendsto g l (nhds p)) : filter.tendsto (f +·µ• g) l (nhds (v +·µ• p)) :=
  filter.tendsto.comp (continuous.tendsto continuous_vadd (v, p)) (filter.tendsto.prod_mk_nhds hf hg)

theorem filter.tendsto.vsub {Œ± : Type u_1} {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] {l : filter Œ±} {f : Œ± ‚Üí P} {g : Œ± ‚Üí P} {x : P} {y : P} (hf : filter.tendsto f l (nhds x)) (hg : filter.tendsto g l (nhds y)) : filter.tendsto (f -·µ• g) l (nhds (x -·µ• y)) :=
  filter.tendsto.comp (continuous.tendsto continuous_vsub (x, y)) (filter.tendsto.prod_mk_nhds hf hg)

theorem continuous.vadd {Œ± : Type u_1} {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] [topological_space Œ±] {f : Œ± ‚Üí V} {g : Œ± ‚Üí P} (hf : continuous f) (hg : continuous g) : continuous (f +·µ• g) :=
  continuous.comp continuous_vadd (continuous.prod_mk hf hg)

theorem continuous.vsub {Œ± : Type u_1} {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] [topological_space Œ±] {f : Œ± ‚Üí P} {g : Œ± ‚Üí P} (hf : continuous f) (hg : continuous g) : continuous (f -·µ• g) :=
  continuous.comp continuous_vsub (continuous.prod_mk hf hg)

theorem continuous_at.vadd {Œ± : Type u_1} {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] [topological_space Œ±] {f : Œ± ‚Üí V} {g : Œ± ‚Üí P} {x : Œ±} (hf : continuous_at f x) (hg : continuous_at g x) : continuous_at (f +·µ• g) x :=
  filter.tendsto.vadd hf hg

theorem continuous_at.vsub {Œ± : Type u_1} {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] [topological_space Œ±] {f : Œ± ‚Üí P} {g : Œ± ‚Üí P} {x : Œ±} (hf : continuous_at f x) (hg : continuous_at g x) : continuous_at (f -·µ• g) x :=
  filter.tendsto.vsub hf hg

theorem continuous_within_at.vadd {Œ± : Type u_1} {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] [topological_space Œ±] {f : Œ± ‚Üí V} {g : Œ± ‚Üí P} {x : Œ±} {s : set Œ±} (hf : continuous_within_at f s x) (hg : continuous_within_at g s x) : continuous_within_at (f +·µ• g) s x :=
  filter.tendsto.vadd hf hg

theorem continuous_within_at.vsub {Œ± : Type u_1} {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] [topological_space Œ±] {f : Œ± ‚Üí P} {g : Œ± ‚Üí P} {x : Œ±} {s : set Œ±} (hf : continuous_within_at f s x) (hg : continuous_within_at g s x) : continuous_within_at (f -·µ• g) s x :=
  filter.tendsto.vsub hf hg

/-- The map `g` from `V1` to `V2` corresponding to a map `f` from `P1`
to `P2`, at a base point `p`, is an isometry if `f` is one. -/
theorem isometry.vadd_vsub {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] {V' : Type u_4} {P' : Type u_5} [normed_group V'] [metric_space P'] [normed_add_torsor V' P'] {f : P ‚Üí P'} (hf : isometry f) {p : P} {g : V ‚Üí V'} (hg : ‚àÄ (v : V), g v = f (v +·µ• p) -·µ• f p) : isometry g := sorry

/-- If `f` is an affine map, then its linear part is continuous iff `f` is continuous. -/
theorem affine_map.continuous_linear_iff {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] {V' : Type u_4} {P' : Type u_5} [normed_group V'] [metric_space P'] [normed_add_torsor V' P'] {ùïú : Type u_6} [normed_field ùïú] [normed_space ùïú V] [normed_space ùïú V'] {f : affine_map ùïú P P'} : continuous ‚áë(affine_map.linear f) ‚Üî continuous ‚áëf := sorry

@[simp] theorem dist_center_homothety {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] {ùïú : Type u_6} [normed_field ùïú] [normed_space ùïú V] (p‚ÇÅ : P) (p‚ÇÇ : P) (c : ùïú) : dist p‚ÇÅ (coe_fn (affine_map.homothety p‚ÇÅ c) p‚ÇÇ) = norm c * dist p‚ÇÅ p‚ÇÇ := sorry

@[simp] theorem dist_homothety_center {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] {ùïú : Type u_6} [normed_field ùïú] [normed_space ùïú V] (p‚ÇÅ : P) (p‚ÇÇ : P) (c : ùïú) : dist (coe_fn (affine_map.homothety p‚ÇÅ c) p‚ÇÇ) p‚ÇÅ = norm c * dist p‚ÇÅ p‚ÇÇ := sorry

@[simp] theorem dist_homothety_self {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] {ùïú : Type u_6} [normed_field ùïú] [normed_space ùïú V] (p‚ÇÅ : P) (p‚ÇÇ : P) (c : ùïú) : dist (coe_fn (affine_map.homothety p‚ÇÅ c) p‚ÇÇ) p‚ÇÇ = norm (1 - c) * dist p‚ÇÅ p‚ÇÇ := sorry

@[simp] theorem dist_self_homothety {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] {ùïú : Type u_6} [normed_field ùïú] [normed_space ùïú V] (p‚ÇÅ : P) (p‚ÇÇ : P) (c : ùïú) : dist p‚ÇÇ (coe_fn (affine_map.homothety p‚ÇÅ c) p‚ÇÇ) = norm (1 - c) * dist p‚ÇÅ p‚ÇÇ := sorry

@[simp] theorem dist_left_midpoint {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] {ùïú : Type u_6} [normed_field ùïú] [normed_space ùïú V] [invertible (bit0 1)] (p‚ÇÅ : P) (p‚ÇÇ : P) : dist p‚ÇÅ (midpoint ùïú p‚ÇÅ p‚ÇÇ) = norm (bit0 1)‚Åª¬π * dist p‚ÇÅ p‚ÇÇ := sorry

@[simp] theorem dist_midpoint_left {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] {ùïú : Type u_6} [normed_field ùïú] [normed_space ùïú V] [invertible (bit0 1)] (p‚ÇÅ : P) (p‚ÇÇ : P) : dist (midpoint ùïú p‚ÇÅ p‚ÇÇ) p‚ÇÅ = norm (bit0 1)‚Åª¬π * dist p‚ÇÅ p‚ÇÇ := sorry

@[simp] theorem dist_midpoint_right {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] {ùïú : Type u_6} [normed_field ùïú] [normed_space ùïú V] [invertible (bit0 1)] (p‚ÇÅ : P) (p‚ÇÇ : P) : dist (midpoint ùïú p‚ÇÅ p‚ÇÇ) p‚ÇÇ = norm (bit0 1)‚Åª¬π * dist p‚ÇÅ p‚ÇÇ := sorry

@[simp] theorem dist_right_midpoint {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] {ùïú : Type u_6} [normed_field ùïú] [normed_space ùïú V] [invertible (bit0 1)] (p‚ÇÅ : P) (p‚ÇÇ : P) : dist p‚ÇÇ (midpoint ùïú p‚ÇÅ p‚ÇÇ) = norm (bit0 1)‚Åª¬π * dist p‚ÇÅ p‚ÇÇ := sorry

/-- A continuous map between two normed affine spaces is an affine map provided that
it sends midpoints to midpoints. -/
def affine_map.of_map_midpoint {V : Type u_2} {P : Type u_3} [normed_group V] [metric_space P] [normed_add_torsor V P] {V' : Type u_4} {P' : Type u_5} [normed_group V'] [metric_space P'] [normed_add_torsor V' P'] [normed_space ‚Ñù V] [normed_space ‚Ñù V'] (f : P ‚Üí P') (h : ‚àÄ (x y : P), f (midpoint ‚Ñù x y) = midpoint ‚Ñù (f x) (f y)) (hfc : continuous f) : affine_map ‚Ñù P P' :=
  affine_map.mk' f
    (‚Üë(add_monoid_hom.to_real_linear_map
        (add_monoid_hom.of_map_midpoint ‚Ñù ‚Ñù
          (‚áë(affine_equiv.symm (affine_equiv.vadd_const ‚Ñù (f (classical.arbitrary P)))) ‚àò
            f ‚àò ‚áë(affine_equiv.vadd_const ‚Ñù (classical.arbitrary P)))
          sorry sorry)
        sorry))
    (classical.arbitrary P) sorry

