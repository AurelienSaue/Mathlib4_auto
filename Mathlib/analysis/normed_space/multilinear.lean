/-
Copyright (c) 2020 S√©bastien Gou√´zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: S√©bastien Gou√´zel
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.analysis.normed_space.operator_norm
import Mathlib.topology.algebra.multilinear
import Mathlib.PostPort

universes u v w‚ÇÅ w‚ÇÇ wG u_1 w 

namespace Mathlib

/-!
# Operator norm on the space of continuous multilinear maps

When `f` is a continuous multilinear map in finitely many variables, we define its norm `‚à•f‚à•` as the
smallest number such that `‚à•f m‚à• ‚â§ ‚à•f‚à• * ‚àè i, ‚à•m i‚à•` for all `m`.

We show that it is indeed a norm, and prove its basic properties.

## Main results

Let `f` be a multilinear map in finitely many variables.
* `exists_bound_of_continuous` asserts that, if `f` is continuous, then there exists `C > 0`
  with `‚à•f m‚à• ‚â§ C * ‚àè i, ‚à•m i‚à•` for all `m`.
* `continuous_of_bound`, conversely, asserts that this bound implies continuity.
* `mk_continuous` constructs the associated continuous multilinear map.

Let `f` be a continuous multilinear map in finitely many variables.
* `‚à•f‚à•` is its norm, i.e., the smallest number such that `‚à•f m‚à• ‚â§ ‚à•f‚à• * ‚àè i, ‚à•m i‚à•` for
  all `m`.
* `le_op_norm f m` asserts the fundamental inequality `‚à•f m‚à• ‚â§ ‚à•f‚à• * ‚àè i, ‚à•m i‚à•`.
* `norm_image_sub_le f m‚ÇÅ m‚ÇÇ` gives a control of the difference `f m‚ÇÅ - f m‚ÇÇ` in terms of
  `‚à•f‚à•` and `‚à•m‚ÇÅ - m‚ÇÇ‚à•`.

We also register isomorphisms corresponding to currying or uncurrying variables, transforming a
continuous multilinear function `f` in `n+1` variables into a continuous linear function taking
values in continuous multilinear functions in `n` variables, and also into a continuous multilinear
function in `n` variables taking values in continuous linear functions. These operations are called
`f.curry_left` and `f.curry_right` respectively (with inverses `f.uncurry_left` and
`f.uncurry_right`). They induce continuous linear equivalences between spaces of
continuous multilinear functions in `n+1` variables and spaces of continuous linear functions into
continuous multilinear functions in `n` variables (resp. continuous multilinear functions in `n`
variables taking values in continuous linear functions), called respectively
`continuous_multilinear_curry_left_equiv` and `continuous_multilinear_curry_right_equiv`.

## Implementation notes

We mostly follow the API (and the proofs) of `operator_norm.lean`, with the additional complexity
that we should deal with multilinear maps in several variables. The currying/uncurrying
constructions are based on those in `multilinear.lean`.

From the mathematical point of view, all the results follow from the results on operator norm in
one variable, by applying them to one variable after the other through currying. However, this
is only well defined when there is an order on the variables (for instance on `fin n`) although
the final result is independent of the order. While everything could be done following this
approach, it turns out that direct proofs are easier and more efficient.
-/

/-!
### Continuity properties of multilinear maps

We relate continuity of multilinear maps to the inequality `‚à•f m‚à• ‚â§ C * ‚àè i, ‚à•m i‚à•`, in
both directions. Along the way, we prove useful bounds on the difference `‚à•f m‚ÇÅ - f m‚ÇÇ‚à•`.
-/

namespace multilinear_map


/-- If a multilinear map in finitely many variables on normed spaces satisfies the inequality
`‚à•f m‚à• ‚â§ C * ‚àè i, ‚à•m i‚à•` on a shell `Œµ i / ‚à•c i‚à• < ‚à•m i‚à• < Œµ i` for some positive numbers `Œµ i`
and elements `c i : ùïú`, `1 < ‚à•c i‚à•`, then it satisfies this inequality for all `m`. -/
theorem bound_of_shell {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : multilinear_map ùïú E‚ÇÅ E‚ÇÇ) {Œµ : Œπ ‚Üí ‚Ñù} {C : ‚Ñù} (hŒµ : ‚àÄ (i : Œπ), 0 < Œµ i) {c : Œπ ‚Üí ùïú} (hc : ‚àÄ (i : Œπ), 1 < norm (c i)) (hf : ‚àÄ (m : (i : Œπ) ‚Üí E‚ÇÅ i),
  (‚àÄ (i : Œπ), Œµ i / norm (c i) ‚â§ norm (m i)) ‚Üí
    (‚àÄ (i : Œπ), norm (m i) < Œµ i) ‚Üí norm (coe_fn f m) ‚â§ C * finset.prod finset.univ fun (i : Œπ) => norm (m i)) (m : (i : Œπ) ‚Üí E‚ÇÅ i) : norm (coe_fn f m) ‚â§ C * finset.prod finset.univ fun (i : Œπ) => norm (m i) := sorry

/-- If a multilinear map in finitely many variables on normed spaces is continuous, then it
satisfies the inequality `‚à•f m‚à• ‚â§ C * ‚àè i, ‚à•m i‚à•`, for some `C` which can be chosen to be
positive. -/
theorem exists_bound_of_continuous {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : multilinear_map ùïú E‚ÇÅ E‚ÇÇ) (hf : continuous ‚áëf) : ‚àÉ (C : ‚Ñù), 0 < C ‚àß ‚àÄ (m : (i : Œπ) ‚Üí E‚ÇÅ i), norm (coe_fn f m) ‚â§ C * finset.prod finset.univ fun (i : Œπ) => norm (m i) := sorry

/-- If `f` satisfies a boundedness property around `0`, one can deduce a bound on `f m‚ÇÅ - f m‚ÇÇ`
using the multilinearity. Here, we give a precise but hard to use version. See
`norm_image_sub_le_of_bound` for a less precise but more usable version. The bound reads
`‚à•f m - f m'‚à• ‚â§
  C * ‚à•m 1 - m' 1‚à• * max ‚à•m 2‚à• ‚à•m' 2‚à• * max ‚à•m 3‚à• ‚à•m' 3‚à• * ... * max ‚à•m n‚à• ‚à•m' n‚à• + ...`,
where the other terms in the sum are the same products where `1` is replaced by any `i`. -/
theorem norm_image_sub_le_of_bound' {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : multilinear_map ùïú E‚ÇÅ E‚ÇÇ) {C : ‚Ñù} (hC : 0 ‚â§ C) (H : ‚àÄ (m : (i : Œπ) ‚Üí E‚ÇÅ i), norm (coe_fn f m) ‚â§ C * finset.prod finset.univ fun (i : Œπ) => norm (m i)) (m‚ÇÅ : (i : Œπ) ‚Üí E‚ÇÅ i) (m‚ÇÇ : (i : Œπ) ‚Üí E‚ÇÅ i) : norm (coe_fn f m‚ÇÅ - coe_fn f m‚ÇÇ) ‚â§
  C *
    finset.sum finset.univ
      fun (i : Œπ) =>
        finset.prod finset.univ fun (j : Œπ) => ite (j = i) (norm (m‚ÇÅ i - m‚ÇÇ i)) (max (norm (m‚ÇÅ j)) (norm (m‚ÇÇ j))) := sorry

/-- If `f` satisfies a boundedness property around `0`, one can deduce a bound on `f m‚ÇÅ - f m‚ÇÇ`
using the multilinearity. Here, we give a usable but not very precise version. See
`norm_image_sub_le_of_bound'` for a more precise but less usable version. The bound is
`‚à•f m - f m'‚à• ‚â§ C * card Œπ * ‚à•m - m'‚à• * (max ‚à•m‚à• ‚à•m'‚à•) ^ (card Œπ - 1)`. -/
theorem norm_image_sub_le_of_bound {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : multilinear_map ùïú E‚ÇÅ E‚ÇÇ) {C : ‚Ñù} (hC : 0 ‚â§ C) (H : ‚àÄ (m : (i : Œπ) ‚Üí E‚ÇÅ i), norm (coe_fn f m) ‚â§ C * finset.prod finset.univ fun (i : Œπ) => norm (m i)) (m‚ÇÅ : (i : Œπ) ‚Üí E‚ÇÅ i) (m‚ÇÇ : (i : Œπ) ‚Üí E‚ÇÅ i) : norm (coe_fn f m‚ÇÅ - coe_fn f m‚ÇÇ) ‚â§
  C * ‚Üë(fintype.card Œπ) * max (norm m‚ÇÅ) (norm m‚ÇÇ) ^ (fintype.card Œπ - 1) * norm (m‚ÇÅ - m‚ÇÇ) := sorry

/-- If a multilinear map satisfies an inequality `‚à•f m‚à• ‚â§ C * ‚àè i, ‚à•m i‚à•`, then it is
continuous. -/
theorem continuous_of_bound {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : multilinear_map ùïú E‚ÇÅ E‚ÇÇ) (C : ‚Ñù) (H : ‚àÄ (m : (i : Œπ) ‚Üí E‚ÇÅ i), norm (coe_fn f m) ‚â§ C * finset.prod finset.univ fun (i : Œπ) => norm (m i)) : continuous ‚áëf := sorry

/-- Constructing a continuous multilinear map from a multilinear map satisfying a boundedness
condition. -/
def mk_continuous {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : multilinear_map ùïú E‚ÇÅ E‚ÇÇ) (C : ‚Ñù) (H : ‚àÄ (m : (i : Œπ) ‚Üí E‚ÇÅ i), norm (coe_fn f m) ‚â§ C * finset.prod finset.univ fun (i : Œπ) => norm (m i)) : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ :=
  continuous_multilinear_map.mk (mk (to_fun f) sorry sorry) sorry

@[simp] theorem coe_mk_continuous {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : multilinear_map ùïú E‚ÇÅ E‚ÇÇ) (C : ‚Ñù) (H : ‚àÄ (m : (i : Œπ) ‚Üí E‚ÇÅ i), norm (coe_fn f m) ‚â§ C * finset.prod finset.univ fun (i : Œπ) => norm (m i)) : ‚áë(mk_continuous f C H) = ‚áëf :=
  rfl

/-- Given a multilinear map in `n` variables, if one restricts it to `k` variables putting `z` on
the other coordinates, then the resulting restricted function satisfies an inequality
`‚à•f.restr v‚à• ‚â§ C * ‚à•z‚à•^(n-k) * Œ† ‚à•v i‚à•` if the original function satisfies `‚à•f v‚à• ‚â§ C * Œ† ‚à•v i‚à•`. -/
theorem restr_norm_le {ùïú : Type u} {G : Type wG} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] {k : ‚Ñï} {n : ‚Ñï} (f : multilinear_map ùïú (fun (i : fin n) => G) E‚ÇÇ) (s : finset (fin n)) (hk : finset.card s = k) (z : G) {C : ‚Ñù} (H : ‚àÄ (m : (i : fin n) ‚Üí (fun (i : fin n) => G) i),
  norm (coe_fn f m) ‚â§ C * finset.prod finset.univ fun (i : fin n) => norm (m i)) (v : fin k ‚Üí G) : norm (coe_fn (restr f s hk z) v) ‚â§ C * norm z ^ (n - k) * finset.prod finset.univ fun (i : fin k) => norm (v i) := sorry

end multilinear_map


/-!
### Continuous multilinear maps

We define the norm `‚à•f‚à•` of a continuous multilinear map `f` in finitely many variables as the
smallest number such that `‚à•f m‚à• ‚â§ ‚à•f‚à• * ‚àè i, ‚à•m i‚à•` for all `m`. We show that this
defines a normed space structure on `continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ`.
-/

namespace continuous_multilinear_map


theorem bound {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) : ‚àÉ (C : ‚Ñù), 0 < C ‚àß ‚àÄ (m : (i : Œπ) ‚Üí E‚ÇÅ i), norm (coe_fn f m) ‚â§ C * finset.prod finset.univ fun (i : Œπ) => norm (m i) :=
  multilinear_map.exists_bound_of_continuous (to_multilinear_map f) (cont f)

/-- The operator norm of a continuous multilinear map is the inf of all its bounds. -/
def op_norm {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) : ‚Ñù :=
  Inf
    (set_of
      fun (c : ‚Ñù) =>
        0 ‚â§ c ‚àß ‚àÄ (m : (i : Œπ) ‚Üí E‚ÇÅ i), norm (coe_fn f m) ‚â§ c * finset.prod finset.univ fun (i : Œπ) => norm (m i))

protected instance has_op_norm {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] : has_norm (continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) :=
  has_norm.mk op_norm

theorem norm_def {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) : norm f =
  Inf
    (set_of
      fun (c : ‚Ñù) =>
        0 ‚â§ c ‚àß ‚àÄ (m : (i : Œπ) ‚Üí E‚ÇÅ i), norm (coe_fn f m) ‚â§ c * finset.prod finset.univ fun (i : Œπ) => norm (m i)) :=
  rfl

-- So that invocations of `real.Inf_le` make sense: we show that the set of

-- bounds is nonempty and bounded below.

theorem bounds_nonempty {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] {f : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ} : ‚àÉ (c : ‚Ñù),
  c ‚àà
    set_of
      fun (c : ‚Ñù) =>
        0 ‚â§ c ‚àß ‚àÄ (m : (i : Œπ) ‚Üí E‚ÇÅ i), norm (coe_fn f m) ‚â§ c * finset.prod finset.univ fun (i : Œπ) => norm (m i) := sorry

theorem bounds_bdd_below {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] {f : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ} : bdd_below
  (set_of
    fun (c : ‚Ñù) =>
      0 ‚â§ c ‚àß ‚àÄ (m : (i : Œπ) ‚Üí E‚ÇÅ i), norm (coe_fn f m) ‚â§ c * finset.prod finset.univ fun (i : Œπ) => norm (m i)) := sorry

theorem op_norm_nonneg {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) : 0 ‚â§ norm f := sorry

/-- The fundamental property of the operator norm of a continuous multilinear map:
`‚à•f m‚à•` is bounded by `‚à•f‚à•` times the product of the `‚à•m i‚à•`. -/
theorem le_op_norm {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) (m : (i : Œπ) ‚Üí E‚ÇÅ i) : norm (coe_fn f m) ‚â§ norm f * finset.prod finset.univ fun (i : Œπ) => norm (m i) := sorry

theorem ratio_le_op_norm {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) (m : (i : Œπ) ‚Üí E‚ÇÅ i) : (norm (coe_fn f m) / finset.prod finset.univ fun (i : Œπ) => norm (m i)) ‚â§ norm f := sorry

/-- The image of the unit ball under a continuous multilinear map is bounded. -/
theorem unit_le_op_norm {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) (m : (i : Œπ) ‚Üí E‚ÇÅ i) (h : norm m ‚â§ 1) : norm (coe_fn f m) ‚â§ norm f := sorry

/-- If one controls the norm of every `f x`, then one controls the norm of `f`. -/
theorem op_norm_le_bound {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) {M : ‚Ñù} (hMp : 0 ‚â§ M) (hM : ‚àÄ (m : (i : Œπ) ‚Üí E‚ÇÅ i), norm (coe_fn f m) ‚â§ M * finset.prod finset.univ fun (i : Œπ) => norm (m i)) : norm f ‚â§ M := sorry

/-- The operator norm satisfies the triangle inequality. -/
theorem op_norm_add_le {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) (g : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) : norm (f + g) ‚â§ norm f + norm g := sorry

/-- A continuous linear map is zero iff its norm vanishes. -/
theorem op_norm_zero_iff {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) : norm f = 0 ‚Üî f = 0 := sorry

theorem op_norm_smul_le {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) {ùïú' : Type u_1} [nondiscrete_normed_field ùïú'] [normed_algebra ùïú' ùïú] [normed_space ùïú' E‚ÇÇ] [is_scalar_tower ùïú' ùïú E‚ÇÇ] (c : ùïú') : norm (c ‚Ä¢ f) ‚â§ norm c * norm f := sorry

theorem op_norm_neg {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) : norm (-f) = norm f := sorry

/-- Continuous multilinear maps themselves form a normed space with respect to
    the operator norm. -/
protected instance to_normed_group {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] : normed_group (continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) :=
  normed_group.of_core (continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) sorry

protected instance to_normed_space {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] {ùïú' : Type u_1} [nondiscrete_normed_field ùïú'] [normed_algebra ùïú' ùïú] [normed_space ùïú' E‚ÇÇ] [is_scalar_tower ùïú' ùïú E‚ÇÇ] : normed_space ùïú' (continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) :=
  normed_space.mk sorry

@[simp] theorem norm_restrict_scalars {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) {ùïú' : Type u_1} [nondiscrete_normed_field ùïú'] [normed_algebra ùïú' ùïú] [normed_space ùïú' E‚ÇÇ] [is_scalar_tower ùïú' ùïú E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú' (E‚ÇÅ i)] [‚àÄ (i : Œπ), is_scalar_tower ùïú' ùïú (E‚ÇÅ i)] : norm (restrict_scalars ùïú' f) = norm f := sorry

/-- `continuous_multilinear_map.restrict_scalars` as a `continuous_multilinear_map`. -/
def restrict_scalars_linear {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (ùïú' : Type u_1) [nondiscrete_normed_field ùïú'] [normed_algebra ùïú' ùïú] [normed_space ùïú' E‚ÇÇ] [is_scalar_tower ùïú' ùïú E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú' (E‚ÇÅ i)] [‚àÄ (i : Œπ), is_scalar_tower ùïú' ùïú (E‚ÇÅ i)] : continuous_linear_map ùïú' (continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) (continuous_multilinear_map ùïú' E‚ÇÅ E‚ÇÇ) :=
  linear_map.mk_continuous (linear_map.mk (restrict_scalars ùïú') sorry sorry) 1 sorry

theorem continuous_restrict_scalars {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] {ùïú' : Type u_1} [nondiscrete_normed_field ùïú'] [normed_algebra ùïú' ùïú] [normed_space ùïú' E‚ÇÇ] [is_scalar_tower ùïú' ùïú E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú' (E‚ÇÅ i)] [‚àÄ (i : Œπ), is_scalar_tower ùïú' ùïú (E‚ÇÅ i)] : continuous (restrict_scalars ùïú') :=
  continuous_linear_map.continuous (restrict_scalars_linear ùïú')

/-- The difference `f m‚ÇÅ - f m‚ÇÇ` is controlled in terms of `‚à•f‚à•` and `‚à•m‚ÇÅ - m‚ÇÇ‚à•`, precise version.
For a less precise but more usable version, see `norm_image_sub_le`. The bound reads
`‚à•f m - f m'‚à• ‚â§
  ‚à•f‚à• * ‚à•m 1 - m' 1‚à• * max ‚à•m 2‚à• ‚à•m' 2‚à• * max ‚à•m 3‚à• ‚à•m' 3‚à• * ... * max ‚à•m n‚à• ‚à•m' n‚à• + ...`,
where the other terms in the sum are the same products where `1` is replaced by any `i`.-/
theorem norm_image_sub_le' {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) (m‚ÇÅ : (i : Œπ) ‚Üí E‚ÇÅ i) (m‚ÇÇ : (i : Œπ) ‚Üí E‚ÇÅ i) : norm (coe_fn f m‚ÇÅ - coe_fn f m‚ÇÇ) ‚â§
  norm f *
    finset.sum finset.univ
      fun (i : Œπ) =>
        finset.prod finset.univ fun (j : Œπ) => ite (j = i) (norm (m‚ÇÅ i - m‚ÇÇ i)) (max (norm (m‚ÇÅ j)) (norm (m‚ÇÇ j))) :=
  multilinear_map.norm_image_sub_le_of_bound' (to_multilinear_map f) (norm_nonneg f) (le_op_norm f) m‚ÇÅ m‚ÇÇ

/-- The difference `f m‚ÇÅ - f m‚ÇÇ` is controlled in terms of `‚à•f‚à•` and `‚à•m‚ÇÅ - m‚ÇÇ‚à•`, less precise
version. For a more precise but less usable version, see `norm_image_sub_le'`.
The bound is `‚à•f m - f m'‚à• ‚â§ ‚à•f‚à• * card Œπ * ‚à•m - m'‚à• * (max ‚à•m‚à• ‚à•m'‚à•) ^ (card Œπ - 1)`.-/
theorem norm_image_sub_le {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) (m‚ÇÅ : (i : Œπ) ‚Üí E‚ÇÅ i) (m‚ÇÇ : (i : Œπ) ‚Üí E‚ÇÅ i) : norm (coe_fn f m‚ÇÅ - coe_fn f m‚ÇÇ) ‚â§
  norm f * ‚Üë(fintype.card Œπ) * max (norm m‚ÇÅ) (norm m‚ÇÇ) ^ (fintype.card Œπ - 1) * norm (m‚ÇÅ - m‚ÇÇ) :=
  multilinear_map.norm_image_sub_le_of_bound (to_multilinear_map f) (norm_nonneg f) (le_op_norm f) m‚ÇÅ m‚ÇÇ

/-- Applying a multilinear map to a vector is continuous in both coordinates. -/
theorem continuous_eval {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] : continuous fun (p : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ √ó ((i : Œπ) ‚Üí E‚ÇÅ i)) => coe_fn (prod.fst p) (prod.snd p) := sorry

theorem continuous_eval_left {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (m : (i : Œπ) ‚Üí E‚ÇÅ i) : continuous fun (p : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) => coe_fn p m :=
  continuous.comp continuous_eval (continuous.prod_mk continuous_id continuous_const)

theorem has_sum_eval {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] {Œ± : Type u_1} {p : Œ± ‚Üí continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ} {q : continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ} (h : has_sum p q) (m : (i : Œπ) ‚Üí E‚ÇÅ i) : has_sum (fun (a : Œ±) => coe_fn (p a) m) (coe_fn q m) := sorry

/-- If the target space is complete, the space of continuous multilinear maps with its norm is also
complete. The proof is essentially the same as for the space of continuous linear maps (modulo the
addition of `finset.prod` where needed. The duplication could be avoided by deducing the linear
case from the multilinear case via a currying isomorphism. However, this would mess up imports,
and it is more satisfactory to have the simplest case as a standalone proof. -/
protected instance complete_space {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] [complete_space E‚ÇÇ] : complete_space (continuous_multilinear_map ùïú E‚ÇÅ E‚ÇÇ) := sorry

end continuous_multilinear_map


/-- If a continuous multilinear map is constructed from a multilinear map via the constructor
`mk_continuous`, then its norm is bounded by the bound given to the constructor if it is
nonnegative. -/
theorem multilinear_map.mk_continuous_norm_le {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type w‚ÇÅ} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [(i : Œπ) ‚Üí normed_group (E‚ÇÅ i)] [normed_group E‚ÇÇ] [(i : Œπ) ‚Üí normed_space ùïú (E‚ÇÅ i)] [normed_space ùïú E‚ÇÇ] (f : multilinear_map ùïú E‚ÇÅ E‚ÇÇ) {C : ‚Ñù} (hC : 0 ‚â§ C) (H : ‚àÄ (m : (i : Œπ) ‚Üí E‚ÇÅ i), norm (coe_fn f m) ‚â§ C * finset.prod finset.univ fun (i : Œπ) => norm (m i)) : norm (multilinear_map.mk_continuous f C H) ‚â§ C :=
  continuous_multilinear_map.op_norm_le_bound (multilinear_map.mk_continuous f C H) hC fun (m : (i : Œπ) ‚Üí E‚ÇÅ i) => H m

namespace continuous_multilinear_map


/-- Given a continuous multilinear map `f` on `n` variables (parameterized by `fin n`) and a subset
`s` of `k` of these variables, one gets a new continuous multilinear map on `fin k` by varying
these variables, and fixing the other ones equal to a given value `z`. It is denoted by
`f.restr s hk z`, where `hk` is a proof that the cardinality of `s` is `k`. The implicit
identification between `fin k` and `s` that we use is the canonical (increasing) bijection. -/
def restr {ùïú : Type u} {G : Type wG} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] {k : ‚Ñï} {n : ‚Ñï} (f : continuous_multilinear_map ùïú (fun (i : fin n) => G) E‚ÇÇ) (s : finset (fin n)) (hk : finset.card s = k) (z : G) : continuous_multilinear_map ùïú (fun (i : fin k) => G) E‚ÇÇ :=
  multilinear_map.mk_continuous (multilinear_map.restr (to_multilinear_map f) s hk z) (norm f * norm z ^ (n - k)) sorry

theorem norm_restr {ùïú : Type u} {G : Type wG} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] {k : ‚Ñï} {n : ‚Ñï} (f : continuous_multilinear_map ùïú (fun (i : fin n) => G) E‚ÇÇ) (s : finset (fin n)) (hk : finset.card s = k) (z : G) : norm (restr f s hk z) ‚â§ norm f * norm z ^ (n - k) :=
  multilinear_map.mk_continuous_norm_le (multilinear_map.restr (to_multilinear_map f) s hk z)
    (mul_nonneg (norm_nonneg f) (pow_nonneg (norm_nonneg z) (n - k))) (restr._proof_1 f s hk z)

/-- The continuous multilinear map on `A^Œπ`, where `A` is a normed commutative algebra
over `ùïú`, associating to `m` the product of all the `m i`.

See also `continuous_multilinear_map.mk_pi_algebra_fin`. -/
protected def mk_pi_algebra (ùïú : Type u) (Œπ : Type v) [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] (A : Type u_1) [normed_comm_ring A] [normed_algebra ùïú A] : continuous_multilinear_map ùïú (fun (i : Œπ) => A) A :=
  multilinear_map.mk_continuous (multilinear_map.mk_pi_algebra ùïú Œπ A) (ite (Nonempty Œπ) 1 (norm 1)) sorry

@[simp] theorem mk_pi_algebra_apply {ùïú : Type u} {Œπ : Type v} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] {A : Type u_1} [normed_comm_ring A] [normed_algebra ùïú A] (m : Œπ ‚Üí A) : coe_fn (continuous_multilinear_map.mk_pi_algebra ùïú Œπ A) m = finset.prod finset.univ fun (i : Œπ) => m i :=
  rfl

theorem norm_mk_pi_algebra_le {ùïú : Type u} {Œπ : Type v} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] {A : Type u_1} [normed_comm_ring A] [normed_algebra ùïú A] [Nonempty Œπ] : norm (continuous_multilinear_map.mk_pi_algebra ùïú Œπ A) ‚â§ 1 := sorry

theorem norm_mk_pi_algebra_of_empty {ùïú : Type u} {Œπ : Type v} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] {A : Type u_1} [normed_comm_ring A] [normed_algebra ùïú A] (h : ¬¨Nonempty Œπ) : norm (continuous_multilinear_map.mk_pi_algebra ùïú Œπ A) = norm 1 := sorry

@[simp] theorem norm_mk_pi_algebra {ùïú : Type u} {Œπ : Type v} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] {A : Type u_1} [normed_comm_ring A] [normed_algebra ùïú A] [norm_one_class A] : norm (continuous_multilinear_map.mk_pi_algebra ùïú Œπ A) = 1 := sorry

/-- The continuous multilinear map on `A^n`, where `A` is a normed algebra over `ùïú`, associating to
`m` the product of all the `m i`.

See also: `multilinear_map.mk_pi_algebra`. -/
protected def mk_pi_algebra_fin (ùïú : Type u) (n : ‚Ñï) [nondiscrete_normed_field ùïú] (A : Type u_1) [normed_ring A] [normed_algebra ùïú A] : continuous_multilinear_map ùïú (fun (i : fin n) => A) A :=
  multilinear_map.mk_continuous (multilinear_map.mk_pi_algebra_fin ùïú n A) (nat.cases_on n (norm 1) fun (_x : ‚Ñï) => 1)
    sorry

@[simp] theorem mk_pi_algebra_fin_apply {ùïú : Type u} {n : ‚Ñï} [nondiscrete_normed_field ùïú] {A : Type u_1} [normed_ring A] [normed_algebra ùïú A] (m : fin n ‚Üí A) : coe_fn (continuous_multilinear_map.mk_pi_algebra_fin ùïú n A) m = list.prod (list.of_fn m) :=
  rfl

theorem norm_mk_pi_algebra_fin_succ_le {ùïú : Type u} {n : ‚Ñï} [nondiscrete_normed_field ùïú] {A : Type u_1} [normed_ring A] [normed_algebra ùïú A] : norm (continuous_multilinear_map.mk_pi_algebra_fin ùïú (Nat.succ n) A) ‚â§ 1 :=
  multilinear_map.mk_continuous_norm_le (multilinear_map.mk_pi_algebra_fin ùïú (Nat.succ n) A) zero_le_one
    (mk_pi_algebra_fin._proof_1 ùïú (Nat.succ n) A)

theorem norm_mk_pi_algebra_fin_le_of_pos {ùïú : Type u} {n : ‚Ñï} [nondiscrete_normed_field ùïú] {A : Type u_1} [normed_ring A] [normed_algebra ùïú A] (hn : 0 < n) : norm (continuous_multilinear_map.mk_pi_algebra_fin ùïú n A) ‚â§ 1 :=
  nat.cases_on n (fun (hn : 0 < 0) => false.elim (has_lt.lt.false hn))
    (fun (n : ‚Ñï) (hn : 0 < Nat.succ n) => norm_mk_pi_algebra_fin_succ_le) hn

theorem norm_mk_pi_algebra_fin_zero {ùïú : Type u} [nondiscrete_normed_field ùïú] {A : Type u_1} [normed_ring A] [normed_algebra ùïú A] : norm (continuous_multilinear_map.mk_pi_algebra_fin ùïú 0 A) = norm 1 := sorry

theorem norm_mk_pi_algebra_fin {ùïú : Type u} {n : ‚Ñï} [nondiscrete_normed_field ùïú] {A : Type u_1} [normed_ring A] [normed_algebra ùïú A] [norm_one_class A] : norm (continuous_multilinear_map.mk_pi_algebra_fin ùïú n A) = 1 := sorry

/-- The canonical continuous multilinear map on `ùïú^Œπ`, associating to `m` the product of all the
`m i` (multiplied by a fixed reference element `z` in the target module) -/
protected def mk_pi_field (ùïú : Type u) (Œπ : Type v) {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [normed_group E‚ÇÇ] [normed_space ùïú E‚ÇÇ] (z : E‚ÇÇ) : continuous_multilinear_map ùïú (fun (i : Œπ) => ùïú) E‚ÇÇ :=
  multilinear_map.mk_continuous (multilinear_map.mk_pi_ring ùïú Œπ z) (norm z) sorry

@[simp] theorem mk_pi_field_apply {ùïú : Type u} {Œπ : Type v} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [normed_group E‚ÇÇ] [normed_space ùïú E‚ÇÇ] (z : E‚ÇÇ) (m : Œπ ‚Üí ùïú) : coe_fn (continuous_multilinear_map.mk_pi_field ùïú Œπ z) m = (finset.prod finset.univ fun (i : Œπ) => m i) ‚Ä¢ z :=
  rfl

theorem mk_pi_field_apply_one_eq_self {ùïú : Type u} {Œπ : Type v} {E‚ÇÇ : Type w‚ÇÇ} [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [normed_group E‚ÇÇ] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú (fun (i : Œπ) => ùïú) E‚ÇÇ) : continuous_multilinear_map.mk_pi_field ùïú Œπ (coe_fn f fun (i : Œπ) => 1) = f :=
  to_multilinear_map_inj (multilinear_map.mk_pi_ring_apply_one_eq_self (to_multilinear_map f))

/-- Continuous multilinear maps on `ùïú^n` with values in `E‚ÇÇ` are in bijection with `E‚ÇÇ`, as such a
continuous multilinear map is completely determined by its value on the constant vector made of
ones. We register this bijection as a linear equivalence in
`continuous_multilinear_map.pi_field_equiv_aux`. The continuous linear equivalence is
`continuous_multilinear_map.pi_field_equiv`. -/
protected def pi_field_equiv_aux (ùïú : Type u) (Œπ : Type v) (E‚ÇÇ : Type w‚ÇÇ) [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [normed_group E‚ÇÇ] [normed_space ùïú E‚ÇÇ] : linear_equiv ùïú E‚ÇÇ (continuous_multilinear_map ùïú (fun (i : Œπ) => ùïú) E‚ÇÇ) :=
  linear_equiv.mk (fun (z : E‚ÇÇ) => continuous_multilinear_map.mk_pi_field ùïú Œπ z) sorry sorry
    (fun (f : continuous_multilinear_map ùïú (fun (i : Œπ) => ùïú) E‚ÇÇ) => coe_fn f fun (i : Œπ) => 1) sorry sorry

/-- Continuous multilinear maps on `ùïú^n` with values in `E‚ÇÇ` are in bijection with `E‚ÇÇ`, as such a
continuous multilinear map is completely determined by its value on the constant vector made of
ones. We register this bijection as a continuous linear equivalence in
`continuous_multilinear_map.pi_field_equiv`. -/
protected def pi_field_equiv (ùïú : Type u) (Œπ : Type v) (E‚ÇÇ : Type w‚ÇÇ) [DecidableEq Œπ] [fintype Œπ] [nondiscrete_normed_field ùïú] [normed_group E‚ÇÇ] [normed_space ùïú E‚ÇÇ] : continuous_linear_equiv ùïú E‚ÇÇ (continuous_multilinear_map ùïú (fun (i : Œπ) => ùïú) E‚ÇÇ) :=
  continuous_linear_equiv.mk
    (linear_equiv.mk (linear_equiv.to_fun (continuous_multilinear_map.pi_field_equiv_aux ùïú Œπ E‚ÇÇ)) sorry sorry
      (linear_equiv.inv_fun (continuous_multilinear_map.pi_field_equiv_aux ùïú Œπ E‚ÇÇ)) sorry sorry)

end continuous_multilinear_map


/-!
### Currying

We associate to a continuous multilinear map in `n+1` variables (i.e., based on `fin n.succ`) two
curried functions, named `f.curry_left` (which is a continuous linear map on `E 0` taking values
in continuous multilinear maps in `n` variables) and `f.curry_right` (which is a continuous
multilinear map in `n` variables taking values in continuous linear maps on `E (last n)`).
The inverse operations are called `uncurry_left` and `uncurry_right`.

We also register continuous linear equiv versions of these correspondences, in
`continuous_multilinear_curry_left_equiv` and `continuous_multilinear_curry_right_equiv`.
-/

theorem continuous_linear_map.norm_map_tail_le {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_linear_map ùïú (E 0) (continuous_multilinear_map ùïú (fun (i : fin n) => E (fin.succ i)) E‚ÇÇ)) (m : (i : fin (Nat.succ n)) ‚Üí E i) : norm (coe_fn (coe_fn f (m 0)) (fin.tail m)) ‚â§ norm f * finset.prod finset.univ fun (i : fin (Nat.succ n)) => norm (m i) := sorry

theorem continuous_multilinear_map.norm_map_init_le {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú (fun (i : fin n) => E (coe_fn fin.cast_succ i))
  (continuous_linear_map ùïú (E (fin.last n)) E‚ÇÇ)) (m : (i : fin (Nat.succ n)) ‚Üí E i) : norm (coe_fn (coe_fn f (fin.init m)) (m (fin.last n))) ‚â§
  norm f * finset.prod finset.univ fun (i : fin (Nat.succ n)) => norm (m i) := sorry

theorem continuous_multilinear_map.norm_map_cons_le {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E E‚ÇÇ) (x : E 0) (m : (i : fin n) ‚Üí E (fin.succ i)) : norm (coe_fn f (fin.cons x m)) ‚â§ norm f * norm x * finset.prod finset.univ fun (i : fin n) => norm (m i) := sorry

theorem continuous_multilinear_map.norm_map_snoc_le {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E E‚ÇÇ) (m : (i : fin n) ‚Üí E (coe_fn fin.cast_succ i)) (x : E (fin.last n)) : norm (coe_fn f (fin.snoc m x)) ‚â§ (norm f * finset.prod finset.univ fun (i : fin n) => norm (m i)) * norm x := sorry

/-! #### Left currying -/

/-- Given a continuous linear map `f` from `E 0` to continuous multilinear maps on `n` variables,
construct the corresponding continuous multilinear map on `n+1` variables obtained by concatenating
the variables, given by `m ‚Ü¶ f (m 0) (tail m)`-/
def continuous_linear_map.uncurry_left {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_linear_map ùïú (E 0) (continuous_multilinear_map ùïú (fun (i : fin n) => E (fin.succ i)) E‚ÇÇ)) : continuous_multilinear_map ùïú E E‚ÇÇ :=
  multilinear_map.mk_continuous
    (linear_map.uncurry_left
      (linear_map.comp continuous_multilinear_map.to_multilinear_map_linear (continuous_linear_map.to_linear_map f)))
    (norm f) sorry

@[simp] theorem continuous_linear_map.uncurry_left_apply {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_linear_map ùïú (E 0) (continuous_multilinear_map ùïú (fun (i : fin n) => E (fin.succ i)) E‚ÇÇ)) (m : (i : fin (Nat.succ n)) ‚Üí E i) : coe_fn (continuous_linear_map.uncurry_left f) m = coe_fn (coe_fn f (m 0)) (fin.tail m) :=
  rfl

/-- Given a continuous multilinear map `f` in `n+1` variables, split the first variable to obtain
a continuous linear map into continuous multilinear maps in `n` variables, given by
`x ‚Ü¶ (m ‚Ü¶ f (cons x m))`. -/
def continuous_multilinear_map.curry_left {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E E‚ÇÇ) : continuous_linear_map ùïú (E 0) (continuous_multilinear_map ùïú (fun (i : fin n) => E (fin.succ i)) E‚ÇÇ) :=
  linear_map.mk_continuous
    (linear_map.mk
      (fun (x : E 0) =>
        multilinear_map.mk_continuous
          (coe_fn (multilinear_map.curry_left (continuous_multilinear_map.to_multilinear_map f)) x) (norm f * norm x)
          sorry)
      sorry sorry)
    (norm f) sorry

@[simp] theorem continuous_multilinear_map.curry_left_apply {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E E‚ÇÇ) (x : E 0) (m : (i : fin n) ‚Üí E (fin.succ i)) : coe_fn (coe_fn (continuous_multilinear_map.curry_left f) x) m = coe_fn f (fin.cons x m) :=
  rfl

@[simp] theorem continuous_linear_map.curry_uncurry_left {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_linear_map ùïú (E 0) (continuous_multilinear_map ùïú (fun (i : fin n) => E (fin.succ i)) E‚ÇÇ)) : continuous_multilinear_map.curry_left (continuous_linear_map.uncurry_left f) = f := sorry

@[simp] theorem continuous_multilinear_map.uncurry_curry_left {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E E‚ÇÇ) : continuous_linear_map.uncurry_left (continuous_multilinear_map.curry_left f) = f := sorry

@[simp] theorem continuous_multilinear_map.curry_left_norm {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E E‚ÇÇ) : norm (continuous_multilinear_map.curry_left f) = norm f := sorry

@[simp] theorem continuous_linear_map.uncurry_left_norm {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_linear_map ùïú (E 0) (continuous_multilinear_map ùïú (fun (i : fin n) => E (fin.succ i)) E‚ÇÇ)) : norm (continuous_linear_map.uncurry_left f) = norm f := sorry

/-- The space of continuous multilinear maps on `Œ†(i : fin (n+1)), E i` is canonically isomorphic to
the space of continuous linear maps from `E 0` to the space of continuous multilinear maps on
`Œ†(i : fin n), E i.succ `, by separating the first variable. We register this isomorphism as a
linear isomorphism in `continuous_multilinear_curry_left_equiv_aux ùïú E E‚ÇÇ`.
The algebraic version (without continuity assumption on the maps) is
`multilinear_curry_left_equiv ùïú E E‚ÇÇ`, and the topological isomorphism (registering
additionally that the isomorphism is continuous) is
`continuous_multilinear_curry_left_equiv ùïú E E‚ÇÇ`.

The direct and inverse maps are given by `f.uncurry_left` and `f.curry_left`. Use these
unless you need the full framework of linear equivs. -/
def continuous_multilinear_curry_left_equiv_aux (ùïú : Type u) {n : ‚Ñï} (E : fin (Nat.succ n) ‚Üí Type w) (E‚ÇÇ : Type w‚ÇÇ) [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] : linear_equiv ùïú (continuous_linear_map ùïú (E 0) (continuous_multilinear_map ùïú (fun (i : fin n) => E (fin.succ i)) E‚ÇÇ))
  (continuous_multilinear_map ùïú E E‚ÇÇ) :=
  linear_equiv.mk continuous_linear_map.uncurry_left sorry sorry continuous_multilinear_map.curry_left
    continuous_linear_map.curry_uncurry_left sorry

/-- The space of continuous multilinear maps on `Œ†(i : fin (n+1)), E i` is canonically isomorphic to
the space of continuous linear maps from `E 0` to the space of continuous multilinear maps on
`Œ†(i : fin n), E i.succ `, by separating the first variable. We register this isomorphism in
`continuous_multilinear_curry_left_equiv ùïú E E‚ÇÇ`. The algebraic version (without topology) is given
in `multilinear_curry_left_equiv ùïú E E‚ÇÇ`.

The direct and inverse maps are given by `f.uncurry_left` and `f.curry_left`. Use these
unless you need the full framework of continuous linear equivs. -/
def continuous_multilinear_curry_left_equiv (ùïú : Type u) {n : ‚Ñï} (E : fin (Nat.succ n) ‚Üí Type w) (E‚ÇÇ : Type w‚ÇÇ) [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] : continuous_linear_equiv ùïú
  (continuous_linear_map ùïú (E 0) (continuous_multilinear_map ùïú (fun (i : fin n) => E (fin.succ i)) E‚ÇÇ))
  (continuous_multilinear_map ùïú E E‚ÇÇ) :=
  continuous_linear_equiv.mk
    (linear_equiv.mk (linear_equiv.to_fun (continuous_multilinear_curry_left_equiv_aux ùïú E E‚ÇÇ)) sorry sorry
      (linear_equiv.inv_fun (continuous_multilinear_curry_left_equiv_aux ùïú E E‚ÇÇ)) sorry sorry)

@[simp] theorem continuous_multilinear_curry_left_equiv_apply {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_linear_map ùïú (E 0) (continuous_multilinear_map ùïú (fun (i : fin n) => E (fin.succ i)) E‚ÇÇ)) (v : (i : fin (Nat.succ n)) ‚Üí E i) : coe_fn (coe_fn (continuous_multilinear_curry_left_equiv ùïú E E‚ÇÇ) f) v = coe_fn (coe_fn f (v 0)) (fin.tail v) :=
  rfl

@[simp] theorem continuous_multilinear_curry_left_equiv_symm_apply {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E E‚ÇÇ) (x : E 0) (v : (i : fin n) ‚Üí E (fin.succ i)) : coe_fn (coe_fn (coe_fn (continuous_linear_equiv.symm (continuous_multilinear_curry_left_equiv ùïú E E‚ÇÇ)) f) x) v =
  coe_fn f (fin.cons x v) :=
  rfl

/-! #### Right currying -/

/-- Given a continuous linear map `f` from continuous multilinear maps on `n` variables to
continuous linear maps on `E 0`, construct the corresponding continuous multilinear map on `n+1`
variables obtained by concatenating the variables, given by `m ‚Ü¶ f (init m) (m (last n))`. -/
def continuous_multilinear_map.uncurry_right {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú (fun (i : fin n) => E (coe_fn fin.cast_succ i))
  (continuous_linear_map ùïú (E (fin.last n)) E‚ÇÇ)) : continuous_multilinear_map ùïú E E‚ÇÇ :=
  let f' : multilinear_map ùïú (fun (i : fin n) => E (coe_fn fin.cast_succ i)) (linear_map ùïú (E (fin.last n)) E‚ÇÇ) :=
    multilinear_map.mk
      (fun (m : (i : fin n) ‚Üí E (coe_fn fin.cast_succ i)) => continuous_linear_map.to_linear_map (coe_fn f m)) sorry
      sorry;
  multilinear_map.mk_continuous (multilinear_map.uncurry_right f') (norm f) sorry

@[simp] theorem continuous_multilinear_map.uncurry_right_apply {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú (fun (i : fin n) => E (coe_fn fin.cast_succ i))
  (continuous_linear_map ùïú (E (fin.last n)) E‚ÇÇ)) (m : (i : fin (Nat.succ n)) ‚Üí E i) : coe_fn (continuous_multilinear_map.uncurry_right f) m = coe_fn (coe_fn f (fin.init m)) (m (fin.last n)) :=
  rfl

/-- Given a continuous multilinear map `f` in `n+1` variables, split the last variable to obtain
a continuous multilinear map in `n` variables into continuous linear maps, given by
`m ‚Ü¶ (x ‚Ü¶ f (snoc m x))`. -/
def continuous_multilinear_map.curry_right {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E E‚ÇÇ) : continuous_multilinear_map ùïú (fun (i : fin n) => E (coe_fn fin.cast_succ i))
  (continuous_linear_map ùïú (E (fin.last n)) E‚ÇÇ) :=
  let f' :
    multilinear_map ùïú (fun (i : fin n) => E (coe_fn fin.cast_succ i)) (continuous_linear_map ùïú (E (fin.last n)) E‚ÇÇ) :=
    multilinear_map.mk
      (fun (m : (i : fin n) ‚Üí E (coe_fn fin.cast_succ i)) =>
        linear_map.mk_continuous
          (coe_fn (multilinear_map.curry_right (continuous_multilinear_map.to_multilinear_map f)) m)
          (norm f * finset.prod finset.univ fun (i : fin n) => norm (m i)) sorry)
      sorry sorry;
  multilinear_map.mk_continuous f' (norm f) sorry

@[simp] theorem continuous_multilinear_map.curry_right_apply {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E E‚ÇÇ) (m : (i : fin n) ‚Üí E (coe_fn fin.cast_succ i)) (x : E (fin.last n)) : coe_fn (coe_fn (continuous_multilinear_map.curry_right f) m) x = coe_fn f (fin.snoc m x) :=
  rfl

@[simp] theorem continuous_multilinear_map.curry_uncurry_right {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú (fun (i : fin n) => E (coe_fn fin.cast_succ i))
  (continuous_linear_map ùïú (E (fin.last n)) E‚ÇÇ)) : continuous_multilinear_map.curry_right (continuous_multilinear_map.uncurry_right f) = f := sorry

@[simp] theorem continuous_multilinear_map.uncurry_curry_right {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E E‚ÇÇ) : continuous_multilinear_map.uncurry_right (continuous_multilinear_map.curry_right f) = f := sorry

@[simp] theorem continuous_multilinear_map.curry_right_norm {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E E‚ÇÇ) : norm (continuous_multilinear_map.curry_right f) = norm f := sorry

@[simp] theorem continuous_multilinear_map.uncurry_right_norm {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú (fun (i : fin n) => E (coe_fn fin.cast_succ i))
  (continuous_linear_map ùïú (E (fin.last n)) E‚ÇÇ)) : norm (continuous_multilinear_map.uncurry_right f) = norm f := sorry

/-- The space of continuous multilinear maps on `Œ†(i : fin (n+1)), E i` is canonically isomorphic to
the space of continuous multilinear maps on `Œ†(i : fin n), E i.cast_succ` with values in the space
of continuous linear maps on `E (last n)`, by separating the last variable. We register this
isomorphism as a linear equiv in `continuous_multilinear_curry_right_equiv_aux ùïú E E‚ÇÇ`.
The algebraic version (without continuity assumption on the maps) is
`multilinear_curry_right_equiv ùïú E E‚ÇÇ`, and the topological isomorphism (registering
additionally that the isomorphism is continuous) is
`continuous_multilinear_curry_right_equiv ùïú E E‚ÇÇ`.

The direct and inverse maps are given by `f.uncurry_right` and `f.curry_right`. Use these
unless you need the full framework of linear equivs. -/
def continuous_multilinear_curry_right_equiv_aux (ùïú : Type u) {n : ‚Ñï} (E : fin (Nat.succ n) ‚Üí Type w) (E‚ÇÇ : Type w‚ÇÇ) [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] : linear_equiv ùïú
  (continuous_multilinear_map ùïú (fun (i : fin n) => E (coe_fn fin.cast_succ i))
    (continuous_linear_map ùïú (E (fin.last n)) E‚ÇÇ))
  (continuous_multilinear_map ùïú E E‚ÇÇ) :=
  linear_equiv.mk continuous_multilinear_map.uncurry_right sorry sorry continuous_multilinear_map.curry_right
    continuous_multilinear_map.curry_uncurry_right sorry

/-- The space of continuous multilinear maps on `Œ†(i : fin (n+1)), E i` is canonically isomorphic to
the space of continuous multilinear maps on `Œ†(i : fin n), E i.cast_succ` with values in the space
of continuous linear maps on `E (last n)`, by separating the last variable. We register this
isomorphism as a continuous linear equiv in `continuous_multilinear_curry_right_equiv ùïú E E‚ÇÇ`.
The algebraic version (without topology) is given in `multilinear_curry_right_equiv ùïú E E‚ÇÇ`.

The direct and inverse maps are given by `f.uncurry_right` and `f.curry_right`. Use these
unless you need the full framework of continuous linear equivs. -/
def continuous_multilinear_curry_right_equiv (ùïú : Type u) {n : ‚Ñï} (E : fin (Nat.succ n) ‚Üí Type w) (E‚ÇÇ : Type w‚ÇÇ) [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] : continuous_linear_equiv ùïú
  (continuous_multilinear_map ùïú (fun (i : fin n) => E (coe_fn fin.cast_succ i))
    (continuous_linear_map ùïú (E (fin.last n)) E‚ÇÇ))
  (continuous_multilinear_map ùïú E E‚ÇÇ) :=
  continuous_linear_equiv.mk
    (linear_equiv.mk (linear_equiv.to_fun (continuous_multilinear_curry_right_equiv_aux ùïú E E‚ÇÇ)) sorry sorry
      (linear_equiv.inv_fun (continuous_multilinear_curry_right_equiv_aux ùïú E E‚ÇÇ)) sorry sorry)

/-- The space of continuous multilinear maps on `Œ†(i : fin (n+1)), G` is canonically isomorphic to
the space of continuous multilinear maps on `Œ†(i : fin n), G` with values in the space
of continuous linear maps on `G`, by separating the last variable. We register this
isomorphism as a continuous linear equiv in `continuous_multilinear_curry_right_equiv' ùïú n G E‚ÇÇ`.
For a version allowing dependent types, see `continuous_multilinear_curry_right_equiv`. When there
are no dependent types, use the primed version as it helps Lean a lot for unification.

The direct and inverse maps are given by `f.uncurry_right` and `f.curry_right`. Use these
unless you need the full framework of continuous linear equivs. -/
def continuous_multilinear_curry_right_equiv' (ùïú : Type u) (n : ‚Ñï) (G : Type wG) (E‚ÇÇ : Type w‚ÇÇ) [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] : continuous_linear_equiv ùïú (continuous_multilinear_map ùïú (fun (i : fin n) => G) (continuous_linear_map ùïú G E‚ÇÇ))
  (continuous_multilinear_map ùïú (fun (i : fin (Nat.succ n)) => G) E‚ÇÇ) :=
  continuous_multilinear_curry_right_equiv ùïú (fun (i : fin (Nat.succ n)) => G) E‚ÇÇ

@[simp] theorem continuous_multilinear_curry_right_equiv_apply {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú (fun (i : fin n) => E (coe_fn fin.cast_succ i))
  (continuous_linear_map ùïú (E (fin.last n)) E‚ÇÇ)) (v : (i : fin (Nat.succ n)) ‚Üí E i) : coe_fn (coe_fn (continuous_multilinear_curry_right_equiv ùïú E E‚ÇÇ) f) v = coe_fn (coe_fn f (fin.init v)) (v (fin.last n)) :=
  rfl

@[simp] theorem continuous_multilinear_curry_right_equiv_symm_apply {ùïú : Type u} {n : ‚Ñï} {E : fin (Nat.succ n) ‚Üí Type w} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [(i : fin (Nat.succ n)) ‚Üí normed_group (E i)] [normed_group E‚ÇÇ] [(i : fin (Nat.succ n)) ‚Üí normed_space ùïú (E i)] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú E E‚ÇÇ) (v : (i : fin n) ‚Üí E (coe_fn fin.cast_succ i)) (x : E (fin.last n)) : coe_fn (coe_fn (coe_fn (continuous_linear_equiv.symm (continuous_multilinear_curry_right_equiv ùïú E E‚ÇÇ)) f) v) x =
  coe_fn f (fin.snoc v x) :=
  rfl

@[simp] theorem continuous_multilinear_curry_right_equiv_apply' {ùïú : Type u} {n : ‚Ñï} {G : Type wG} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú (fun (i : fin n) => G) (continuous_linear_map ùïú G E‚ÇÇ)) (v : fin (Nat.succ n) ‚Üí G) : coe_fn (coe_fn (continuous_multilinear_curry_right_equiv' ùïú n G E‚ÇÇ) f) v =
  coe_fn (coe_fn f (fin.init v)) (v (fin.last n)) :=
  rfl

@[simp] theorem continuous_multilinear_curry_right_equiv_symm_apply' {ùïú : Type u} {n : ‚Ñï} {G : Type wG} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú (fun (i : fin (Nat.succ n)) => G) E‚ÇÇ) (v : fin n ‚Üí G) (x : G) : coe_fn (coe_fn (coe_fn (continuous_linear_equiv.symm (continuous_multilinear_curry_right_equiv' ùïú n G E‚ÇÇ)) f) v) x =
  coe_fn f (fin.snoc v x) :=
  rfl

/-!
#### Currying with `0` variables

The space of multilinear maps with `0` variables is trivial: such a multilinear map is just an
arbitrary constant (note that multilinear maps in `0` variables need not map `0` to `0`!).
Therefore, the space of continuous multilinear maps on `(fin 0) ‚Üí G` with values in `E‚ÇÇ` is
isomorphic (and even isometric) to `E‚ÇÇ`. As this is the zeroth step in the construction of iterated
derivatives, we register this isomorphism. -/

/-- Associating to a continuous multilinear map in `0` variables the unique value it takes. -/
def continuous_multilinear_map.uncurry0 {ùïú : Type u} {G : Type wG} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú (fun (i : fin 0) => G) E‚ÇÇ) : E‚ÇÇ :=
  coe_fn f 0

/-- Associating to an element `x` of a vector space `E‚ÇÇ` the continuous multilinear map in `0`
variables taking the (unique) value `x` -/
def continuous_multilinear_map.curry0 (ùïú : Type u) (G : Type wG) {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] (x : E‚ÇÇ) : continuous_multilinear_map ùïú (fun (i : fin 0) => G) E‚ÇÇ :=
  continuous_multilinear_map.mk (multilinear_map.mk (fun (m : fin 0 ‚Üí G) => x) sorry sorry) sorry

@[simp] theorem continuous_multilinear_map.curry0_apply (ùïú : Type u) {G : Type wG} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] (x : E‚ÇÇ) (m : fin 0 ‚Üí G) : coe_fn (continuous_multilinear_map.curry0 ùïú G x) m = x :=
  rfl

@[simp] theorem continuous_multilinear_map.uncurry0_apply {ùïú : Type u} {G : Type wG} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú (fun (i : fin 0) => G) E‚ÇÇ) : continuous_multilinear_map.uncurry0 f = coe_fn f 0 :=
  rfl

@[simp] theorem continuous_multilinear_map.apply_zero_curry0 {ùïú : Type u} {G : Type wG} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú (fun (i : fin 0) => G) E‚ÇÇ) {x : fin 0 ‚Üí G} : continuous_multilinear_map.curry0 ùïú G (coe_fn f x) = f := sorry

theorem continuous_multilinear_map.uncurry0_curry0 {ùïú : Type u} {G : Type wG} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú (fun (i : fin 0) => G) E‚ÇÇ) : continuous_multilinear_map.curry0 ùïú G (continuous_multilinear_map.uncurry0 f) = f := sorry

@[simp] theorem continuous_multilinear_map.curry0_uncurry0 (ùïú : Type u) (G : Type wG) {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] (x : E‚ÇÇ) : continuous_multilinear_map.uncurry0 (continuous_multilinear_map.curry0 ùïú G x) = x :=
  rfl

@[simp] theorem continuous_multilinear_map.uncurry0_norm (ùïú : Type u) (G : Type wG) {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] (x : E‚ÇÇ) : norm (continuous_multilinear_map.curry0 ùïú G x) = norm x := sorry

@[simp] theorem continuous_multilinear_map.fin0_apply_norm {ùïú : Type u} {G : Type wG} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú (fun (i : fin 0) => G) E‚ÇÇ) {x : fin 0 ‚Üí G} : norm (coe_fn f x) = norm f := sorry

theorem continuous_multilinear_map.curry0_norm {ùïú : Type u} {G : Type wG} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú (fun (i : fin 0) => G) E‚ÇÇ) : norm (continuous_multilinear_map.uncurry0 f) = norm f := sorry

/-- The linear isomorphism between elements of a normed space, and continuous multilinear maps in
`0` variables with values in this normed space. The continuous version is given in
`continuous_multilinear_curry_fin0`.

The direct and inverse maps are `uncurry0` and `curry0`. Use these unless you need the full
framework of linear equivs. -/
def continuous_multilinear_curry_fin0_aux (ùïú : Type u) (G : Type wG) (E‚ÇÇ : Type w‚ÇÇ) [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] : linear_equiv ùïú (continuous_multilinear_map ùïú (fun (i : fin 0) => G) E‚ÇÇ) E‚ÇÇ :=
  linear_equiv.mk
    (fun (f : continuous_multilinear_map ùïú (fun (i : fin 0) => G) E‚ÇÇ) => continuous_multilinear_map.uncurry0 f) sorry
    sorry (fun (f : E‚ÇÇ) => continuous_multilinear_map.curry0 ùïú G f) continuous_multilinear_map.uncurry0_curry0
    (continuous_multilinear_map.curry0_uncurry0 ùïú G)

/-- The continuous linear isomorphism between elements of a normed space, and continuous multilinear
maps in `0` variables with values in this normed space.

The direct and inverse maps are `uncurry0` and `curry0`. Use these unless you need the full
framework of continuous linear equivs. -/
def continuous_multilinear_curry_fin0 (ùïú : Type u) (G : Type wG) (E‚ÇÇ : Type w‚ÇÇ) [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] : continuous_linear_equiv ùïú (continuous_multilinear_map ùïú (fun (i : fin 0) => G) E‚ÇÇ) E‚ÇÇ :=
  continuous_linear_equiv.mk
    (linear_equiv.mk (linear_equiv.to_fun (continuous_multilinear_curry_fin0_aux ùïú G E‚ÇÇ)) sorry sorry
      (linear_equiv.inv_fun (continuous_multilinear_curry_fin0_aux ùïú G E‚ÇÇ)) sorry sorry)

@[simp] theorem continuous_multilinear_curry_fin0_apply {ùïú : Type u} {G : Type wG} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú (fun (i : fin 0) => G) E‚ÇÇ) : coe_fn (continuous_multilinear_curry_fin0 ùïú G E‚ÇÇ) f = coe_fn f 0 :=
  rfl

@[simp] theorem continuous_multilinear_curry_fin0_symm_apply {ùïú : Type u} {G : Type wG} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] (x : E‚ÇÇ) (v : fin 0 ‚Üí G) : coe_fn (coe_fn (continuous_linear_equiv.symm (continuous_multilinear_curry_fin0 ùïú G E‚ÇÇ)) x) v = x :=
  rfl

/-! #### With 1 variable -/

/-- Continuous multilinear maps from `G^1` to `E‚ÇÇ` are isomorphic with continuous linear maps from
`G` to `E‚ÇÇ`. -/
def continuous_multilinear_curry_fin1 (ùïú : Type u) (G : Type wG) (E‚ÇÇ : Type w‚ÇÇ) [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] : continuous_linear_equiv ùïú (continuous_multilinear_map ùïú (fun (i : fin 1) => G) E‚ÇÇ) (continuous_linear_map ùïú G E‚ÇÇ) :=
  continuous_linear_equiv.trans
    (continuous_linear_equiv.symm (continuous_multilinear_curry_right_equiv ùïú (fun (i : fin 1) => G) E‚ÇÇ))
    (continuous_multilinear_curry_fin0 ùïú G (continuous_linear_map ùïú G E‚ÇÇ))

@[simp] theorem continuous_multilinear_curry_fin1_apply {ùïú : Type u} {G : Type wG} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] (f : continuous_multilinear_map ùïú (fun (i : fin 1) => G) E‚ÇÇ) (x : G) : coe_fn (coe_fn (continuous_multilinear_curry_fin1 ùïú G E‚ÇÇ) f) x = coe_fn f (fin.snoc 0 x) :=
  rfl

@[simp] theorem continuous_multilinear_curry_fin1_symm_apply {ùïú : Type u} {G : Type wG} {E‚ÇÇ : Type w‚ÇÇ} [nondiscrete_normed_field ùïú] [normed_group G] [normed_group E‚ÇÇ] [normed_space ùïú G] [normed_space ùïú E‚ÇÇ] (f : continuous_linear_map ùïú G E‚ÇÇ) (v : fin 1 ‚Üí G) : coe_fn (coe_fn (continuous_linear_equiv.symm (continuous_multilinear_curry_fin1 ùïú G E‚ÇÇ)) f) v = coe_fn f (v 0) :=
  rfl

