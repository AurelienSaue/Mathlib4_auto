/-
Copyright (c) 2020 Kexing Ying. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kexing Ying
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.group_theory.submonoid.default
import Mathlib.algebra.group.conj
import Mathlib.order.modular_lattice
import Mathlib.PostPort

universes u_3 l u_1 u_2 u_4 u_5 

namespace Mathlib

/-!
# Subgroups

This file defines multiplicative and additive subgroups as an extension of submonoids, in a bundled
form (unbundled subgroups are in `deprecated/subgroups.lean`).

We prove subgroups of a group form a complete lattice, and results about images and preimages of
subgroups under group homomorphisms. The bundled subgroups use bundled monoid homomorphisms.

There are also theorems about the subgroups generated by an element or a subset of a group,
defined both inductively and as the infimum of the set of subgroups containing a given
element/subset.

Special thanks goes to Amelia Livingston and Yury Kudryashov for their help and inspiration.

## Main definitions

Notation used here:

- `G N` are `group`s

- `A` is an `add_group`

- `H K` are `subgroup`s of `G` or `add_subgroup`s of `A`

- `x` is an element of type `G` or type `A`

- `f g : N →* G` are group homomorphisms

- `s k` are sets of elements of type `G`

Definitions in the file:

* `subgroup G` : the type of subgroups of a group `G`

* `add_subgroup A` : the type of subgroups of an additive group `A`

* `complete_lattice (subgroup G)` : the subgroups of `G` form a complete lattice

* `subgroup.closure k` : the minimal subgroup that includes the set `k`

* `subgroup.subtype` : the natural group homomorphism from a subgroup of group `G` to `G`

* `subgroup.gi` : `closure` forms a Galois insertion with the coercion to set

* `subgroup.comap H f` : the preimage of a subgroup `H` along the group homomorphism `f` is also a
  subgroup

* `subgroup.map f H` : the image of a subgroup `H` along the group homomorphism `f` is also a
  subgroup

* `subgroup.prod H K` : the product of subgroups `H`, `K` of groups `G`, `N` respectively, `H × K`
  is a subgroup of `G × N`

* `monoid_hom.range f` : the range of the group homomorphism `f` is a subgroup

* `monoid_hom.ker f` : the kernel of a group homomorphism `f` is the subgroup of elements `x : G`
  such that `f x = 1`

* `monoid_hom.eq_locus f g` : given group homomorphisms `f`, `g`, the elements of `G` such that
  `f x = g x` form a subgroup of `G`

## Implementation notes

Subgroup inclusion is denoted `≤` rather than `⊆`, although `∈` is defined as
membership of a subgroup's underlying set.

## Tags
subgroup, subgroups
-/

/-- A subgroup of a group `G` is a subset containing 1, closed under multiplication
and closed under multiplicative inverse. -/
structure subgroup (G : Type u_3) [group G] extends submonoid G where
  inv_mem' : ∀ {x : G}, x ∈ carrier → x⁻¹ ∈ carrier

/-- An additive subgroup of an additive group `G` is a subset containing 0, closed
under addition and additive inverse. -/
structure add_subgroup (G : Type u_3) [add_group G] extends add_submonoid G where
  neg_mem' : ∀ {x : G}, x ∈ carrier → -x ∈ carrier

/-- Reinterpret a `subgroup` as a `submonoid`. -/
/-- Reinterpret an `add_subgroup` as an `add_submonoid`. -/
/-- Map from subgroups of group `G` to `add_subgroup`s of `additive G`. -/
def subgroup.to_add_subgroup {G : Type u_1} [group G] (H : subgroup G) :
    add_subgroup (additive G) :=
  add_subgroup.mk (add_submonoid.carrier (submonoid.to_add_submonoid (subgroup.to_submonoid H)))
    sorry sorry (subgroup.inv_mem' H)

/-- Map from `add_subgroup`s of `additive G` to subgroups of `G`. -/
def subgroup.of_add_subgroup {G : Type u_1} [group G] (H : add_subgroup (additive G)) :
    subgroup G :=
  subgroup.mk (submonoid.carrier (submonoid.of_add_submonoid (add_subgroup.to_add_submonoid H)))
    sorry sorry sorry

/-- Map from `add_subgroup`s of `add_group G` to subgroups of `multiplicative G`. -/
def add_subgroup.to_subgroup {G : Type u_1} [add_group G] (H : add_subgroup G) :
    subgroup (multiplicative G) :=
  subgroup.mk (submonoid.carrier (add_submonoid.to_submonoid (add_subgroup.to_add_submonoid H)))
    sorry sorry (add_subgroup.neg_mem' H)

/-- Map from subgroups of `multiplicative G` to `add_subgroup`s of `add_group G`. -/
def add_subgroup.of_subgroup {G : Type u_1} [add_group G] (H : subgroup (multiplicative G)) :
    add_subgroup G :=
  add_subgroup.mk (add_submonoid.carrier (add_submonoid.of_submonoid (subgroup.to_submonoid H)))
    sorry sorry sorry

/-- Subgroups of group `G` are isomorphic to additive subgroups of `additive G`. -/
def subgroup.add_subgroup_equiv (G : Type u_1) [group G] : subgroup G ≃ add_subgroup (additive G) :=
  equiv.mk subgroup.to_add_subgroup subgroup.of_add_subgroup sorry sorry

namespace subgroup


protected instance set.has_coe {G : Type u_1} [group G] : has_coe (subgroup G) (set G) :=
  has_coe.mk carrier

@[simp] theorem coe_to_submonoid {G : Type u_1} [group G] (K : subgroup G) :
    ↑(to_submonoid K) = ↑K :=
  rfl

protected instance has_mem {G : Type u_1} [group G] : has_mem G (subgroup G) :=
  has_mem.mk fun (m : G) (K : subgroup G) => m ∈ ↑K

protected instance Mathlib.add_subgroup.has_coe_to_sort {G : Type u_1} [add_group G] :
    has_coe_to_sort (add_subgroup G) :=
  has_coe_to_sort.mk (has_coe_to_sort.S (add_subgroup G)) fun (G_1 : add_subgroup G) => ↥G_1

@[simp] theorem Mathlib.add_subgroup.mem_coe {G : Type u_1} [add_group G] {K : add_subgroup G}
    {g : G} : g ∈ ↑K ↔ g ∈ K :=
  iff.rfl

@[simp] theorem Mathlib.add_subgroup.coe_coe {G : Type u_1} [add_group G] (K : add_subgroup G) :
    ↥↑K = ↥K :=
  rfl

-- note that `to_additive` transfers the `simp` attribute over but not the `norm_cast` attribute

protected instance Mathlib.add_subgroup.fintype {G : Type u_1} [add_group G] (K : add_subgroup G)
    [d : decidable_pred (add_subgroup.carrier K)] [fintype G] : fintype ↥K :=
  (fun (this : fintype (Subtype fun (g : G) => g ∈ add_subgroup.carrier K)) => this) infer_instance

end subgroup


protected theorem add_subgroup.exists {G : Type u_1} [add_group G] {K : add_subgroup G}
    {p : ↥K → Prop} : (∃ (x : ↥K), p x) ↔ ∃ (x : G), ∃ (H : x ∈ K), p { val := x, property := H } :=
  set_coe.exists

protected theorem subgroup.forall {G : Type u_1} [group G] {K : subgroup G} {p : ↥K → Prop} :
    (∀ (x : ↥K), p x) ↔ ∀ (x : G) (H : x ∈ K), p { val := x, property := H } :=
  set_coe.forall

namespace subgroup


/-- Copy of a subgroup with a new `carrier` equal to the old one. Useful to fix definitional
equalities.-/
protected def Mathlib.add_subgroup.copy {G : Type u_1} [add_group G] (K : add_subgroup G)
    (s : set G) (hs : s = ↑K) : add_subgroup G :=
  add_subgroup.mk s sorry sorry sorry

/- Two subgroups are equal if the underlying set are the same. -/

theorem Mathlib.add_subgroup.ext' {G : Type u_1} [add_group G] {H : add_subgroup G}
    {K : add_subgroup G} (h : ↑H = ↑K) : H = K :=
  sorry

/- Two subgroups are equal if and only if the underlying subsets are equal. -/

protected theorem Mathlib.add_subgroup.ext'_iff {G : Type u_1} [add_group G] {H : add_subgroup G}
    {K : add_subgroup G} : H = K ↔ ↑H = ↑K :=
  { mp := fun (h : H = K) => h ▸ rfl, mpr := add_subgroup.ext' }

/-- Two subgroups are equal if they have the same elements. -/
theorem ext {G : Type u_1} [group G] {H : subgroup G} {K : subgroup G}
    (h : ∀ (x : G), x ∈ H ↔ x ∈ K) : H = K :=
  ext' (set.ext h)

/-- A subgroup contains the group's 1. -/
theorem one_mem {G : Type u_1} [group G] (H : subgroup G) : 1 ∈ H := one_mem' H

/-- A subgroup is closed under multiplication. -/
theorem Mathlib.add_subgroup.add_mem {G : Type u_1} [add_group G] (H : add_subgroup G) {x : G}
    {y : G} : x ∈ H → y ∈ H → x + y ∈ H :=
  fun (hx : x ∈ H) (hy : y ∈ H) => add_subgroup.add_mem' H hx hy

/-- A subgroup is closed under inverse. -/
theorem inv_mem {G : Type u_1} [group G] (H : subgroup G) {x : G} : x ∈ H → x⁻¹ ∈ H :=
  fun (hx : x ∈ H) => inv_mem' H hx

/-- A subgroup is closed under division. -/
theorem Mathlib.add_subgroup.sub_mem {G : Type u_1} [add_group G] (H : add_subgroup G) {x : G}
    {y : G} (hx : x ∈ H) (hy : y ∈ H) : x - y ∈ H :=
  sorry

@[simp] theorem Mathlib.add_subgroup.neg_mem_iff {G : Type u_1} [add_group G] (H : add_subgroup G)
    {x : G} : -x ∈ H ↔ x ∈ H :=
  { mp := fun (h : -x ∈ H) => neg_neg x ▸ add_subgroup.neg_mem H h, mpr := add_subgroup.neg_mem H }

theorem Mathlib.add_subgroup.add_mem_cancel_right {G : Type u_1} [add_group G] (H : add_subgroup G)
    {x : G} {y : G} (h : x ∈ H) : y + x ∈ H ↔ y ∈ H :=
  sorry

theorem Mathlib.add_subgroup.add_mem_cancel_left {G : Type u_1} [add_group G] (H : add_subgroup G)
    {x : G} {y : G} (h : x ∈ H) : x + y ∈ H ↔ y ∈ H :=
  sorry

/-- Product of a list of elements in a subgroup is in the subgroup. -/
theorem list_prod_mem {G : Type u_1} [group G] (K : subgroup G) {l : List G} :
    (∀ (x : G), x ∈ l → x ∈ K) → list.prod l ∈ K :=
  submonoid.list_prod_mem (to_submonoid K)

/-- Product of a multiset of elements in a subgroup of a `comm_group` is in the subgroup. -/
theorem multiset_prod_mem {G : Type u_1} [comm_group G] (K : subgroup G) (g : multiset G) :
    (∀ (a : G), a ∈ g → a ∈ K) → multiset.prod g ∈ K :=
  submonoid.multiset_prod_mem (to_submonoid K) g

/-- Product of elements of a subgroup of a `comm_group` indexed by a `finset` is in the
    subgroup. -/
theorem Mathlib.add_subgroup.sum_mem {G : Type u_1} [add_comm_group G] (K : add_subgroup G)
    {ι : Type u_2} {t : finset ι} {f : ι → G} (h : ∀ (c : ι), c ∈ t → f c ∈ K) :
    (finset.sum t fun (c : ι) => f c) ∈ K :=
  add_submonoid.sum_mem (add_subgroup.to_add_submonoid K) h

theorem pow_mem {G : Type u_1} [group G] (K : subgroup G) {x : G} (hx : x ∈ K) (n : ℕ) :
    x ^ n ∈ K :=
  submonoid.pow_mem (to_submonoid K) hx

theorem gpow_mem {G : Type u_1} [group G] (K : subgroup G) {x : G} (hx : x ∈ K) (n : ℤ) :
    x ^ n ∈ K :=
  int.cases_on n (fun (n : ℕ) => idRhs (x ^ n ∈ K) (pow_mem K hx n))
    fun (n : ℕ) => idRhs (x ^ Nat.succ n⁻¹ ∈ K) (inv_mem K (pow_mem K hx (Nat.succ n)))

/-- Construct a subgroup from a nonempty set that is closed under division. -/
def Mathlib.add_subgroup.of_sub {G : Type u_1} [add_group G] (s : set G) (hsn : set.nonempty s)
    (hs : ∀ (x y : G), x ∈ s → y ∈ s → x + -y ∈ s) : add_subgroup G :=
  (fun (one_mem : 0 ∈ s) =>
      (fun (inv_mem : ∀ (x : G), x ∈ s → -x ∈ s) => add_subgroup.mk s one_mem sorry inv_mem) sorry)
    sorry

/-- A subgroup of a group inherits a multiplication. -/
protected instance Mathlib.add_subgroup.has_add {G : Type u_1} [add_group G] (H : add_subgroup G) :
    Add ↥H :=
  add_submonoid.has_add (add_subgroup.to_add_submonoid H)

/-- A subgroup of a group inherits a 1. -/
protected instance Mathlib.add_subgroup.has_zero {G : Type u_1} [add_group G] (H : add_subgroup G) :
    HasZero ↥H :=
  add_submonoid.has_zero (add_subgroup.to_add_submonoid H)

/-- A subgroup of a group inherits an inverse. -/
protected instance Mathlib.add_subgroup.has_neg {G : Type u_1} [add_group G] (H : add_subgroup G) :
    Neg ↥H :=
  { neg := fun (a : ↥H) => { val := -↑a, property := sorry } }

/-- A subgroup of a group inherits a division -/
protected instance has_div {G : Type u_1} [group G] (H : subgroup G) : Div ↥H :=
  { div := fun (a b : ↥H) => { val := ↑a / ↑b, property := sorry } }

@[simp] theorem Mathlib.add_subgroup.coe_add {G : Type u_1} [add_group G] (H : add_subgroup G)
    (x : ↥H) (y : ↥H) : ↑(x + y) = ↑x + ↑y :=
  rfl

@[simp] theorem Mathlib.add_subgroup.coe_zero {G : Type u_1} [add_group G] (H : add_subgroup G) :
    ↑0 = 0 :=
  rfl

@[simp] theorem coe_inv {G : Type u_1} [group G] (H : subgroup G) (x : ↥H) : ↑(x⁻¹) = (↑x⁻¹) := rfl

@[simp] theorem Mathlib.add_subgroup.coe_mk {G : Type u_1} [add_group G] (H : add_subgroup G)
    (x : G) (hx : x ∈ H) : ↑{ val := x, property := hx } = x :=
  rfl

/-- A subgroup of a group inherits a group structure. -/
protected instance Mathlib.add_subgroup.to_add_group {G : Type u_1} [add_group G]
    (H : add_subgroup G) : add_group ↥H :=
  add_group.mk add_monoid.add sorry add_monoid.zero sorry sorry Neg.neg Sub.sub sorry

/-- A subgroup of a `comm_group` is a `comm_group`. -/
protected instance Mathlib.add_subgroup.to_add_comm_group {G : Type u_1} [add_comm_group G]
    (H : add_subgroup G) : add_comm_group ↥H :=
  add_comm_group.mk add_group.add sorry add_group.zero sorry sorry add_group.neg add_group.sub sorry
    sorry

/-- The natural group hom from a subgroup of group `G` to `G`. -/
def subtype {G : Type u_1} [group G] (H : subgroup G) : ↥H →* G := monoid_hom.mk coe sorry sorry

@[simp] theorem coe_subtype {G : Type u_1} [group G] (H : subgroup G) : ⇑(subtype H) = coe := rfl

@[simp] theorem coe_pow {G : Type u_1} [group G] (H : subgroup G) (x : ↥H) (n : ℕ) :
    ↑(x ^ n) = ↑x ^ n :=
  coe_subtype H ▸ monoid_hom.map_pow (subtype H) x n

@[simp] theorem coe_gpow {G : Type u_1} [group G] (H : subgroup G) (x : ↥H) (n : ℤ) :
    ↑(x ^ n) = ↑x ^ n :=
  coe_subtype H ▸ monoid_hom.map_gpow (subtype H) x n

protected instance Mathlib.add_subgroup.has_le {G : Type u_1} [add_group G] :
    HasLessEq (add_subgroup G) :=
  { LessEq := fun (H K : add_subgroup G) => ∀ {x : G}, x ∈ H → x ∈ K }

theorem Mathlib.add_subgroup.le_def {G : Type u_1} [add_group G] {H : add_subgroup G}
    {K : add_subgroup G} : H ≤ K ↔ ∀ {x : G}, x ∈ H → x ∈ K :=
  iff.rfl

@[simp] theorem Mathlib.add_subgroup.coe_subset_coe {G : Type u_1} [add_group G]
    {H : add_subgroup G} {K : add_subgroup G} : ↑H ⊆ ↑K ↔ H ≤ K :=
  iff.rfl

protected instance partial_order {G : Type u_1} [group G] : partial_order (subgroup G) :=
  partial_order.mk LessEq partial_order.lt sorry sorry sorry

/-- The subgroup `G` of the group `G`. -/
protected instance has_top {G : Type u_1} [group G] : has_top (subgroup G) :=
  has_top.mk (mk (submonoid.carrier ⊤) sorry sorry sorry)

/-- The trivial subgroup `{1}` of an group `G`. -/
protected instance Mathlib.add_subgroup.has_bot {G : Type u_1} [add_group G] :
    has_bot (add_subgroup G) :=
  has_bot.mk (add_subgroup.mk (add_submonoid.carrier ⊥) sorry sorry sorry)

protected instance Mathlib.add_subgroup.inhabited {G : Type u_1} [add_group G] :
    Inhabited (add_subgroup G) :=
  { default := ⊥ }

@[simp] theorem mem_bot {G : Type u_1} [group G] {x : G} : x ∈ ⊥ ↔ x = 1 := iff.rfl

@[simp] theorem Mathlib.add_subgroup.mem_top {G : Type u_1} [add_group G] (x : G) : x ∈ ⊤ :=
  set.mem_univ x

@[simp] theorem Mathlib.add_subgroup.coe_top {G : Type u_1} [add_group G] : ↑⊤ = set.univ := rfl

@[simp] theorem coe_bot {G : Type u_1} [group G] : ↑⊥ = singleton 1 := rfl

theorem Mathlib.add_subgroup.eq_bot_iff_forall {G : Type u_1} [add_group G] (H : add_subgroup G) :
    H = ⊥ ↔ ∀ (x : G), x ∈ H → x = 0 :=
  sorry

theorem Mathlib.add_subgroup.eq_top_of_card_eq {G : Type u_1} [add_group G] (H : add_subgroup G)
    [fintype ↥H] [fintype G] (h : fintype.card ↥H = fintype.card G) : H = ⊤ :=
  sorry

theorem nontrivial_iff_exists_ne_one {G : Type u_1} [group G] (H : subgroup G) :
    nontrivial ↥H ↔ ∃ (x : G), ∃ (H : x ∈ H), x ≠ 1 :=
  sorry

/-- A subgroup is either the trivial subgroup or nontrivial. -/
theorem Mathlib.add_subgroup.bot_or_nontrivial {G : Type u_1} [add_group G] (H : add_subgroup G) :
    H = ⊥ ∨ nontrivial ↥H :=
  sorry

/-- A subgroup is either the trivial subgroup or contains a nonzero element. -/
theorem bot_or_exists_ne_one {G : Type u_1} [group G] (H : subgroup G) :
    H = ⊥ ∨ ∃ (x : G), ∃ (H : x ∈ H), x ≠ 1 :=
  sorry

/-- The inf of two subgroups is their intersection. -/
protected instance has_inf {G : Type u_1} [group G] : has_inf (subgroup G) :=
  has_inf.mk
    fun (H₁ H₂ : subgroup G) =>
      mk (submonoid.carrier (to_submonoid H₁ ⊓ to_submonoid H₂)) sorry sorry sorry

@[simp] theorem coe_inf {G : Type u_1} [group G] (p : subgroup G) (p' : subgroup G) :
    ↑(p ⊓ p') = ↑p ∩ ↑p' :=
  rfl

@[simp] theorem Mathlib.add_subgroup.mem_inf {G : Type u_1} [add_group G] {p : add_subgroup G}
    {p' : add_subgroup G} {x : G} : x ∈ p ⊓ p' ↔ x ∈ p ∧ x ∈ p' :=
  iff.rfl

protected instance Mathlib.add_subgroup.has_Inf {G : Type u_1} [add_group G] :
    has_Inf (add_subgroup G) :=
  has_Inf.mk
    fun (s : set (add_subgroup G)) =>
      add_subgroup.mk
        (add_submonoid.carrier
          (add_submonoid.copy
            (infi
              fun (S : add_subgroup G) => infi fun (H : S ∈ s) => add_subgroup.to_add_submonoid S)
            (set.Inter fun (S : add_subgroup G) => set.Inter fun (H : S ∈ s) => ↑S) sorry))
        sorry sorry sorry

@[simp] theorem Mathlib.add_subgroup.coe_Inf {G : Type u_1} [add_group G]
    (H : set (add_subgroup G)) :
    ↑(Inf H) = set.Inter fun (s : add_subgroup G) => set.Inter fun (H : s ∈ H) => ↑s :=
  rfl

@[simp] theorem mem_Inf {G : Type u_1} [group G] {S : set (subgroup G)} {x : G} :
    x ∈ Inf S ↔ ∀ (p : subgroup G), p ∈ S → x ∈ p :=
  set.mem_bInter_iff

theorem Mathlib.add_subgroup.mem_infi {G : Type u_1} [add_group G] {ι : Sort u_2}
    {S : ι → add_subgroup G} {x : G} : (x ∈ infi fun (i : ι) => S i) ↔ ∀ (i : ι), x ∈ S i :=
  sorry

@[simp] theorem Mathlib.add_subgroup.coe_infi {G : Type u_1} [add_group G] {ι : Sort u_2}
    {S : ι → add_subgroup G} : ↑(infi fun (i : ι) => S i) = set.Inter fun (i : ι) => ↑(S i) :=
  sorry

/-- Subgroups of a group form a complete lattice. -/
protected instance Mathlib.add_subgroup.complete_lattice {G : Type u_1} [add_group G] :
    complete_lattice (add_subgroup G) :=
  complete_lattice.mk complete_lattice.sup complete_lattice.le complete_lattice.lt sorry sorry sorry
    sorry sorry sorry has_inf.inf sorry sorry sorry ⊤ sorry ⊥ sorry complete_lattice.Sup
    complete_lattice.Inf sorry sorry sorry sorry

theorem Mathlib.add_subgroup.mem_sup_left {G : Type u_1} [add_group G] {S : add_subgroup G}
    {T : add_subgroup G} {x : G} : x ∈ S → x ∈ S ⊔ T :=
  (fun (this : S ≤ S ⊔ T) => this) le_sup_left

theorem Mathlib.add_subgroup.mem_sup_right {G : Type u_1} [add_group G] {S : add_subgroup G}
    {T : add_subgroup G} {x : G} : x ∈ T → x ∈ S ⊔ T :=
  (fun (this : T ≤ S ⊔ T) => this) le_sup_right

theorem Mathlib.add_subgroup.mem_supr_of_mem {G : Type u_1} [add_group G] {ι : Type u_2}
    {S : ι → add_subgroup G} (i : ι) {x : G} : x ∈ S i → x ∈ supr S :=
  (fun (this : S i ≤ supr S) => this) (le_supr S i)

theorem Mathlib.add_subgroup.mem_Sup_of_mem {G : Type u_1} [add_group G] {S : set (add_subgroup G)}
    {s : add_subgroup G} (hs : s ∈ S) {x : G} : x ∈ s → x ∈ Sup S :=
  (fun (this : s ≤ Sup S) => this) (le_Sup hs)

theorem subsingleton_iff {G : Type u_1} [group G] : subsingleton G ↔ subsingleton (subgroup G) :=
  sorry

theorem nontrivial_iff {G : Type u_1} [group G] : nontrivial G ↔ nontrivial (subgroup G) :=
  iff.mp not_iff_not
    (iff.trans (iff.trans not_nontrivial_iff_subsingleton subsingleton_iff)
      (iff.symm not_nontrivial_iff_subsingleton))

protected instance subsingleton {G : Type u_1} [group G] [subsingleton G] :
    subsingleton (subgroup G) :=
  iff.mp subsingleton_iff _inst_3

protected instance Mathlib.add_subgroup.nontrivial {G : Type u_1} [add_group G] [nontrivial G] :
    nontrivial (add_subgroup G) :=
  iff.mp add_subgroup.nontrivial_iff _inst_3

/-- The `subgroup` generated by a set. -/
def Mathlib.add_subgroup.closure {G : Type u_1} [add_group G] (k : set G) : add_subgroup G :=
  Inf (set_of fun (K : add_subgroup G) => k ⊆ ↑K)

theorem Mathlib.add_subgroup.mem_closure {G : Type u_1} [add_group G] {k : set G} {x : G} :
    x ∈ add_subgroup.closure k ↔ ∀ (K : add_subgroup G), k ⊆ ↑K → x ∈ K :=
  add_subgroup.mem_Inf

/-- The subgroup generated by a set includes the set. -/
@[simp] theorem subset_closure {G : Type u_1} [group G] {k : set G} : k ⊆ ↑(closure k) :=
  fun (x : G) (hx : x ∈ k) => iff.mpr mem_closure fun (K : subgroup G) (hK : k ⊆ ↑K) => hK hx

/-- A subgroup `K` includes `closure k` if and only if it includes `k`. -/
@[simp] theorem closure_le {G : Type u_1} [group G] (K : subgroup G) {k : set G} :
    closure k ≤ K ↔ k ⊆ ↑K :=
  { mp := set.subset.trans subset_closure, mpr := fun (h : k ⊆ ↑K) => Inf_le h }

theorem Mathlib.add_subgroup.closure_eq_of_le {G : Type u_1} [add_group G] (K : add_subgroup G)
    {k : set G} (h₁ : k ⊆ ↑K) (h₂ : K ≤ add_subgroup.closure k) : add_subgroup.closure k = K :=
  le_antisymm (iff.mpr (add_subgroup.closure_le K) h₁) h₂

/-- An induction principle for closure membership. If `p` holds for `1` and all elements of `k`, and
is preserved under multiplication and inverse, then `p` holds for all elements of the closure
of `k`. -/
theorem Mathlib.add_subgroup.closure_induction {G : Type u_1} [add_group G] {k : set G}
    {p : G → Prop} {x : G} (h : x ∈ add_subgroup.closure k) (Hk : ∀ (x : G), x ∈ k → p x) (H1 : p 0)
    (Hmul : ∀ (x y : G), p x → p y → p (x + y)) (Hinv : ∀ (x : G), p x → p (-x)) : p x :=
  iff.mpr (add_subgroup.closure_le (add_subgroup.mk p H1 Hmul Hinv)) Hk x h

/-- An induction principle on elements of the subtype `subgroup.closure`.
If `p` holds for `1` and all elements of `k`, and is preserved under multiplication and inverse,
then `p` holds for all elements `x : closure k`.

The difference with `subgroup.closure_induction` is that this acts on the subtype.
-/
theorem closure_induction' {G : Type u_1} [group G] (k : set G) {p : ↥(closure k) → Prop}
    (Hk : ∀ (x : G) (h : x ∈ k), p { val := x, property := subset_closure h }) (H1 : p 1)
    (Hmul : ∀ (x y : ↥(closure k)), p x → p y → p (x * y))
    (Hinv : ∀ (x : ↥(closure k)), p x → p (x⁻¹)) (x : ↥(closure k)) : p x :=
  sorry

/-- `closure` forms a Galois insertion with the coercion to set. -/
protected def Mathlib.add_subgroup.gi (G : Type u_1) [add_group G] :
    galois_insertion add_subgroup.closure coe :=
  galois_insertion.mk
    (fun (s : set G) (_x : ↑(add_subgroup.closure s) ≤ s) => add_subgroup.closure s) sorry sorry
    sorry

/-- Subgroup closure of a set is monotone in its argument: if `h ⊆ k`,
then `closure h ≤ closure k`. -/
theorem closure_mono {G : Type u_1} [group G] {h : set G} {k : set G} (h' : h ⊆ k) :
    closure h ≤ closure k :=
  galois_connection.monotone_l (galois_insertion.gc (subgroup.gi G)) h'

/-- Closure of a subgroup `K` equals `K`. -/
@[simp] theorem closure_eq {G : Type u_1} [group G] (K : subgroup G) : closure ↑K = K :=
  galois_insertion.l_u_eq (subgroup.gi G) K

@[simp] theorem Mathlib.add_subgroup.closure_empty {G : Type u_1} [add_group G] :
    add_subgroup.closure ∅ = ⊥ :=
  galois_connection.l_bot (galois_insertion.gc (add_subgroup.gi G))

@[simp] theorem closure_univ {G : Type u_1} [group G] : closure set.univ = ⊤ :=
  coe_top ▸ closure_eq ⊤

theorem closure_union {G : Type u_1} [group G] (s : set G) (t : set G) :
    closure (s ∪ t) = closure s ⊔ closure t :=
  galois_connection.l_sup (galois_insertion.gc (subgroup.gi G))

theorem Mathlib.add_subgroup.closure_Union {G : Type u_1} [add_group G] {ι : Sort u_2}
    (s : ι → set G) :
    add_subgroup.closure (set.Union fun (i : ι) => s i) =
        supr fun (i : ι) => add_subgroup.closure (s i) :=
  galois_connection.l_supr (galois_insertion.gc (add_subgroup.gi G))

theorem closure_eq_bot_iff (G : Type u_1) [group G] (S : set G) : closure S = ⊥ ↔ S ⊆ singleton 1 :=
  eq.mpr
    (id (Eq._oldrec (Eq.refl (closure S = ⊥ ↔ S ⊆ singleton 1)) (Eq.symm (propext le_bot_iff))))
    (closure_le ⊥)

/-- The subgroup generated by an element of a group equals the set of integer number powers of
    the element. -/
theorem mem_closure_singleton {G : Type u_1} [group G] {x : G} {y : G} :
    y ∈ closure (singleton x) ↔ ∃ (n : ℤ), x ^ n = y :=
  sorry

theorem closure_singleton_one {G : Type u_1} [group G] : closure (singleton 1) = ⊥ := sorry

theorem Mathlib.add_subgroup.mem_supr_of_directed {G : Type u_1} [add_group G] {ι : Sort u_2}
    [hι : Nonempty ι] {K : ι → add_subgroup G} (hK : directed LessEq K) {x : G} :
    x ∈ supr K ↔ ∃ (i : ι), x ∈ K i :=
  sorry

theorem Mathlib.add_subgroup.coe_supr_of_directed {G : Type u_1} [add_group G] {ι : Sort u_2}
    [Nonempty ι] {S : ι → add_subgroup G} (hS : directed LessEq S) :
    ↑(supr fun (i : ι) => S i) = set.Union fun (i : ι) => ↑(S i) :=
  sorry

theorem Mathlib.add_subgroup.mem_Sup_of_directed_on {G : Type u_1} [add_group G]
    {K : set (add_subgroup G)} (Kne : set.nonempty K) (hK : directed_on LessEq K) {x : G} :
    x ∈ Sup K ↔ ∃ (s : add_subgroup G), ∃ (H : s ∈ K), x ∈ s :=
  sorry

/-- The preimage of a subgroup along a monoid homomorphism is a subgroup. -/
def Mathlib.add_subgroup.comap {G : Type u_1} [add_group G] {N : Type u_2} [add_group N]
    (f : G →+ N) (H : add_subgroup N) : add_subgroup G :=
  add_subgroup.mk (⇑f ⁻¹' ↑H) sorry sorry sorry

@[simp] theorem coe_comap {G : Type u_1} [group G] {N : Type u_3} [group N] (K : subgroup N)
    (f : G →* N) : ↑(comap f K) = ⇑f ⁻¹' ↑K :=
  rfl

@[simp] theorem Mathlib.add_subgroup.mem_comap {G : Type u_1} [add_group G] {N : Type u_3}
    [add_group N] {K : add_subgroup N} {f : G →+ N} {x : G} :
    x ∈ add_subgroup.comap f K ↔ coe_fn f x ∈ K :=
  iff.rfl

theorem comap_comap {G : Type u_1} [group G] {N : Type u_3} [group N] {P : Type u_4} [group P]
    (K : subgroup P) (g : N →* P) (f : G →* N) :
    comap f (comap g K) = comap (monoid_hom.comp g f) K :=
  rfl

/-- The image of a subgroup along a monoid homomorphism is a subgroup. -/
def map {G : Type u_1} [group G] {N : Type u_3} [group N] (f : G →* N) (H : subgroup G) :
    subgroup N :=
  mk (⇑f '' ↑H) sorry sorry sorry

@[simp] theorem Mathlib.add_subgroup.coe_map {G : Type u_1} [add_group G] {N : Type u_3}
    [add_group N] (f : G →+ N) (K : add_subgroup G) : ↑(add_subgroup.map f K) = ⇑f '' ↑K :=
  rfl

@[simp] theorem Mathlib.add_subgroup.mem_map {G : Type u_1} [add_group G] {N : Type u_3}
    [add_group N] {f : G →+ N} {K : add_subgroup G} {y : N} :
    y ∈ add_subgroup.map f K ↔ ∃ (x : G), ∃ (H : x ∈ K), coe_fn f x = y :=
  set.mem_image_iff_bex

theorem map_map {G : Type u_1} [group G] (K : subgroup G) {N : Type u_3} [group N] {P : Type u_4}
    [group P] (g : N →* P) (f : G →* N) : map g (map f K) = map (monoid_hom.comp g f) K :=
  ext' (set.image_image (fun (a : N) => coe_fn g a) (fun (a : G) => coe_fn f a) ↑K)

theorem Mathlib.add_subgroup.map_le_iff_le_comap {G : Type u_1} [add_group G] {N : Type u_3}
    [add_group N] {f : G →+ N} {K : add_subgroup G} {H : add_subgroup N} :
    add_subgroup.map f K ≤ H ↔ K ≤ add_subgroup.comap f H :=
  set.image_subset_iff

theorem Mathlib.add_subgroup.gc_map_comap {G : Type u_1} [add_group G] {N : Type u_3} [add_group N]
    (f : G →+ N) : galois_connection (add_subgroup.map f) (add_subgroup.comap f) :=
  fun (_x : add_subgroup G) (_x_1 : add_subgroup N) => add_subgroup.map_le_iff_le_comap

theorem map_sup {G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) (K : subgroup G)
    (f : G →* N) : map f (H ⊔ K) = map f H ⊔ map f K :=
  galois_connection.l_sup (gc_map_comap f)

theorem Mathlib.add_subgroup.map_supr {G : Type u_1} [add_group G] {N : Type u_3} [add_group N]
    {ι : Sort u_2} (f : G →+ N) (s : ι → add_subgroup G) :
    add_subgroup.map f (supr s) = supr fun (i : ι) => add_subgroup.map f (s i) :=
  galois_connection.l_supr (add_subgroup.gc_map_comap f)

theorem comap_inf {G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup N)
    (K : subgroup N) (f : G →* N) : comap f (H ⊓ K) = comap f H ⊓ comap f K :=
  galois_connection.u_inf (gc_map_comap f)

theorem comap_infi {G : Type u_1} [group G] {N : Type u_3} [group N] {ι : Sort u_2} (f : G →* N)
    (s : ι → subgroup N) : comap f (infi s) = infi fun (i : ι) => comap f (s i) :=
  galois_connection.u_infi (gc_map_comap f)

@[simp] theorem map_bot {G : Type u_1} [group G] {N : Type u_3} [group N] (f : G →* N) :
    map f ⊥ = ⊥ :=
  galois_connection.l_bot (gc_map_comap f)

@[simp] theorem Mathlib.add_subgroup.comap_top {G : Type u_1} [add_group G] {N : Type u_3}
    [add_group N] (f : G →+ N) : add_subgroup.comap f ⊤ = ⊤ :=
  galois_connection.u_top (add_subgroup.gc_map_comap f)

theorem Mathlib.add_subgroup.map_eq_bot_iff {G : Type u_1} [add_group G] {G' : Type u_2}
    [add_group G'] {f : G →+ G'} (hf : function.injective ⇑f) (H : add_subgroup G) :
    add_subgroup.map f H = ⊥ ↔ H = ⊥ :=
  sorry

/-- Given `subgroup`s `H`, `K` of groups `G`, `N` respectively, `H × K` as a subgroup of `G × N`. -/
def Mathlib.add_subgroup.prod {G : Type u_1} [add_group G] {N : Type u_3} [add_group N]
    (H : add_subgroup G) (K : add_subgroup N) : add_subgroup (G × N) :=
  add_subgroup.mk
    (add_submonoid.carrier
      (add_submonoid.prod (add_subgroup.to_add_submonoid H) (add_subgroup.to_add_submonoid K)))
    sorry sorry sorry

theorem Mathlib.add_subgroup.coe_prod {G : Type u_1} [add_group G] {N : Type u_3} [add_group N]
    (H : add_subgroup G) (K : add_subgroup N) : ↑(add_subgroup.prod H K) = set.prod ↑H ↑K :=
  rfl

theorem Mathlib.add_subgroup.mem_prod {G : Type u_1} [add_group G] {N : Type u_3} [add_group N]
    {H : add_subgroup G} {K : add_subgroup N} {p : G × N} :
    p ∈ add_subgroup.prod H K ↔ prod.fst p ∈ H ∧ prod.snd p ∈ K :=
  iff.rfl

theorem prod_mono {G : Type u_1} [group G] {N : Type u_3} [group N] :
    relator.lift_fun LessEq (LessEq ⇒ LessEq) prod prod :=
  fun (s s' : subgroup G) (hs : s ≤ s') (t t' : subgroup N) (ht : t ≤ t') => set.prod_mono hs ht

theorem prod_mono_right {G : Type u_1} [group G] {N : Type u_3} [group N] (K : subgroup G) :
    monotone fun (t : subgroup N) => prod K t :=
  prod_mono (le_refl K)

theorem Mathlib.add_subgroup.prod_mono_left {G : Type u_1} [add_group G] {N : Type u_3}
    [add_group N] (H : add_subgroup N) :
    monotone fun (K : add_subgroup G) => add_subgroup.prod K H :=
  fun (s₁ s₂ : add_subgroup G) (hs : s₁ ≤ s₂) => add_subgroup.prod_mono hs (le_refl H)

theorem Mathlib.add_subgroup.prod_top {G : Type u_1} [add_group G] {N : Type u_3} [add_group N]
    (K : add_subgroup G) : add_subgroup.prod K ⊤ = add_subgroup.comap (add_monoid_hom.fst G N) K :=
  sorry

theorem Mathlib.add_subgroup.top_prod {G : Type u_1} [add_group G] {N : Type u_3} [add_group N]
    (H : add_subgroup N) : add_subgroup.prod ⊤ H = add_subgroup.comap (add_monoid_hom.snd G N) H :=
  sorry

@[simp] theorem top_prod_top {G : Type u_1} [group G] {N : Type u_3} [group N] : prod ⊤ ⊤ = ⊤ :=
  Eq.trans (top_prod ⊤) (comap_top (monoid_hom.snd G N))

theorem bot_prod_bot {G : Type u_1} [group G] {N : Type u_3} [group N] : prod ⊥ ⊥ = ⊥ := sorry

/-- Product of subgroups is isomorphic to their product as groups. -/
def prod_equiv {G : Type u_1} [group G] {N : Type u_3} [group N] (H : subgroup G) (K : subgroup N) :
    ↥(prod H K) ≃* ↥H × ↥K :=
  mul_equiv.mk (equiv.to_fun (equiv.set.prod ↑H ↑K)) (equiv.inv_fun (equiv.set.prod ↑H ↑K)) sorry
    sorry sorry

/-- A subgroup is normal if whenever `n ∈ H`, then `g * n * g⁻¹ ∈ H` for every `g : G` -/
class normal {G : Type u_1} [group G] (H : subgroup G) where
  conj_mem : ∀ (n : G), n ∈ H → ∀ (g : G), g * n * (g⁻¹) ∈ H

end subgroup


namespace add_subgroup


/-- An add_subgroup is normal if whenever `n ∈ H`, then `g + n - g ∈ H` for every `g : G` -/
class normal {A : Type u_2} [add_group A] (H : add_subgroup A) where
  conj_mem : ∀ (n : A), n ∈ H → ∀ (g : A), g + n + -g ∈ H

end add_subgroup


namespace subgroup


protected instance normal_of_comm {G : Type u_1} [comm_group G] (H : subgroup G) : normal H := sorry

namespace normal


theorem mem_comm {G : Type u_1} [group G] {H : subgroup G} (nH : normal H) {a : G} {b : G}
    (h : a * b ∈ H) : b * a ∈ H :=
  sorry

theorem mem_comm_iff {G : Type u_1} [group G] {H : subgroup G} (nH : normal H) {a : G} {b : G} :
    a * b ∈ H ↔ b * a ∈ H :=
  { mp := mem_comm nH, mpr := mem_comm nH }

end normal


protected instance bot_normal {G : Type u_1} [group G] : normal ⊥ :=
  normal.mk
    (eq.mpr
      (id
        (Eq.trans
          (Eq.trans
            (Eq.trans
              (forall_congr_eq
                fun (n : G) =>
                  imp_congr_eq (propext mem_bot) (forall_congr_eq fun (g : G) => propext mem_bot))
              (propext forall_eq))
            (forall_congr_eq
              fun (g : G) =>
                Eq.trans
                  ((fun (a a_1 : G) (e_1 : a = a_1) (ᾰ ᾰ_1 : G) (e_2 : ᾰ = ᾰ_1) =>
                      congr (congr_arg Eq e_1) e_2)
                    (g * 1 * (g⁻¹)) 1
                    (Eq.trans
                      ((fun (ᾰ ᾰ_1 : G) (e_2 : ᾰ = ᾰ_1) (ᾰ_2 ᾰ_3 : G) (e_3 : ᾰ_2 = ᾰ_3) =>
                          congr (congr_arg Mul.mul e_2) e_3)
                        (g * 1) g (mul_one g) (g⁻¹) (g⁻¹) (Eq.refl (g⁻¹)))
                      (mul_right_inv g))
                    1 1 (Eq.refl 1))
                  (propext (eq_self_iff_true 1))))
          (propext (forall_const G))))
      trivial)

protected instance top_normal {G : Type u_1} [group G] : normal ⊤ :=
  normal.mk fun (_x : G) (_x : _x ∈ ⊤) => mem_top

/-- The center of a group `G` is the set of elements that commute with everything in `G` -/
def center (G : Type u_1) [group G] : subgroup G :=
  mk (set_of fun (z : G) => ∀ (g : G), g * z = z * g) sorry sorry sorry

theorem Mathlib.add_subgroup.mem_center_iff {G : Type u_1} [add_group G] {z : G} :
    z ∈ add_subgroup.center G ↔ ∀ (g : G), g + z = z + g :=
  iff.rfl

protected instance Mathlib.add_subgroup.center_normal {G : Type u_1} [add_group G] :
    add_subgroup.normal (add_subgroup.center G) :=
  sorry

/-- The `normalizer` of `H` is the smallest subgroup of `G` inside which `H` is normal. -/
def normalizer {G : Type u_1} [group G] (H : subgroup G) : subgroup G :=
  mk (set_of fun (g : G) => ∀ (n : G), n ∈ H ↔ g * n * (g⁻¹) ∈ H) sorry sorry sorry

-- variant for sets.

-- TODO should this replace `normalizer`?

/-- The `set_normalizer` of `S` is the subgroup of `G` whose elements satisfy `g*S*g⁻¹=S` -/
def set_normalizer {G : Type u_1} [group G] (S : set G) : subgroup G :=
  mk (set_of fun (g : G) => ∀ (n : G), n ∈ S ↔ g * n * (g⁻¹) ∈ S) sorry sorry sorry

theorem Mathlib.add_subgroup.mem_normalizer_iff {G : Type u_1} [add_group G] {H : add_subgroup G}
    {g : G} : g ∈ add_subgroup.normalizer H ↔ ∀ (n : G), n ∈ H ↔ g + n + -g ∈ H :=
  iff.rfl

theorem le_normalizer {G : Type u_1} [group G] {H : subgroup G} : H ≤ normalizer H :=
  fun (x : G) (xH : x ∈ H) (n : G) =>
    eq.mpr
      (id
        (Eq._oldrec (Eq.refl (n ∈ H ↔ x * n * (x⁻¹) ∈ H))
          (propext (mul_mem_cancel_right H (inv_mem H xH)))))
      (eq.mpr (id (Eq._oldrec (Eq.refl (n ∈ H ↔ x * n ∈ H)) (propext (mul_mem_cancel_left H xH))))
        (iff.refl (n ∈ H)))

protected instance normal_in_normalizer {G : Type u_1} [group G] {H : subgroup G} :
    normal (comap (subtype (normalizer H)) H) :=
  sorry

theorem le_normalizer_of_normal {G : Type u_1} [group G] {H : subgroup G} {K : subgroup G}
    [hK : normal (comap (subtype K) H)] (HK : H ≤ K) : K ≤ normalizer H :=
  sorry

end subgroup


namespace group


/-- Given an element `a`, `conjugates a` is the set of conjugates. -/
def conjugates {G : Type u_1} [group G] (a : G) : set G := set_of fun (b : G) => is_conj a b

theorem mem_conjugates_self {G : Type u_1} [group G] {a : G} : a ∈ conjugates a := is_conj_refl a

/-- Given a set `s`, `conjugates_of_set s` is the set of all conjugates of
the elements of `s`. -/
def conjugates_of_set {G : Type u_1} [group G] (s : set G) : set G :=
  set.Union fun (a : G) => set.Union fun (H : a ∈ s) => conjugates a

theorem mem_conjugates_of_set_iff {G : Type u_1} [group G] {s : set G} {x : G} :
    x ∈ conjugates_of_set s ↔ ∃ (a : G), ∃ (H : a ∈ s), is_conj a x :=
  set.mem_bUnion_iff

theorem subset_conjugates_of_set {G : Type u_1} [group G] {s : set G} : s ⊆ conjugates_of_set s :=
  fun (x : G) (h : x ∈ s) =>
    iff.mpr mem_conjugates_of_set_iff (Exists.intro x (Exists.intro h (is_conj_refl x)))

theorem conjugates_of_set_mono {G : Type u_1} [group G] {s : set G} {t : set G} (h : s ⊆ t) :
    conjugates_of_set s ⊆ conjugates_of_set t :=
  set.bUnion_subset_bUnion_left h

theorem conjugates_subset_normal {G : Type u_1} [group G] {N : subgroup G} [tn : subgroup.normal N]
    {a : G} (h : a ∈ N) : conjugates a ⊆ ↑N :=
  id
    fun (a_1 : G) (ᾰ : a_1 ∈ conjugates a) =>
      Exists.dcases_on ᾰ
        fun (c : G) (ᾰ_h : c * a * (c⁻¹) = a_1) =>
          Eq._oldrec (subgroup.normal.conj_mem tn a h c) ᾰ_h

theorem conjugates_of_set_subset {G : Type u_1} [group G] {s : set G} {N : subgroup G}
    [subgroup.normal N] (h : s ⊆ ↑N) : conjugates_of_set s ⊆ ↑N :=
  set.bUnion_subset fun (x : G) (H : x ∈ s) => conjugates_subset_normal (h H)

/-- The set of conjugates of `s` is closed under conjugation. -/
theorem conj_mem_conjugates_of_set {G : Type u_1} [group G] {s : set G} {x : G} {c : G} :
    x ∈ conjugates_of_set s → c * x * (c⁻¹) ∈ conjugates_of_set s :=
  sorry

end group


namespace subgroup


/-- The normal closure of a set `s` is the subgroup closure of all the conjugates of
elements of `s`. It is the smallest normal subgroup containing `s`. -/
def normal_closure {G : Type u_1} [group G] (s : set G) : subgroup G :=
  closure (group.conjugates_of_set s)

theorem conjugates_of_set_subset_normal_closure {G : Type u_1} [group G] {s : set G} :
    group.conjugates_of_set s ⊆ ↑(normal_closure s) :=
  subset_closure

theorem subset_normal_closure {G : Type u_1} [group G] {s : set G} : s ⊆ ↑(normal_closure s) :=
  set.subset.trans group.subset_conjugates_of_set conjugates_of_set_subset_normal_closure

theorem le_normal_closure {G : Type u_1} [group G] {H : subgroup G} : H ≤ normal_closure ↑H :=
  fun (_x : G) (h : _x ∈ H) => subset_normal_closure h

/-- The normal closure of `s` is a normal subgroup. -/
protected instance normal_closure_normal {G : Type u_1} [group G] {s : set G} :
    normal (normal_closure s) :=
  sorry

/-- The normal closure of `s` is the smallest normal subgroup containing `s`. -/
theorem normal_closure_le_normal {G : Type u_1} [group G] {s : set G} {N : subgroup G} [normal N]
    (h : s ⊆ ↑N) : normal_closure s ≤ N :=
  sorry

theorem normal_closure_subset_iff {G : Type u_1} [group G] {s : set G} {N : subgroup G} [normal N] :
    s ⊆ ↑N ↔ normal_closure s ≤ N :=
  { mp := normal_closure_le_normal, mpr := set.subset.trans subset_normal_closure }

theorem normal_closure_mono {G : Type u_1} [group G] {s : set G} {t : set G} (h : s ⊆ t) :
    normal_closure s ≤ normal_closure t :=
  normal_closure_le_normal (set.subset.trans h subset_normal_closure)

theorem normal_closure_eq_infi {G : Type u_1} [group G] {s : set G} :
    normal_closure s = infi fun (N : subgroup G) => infi (infi fun (hs : s ⊆ ↑N) => N) :=
  le_antisymm
    (le_infi
      fun (N : subgroup G) => le_infi fun (hN : normal N) => le_infi normal_closure_le_normal)
    (infi_le_of_le (normal_closure s)
      (infi_le_of_le subgroup.normal_closure_normal
        (infi_le_of_le subset_normal_closure (le_refl (normal_closure s)))))

@[simp] theorem normal_closure_eq_self {G : Type u_1} [group G] (H : subgroup G) [normal H] :
    normal_closure ↑H = H :=
  le_antisymm (normal_closure_le_normal (eq.subset rfl)) le_normal_closure

@[simp] theorem normal_closure_idempotent {G : Type u_1} [group G] {s : set G} :
    normal_closure ↑(normal_closure s) = normal_closure s :=
  normal_closure_eq_self (normal_closure s)

theorem closure_le_normal_closure {G : Type u_1} [group G] {s : set G} :
    closure s ≤ normal_closure s :=
  eq.mpr
    (id
      (Eq.trans (propext (closure_le (normal_closure s)))
        (propext (iff_true_intro subset_normal_closure))))
    trivial

@[simp] theorem normal_closure_closure_eq_normal_closure {G : Type u_1} [group G] {s : set G} :
    normal_closure ↑(closure s) = normal_closure s :=
  le_antisymm (normal_closure_le_normal closure_le_normal_closure)
    (normal_closure_mono subset_closure)

end subgroup


namespace add_subgroup


theorem gsmul_mem {A : Type u_2} [add_group A] (H : add_subgroup A) {x : A} (hx : x ∈ H) (n : ℤ) :
    n •ℤ x ∈ H :=
  sorry

/-- The `add_subgroup` generated by an element of an `add_group` equals the set of
natural number multiples of the element. -/
theorem mem_closure_singleton {A : Type u_2} [add_group A] {x : A} {y : A} :
    y ∈ closure (singleton x) ↔ ∃ (n : ℤ), n •ℤ x = y :=
  sorry

theorem closure_singleton_zero {A : Type u_2} [add_group A] : closure (singleton 0) = ⊥ := sorry

@[simp] theorem coe_smul {A : Type u_2} [add_group A] (H : add_subgroup A) (x : ↥H) (n : ℕ) :
    ↑(n •ℕ x) = n •ℕ ↑x :=
  coe_subtype H ▸ add_monoid_hom.map_nsmul (subtype H) x n

@[simp] theorem coe_gsmul {A : Type u_2} [add_group A] (H : add_subgroup A) (x : ↥H) (n : ℤ) :
    ↑(n •ℤ x) = n •ℤ ↑x :=
  coe_subtype H ▸ add_monoid_hom.map_gsmul (subtype H) x n

end add_subgroup


namespace monoid_hom


/-- The range of a monoid homomorphism from a group is a subgroup. -/
def Mathlib.add_monoid_hom.range {G : Type u_1} [add_group G] {N : Type u_3} [add_group N]
    (f : G →+ N) : add_subgroup N :=
  add_subgroup.copy (add_subgroup.map f ⊤) (set.range ⇑f) sorry

protected instance decidable_mem_range {G : Type u_1} [group G] {N : Type u_3} [group N]
    (f : G →* N) [fintype G] [DecidableEq N] : decidable_pred fun (x : N) => x ∈ range f :=
  fun (x : N) => fintype.decidable_exists_fintype

@[simp] theorem Mathlib.add_monoid_hom.coe_range {G : Type u_1} [add_group G] {N : Type u_3}
    [add_group N] (f : G →+ N) : ↑(add_monoid_hom.range f) = set.range ⇑f :=
  rfl

@[simp] theorem Mathlib.add_monoid_hom.mem_range {G : Type u_1} [add_group G] {N : Type u_3}
    [add_group N] {f : G →+ N} {y : N} : y ∈ add_monoid_hom.range f ↔ ∃ (x : G), coe_fn f x = y :=
  iff.rfl

theorem Mathlib.add_monoid_hom.range_eq_map {G : Type u_1} [add_group G] {N : Type u_3}
    [add_group N] (f : G →+ N) : add_monoid_hom.range f = add_subgroup.map f ⊤ :=
  sorry

/-- The canonical surjective group homomorphism `G →* f(G)` induced by a group
homomorphism `G →* N`. -/
def Mathlib.add_monoid_hom.to_range {G : Type u_1} [add_group G] {N : Type u_3} [add_group N]
    (f : G →+ N) : G →+ ↥(add_monoid_hom.range f) :=
  add_monoid_hom.mk' (fun (g : G) => { val := coe_fn f g, property := sorry }) sorry

theorem Mathlib.add_monoid_hom.map_range {G : Type u_1} [add_group G] {N : Type u_3} {P : Type u_4}
    [add_group N] [add_group P] (g : N →+ P) (f : G →+ N) :
    add_subgroup.map g (add_monoid_hom.range f) = add_monoid_hom.range (add_monoid_hom.comp g f) :=
  sorry

theorem range_top_iff_surjective {G : Type u_1} [group G] {N : Type u_2} [group N] {f : G →* N} :
    range f = ⊤ ↔ function.surjective ⇑f :=
  sorry

/-- The range of a surjective monoid homomorphism is the whole of the codomain. -/
theorem range_top_of_surjective {G : Type u_1} [group G] {N : Type u_2} [group N] (f : G →* N)
    (hf : function.surjective ⇑f) : range f = ⊤ :=
  iff.mpr range_top_iff_surjective hf

/-- Restriction of a group hom to a subgroup of the codomain. -/
def Mathlib.add_monoid_hom.cod_restrict {G : Type u_1} [add_group G] {N : Type u_3} [add_group N]
    (f : G →+ N) (S : add_subgroup N) (h : ∀ (x : G), coe_fn f x ∈ S) : G →+ ↥S :=
  add_monoid_hom.mk (fun (n : G) => { val := coe_fn f n, property := h n }) sorry sorry

/-- The multiplicative kernel of a monoid homomorphism is the subgroup of elements `x : G` such that
`f x = 1` -/
def ker {G : Type u_1} [group G] {N : Type u_3} [group N] (f : G →* N) : subgroup G :=
  subgroup.comap f ⊥

theorem Mathlib.add_monoid_hom.mem_ker {G : Type u_1} [add_group G] {N : Type u_3} [add_group N]
    (f : G →+ N) {x : G} : x ∈ add_monoid_hom.ker f ↔ coe_fn f x = 0 :=
  iff.rfl

theorem comap_ker {G : Type u_1} [group G] {N : Type u_3} {P : Type u_4} [group N] [group P]
    (g : N →* P) (f : G →* N) : subgroup.comap f (ker g) = ker (comp g f) :=
  rfl

theorem Mathlib.add_monoid_hom.to_range_ker {G : Type u_1} [add_group G] {N : Type u_3}
    [add_group N] (f : G →+ N) :
    add_monoid_hom.ker (add_monoid_hom.to_range f) = add_monoid_hom.ker f :=
  sorry

/-- The subgroup of elements `x : G` such that `f x = g x` -/
def eq_locus {G : Type u_1} [group G] {N : Type u_3} [group N] (f : G →* N) (g : G →* N) :
    subgroup G :=
  subgroup.mk (submonoid.carrier (eq_mlocus f g)) sorry sorry sorry

/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/
theorem Mathlib.add_monoid_hom.eq_on_closure {G : Type u_1} [add_group G] {N : Type u_3}
    [add_group N] {f : G →+ N} {g : G →+ N} {s : set G} (h : set.eq_on (⇑f) (⇑g) s) :
    set.eq_on ⇑f ⇑g ↑(add_subgroup.closure s) :=
  (fun (this : add_subgroup.closure s ≤ add_monoid_hom.eq_locus f g) => this)
    (iff.mpr (add_subgroup.closure_le (add_monoid_hom.eq_locus f g)) h)

theorem eq_of_eq_on_top {G : Type u_1} [group G] {N : Type u_3} [group N] {f : G →* N} {g : G →* N}
    (h : set.eq_on ⇑f ⇑g ↑⊤) : f = g :=
  ext fun (x : G) => h trivial

theorem Mathlib.add_monoid_hom.eq_of_eq_on_dense {G : Type u_1} [add_group G] {N : Type u_3}
    [add_group N] {s : set G} (hs : add_subgroup.closure s = ⊤) {f : G →+ N} {g : G →+ N}
    (h : set.eq_on (⇑f) (⇑g) s) : f = g :=
  add_monoid_hom.eq_of_eq_on_top (hs ▸ add_monoid_hom.eq_on_closure h)

theorem Mathlib.add_monoid_hom.gclosure_preimage_le {G : Type u_1} [add_group G] {N : Type u_3}
    [add_group N] (f : G →+ N) (s : set N) :
    add_subgroup.closure (⇑f ⁻¹' s) ≤ add_subgroup.comap f (add_subgroup.closure s) :=
  sorry

/-- The image under a monoid homomorphism of the subgroup generated by a set equals the subgroup
generated by the image of the set. -/
theorem Mathlib.add_monoid_hom.map_closure {G : Type u_1} [add_group G] {N : Type u_3} [add_group N]
    (f : G →+ N) (s : set G) :
    add_subgroup.map f (add_subgroup.closure s) = add_subgroup.closure (⇑f '' s) :=
  sorry

end monoid_hom


namespace monoid_hom


/-- `lift_of_surjective f hf g hg` is the unique group homomorphism `φ`

* such that `φ.comp f = g` (`lift_of_surjective_comp`),
* where `f : G₁ →+* G₂` is surjective (`hf`),
* and `g : G₂ →+* G₃` satisfies `hg : f.ker ≤ g.ker`.

See `lift_of_surjective_eq` for the uniqueness lemma.

```
   G₁.
   |  \
 f |   \ g
   |    \
   v     \⌟
   G₂----> G₃
      ∃!φ
```
 -/
def Mathlib.add_monoid_hom.lift_of_surjective {G₁ : Type u_3} {G₂ : Type u_4} {G₃ : Type u_5}
    [add_group G₁] [add_group G₂] [add_group G₃] (f : G₁ →+ G₂) (hf : function.surjective ⇑f)
    (g : G₁ →+ G₃) (hg : add_monoid_hom.ker f ≤ add_monoid_hom.ker g) : G₂ →+ G₃ :=
  add_monoid_hom.mk (fun (b : G₂) => coe_fn g (classical.some (hf b))) sorry sorry

@[simp] theorem lift_of_surjective_comp_apply {G₁ : Type u_3} {G₂ : Type u_4} {G₃ : Type u_5}
    [group G₁] [group G₂] [group G₃] (f : G₁ →* G₂) (hf : function.surjective ⇑f) (g : G₁ →* G₃)
    (hg : ker f ≤ ker g) (x : G₁) :
    coe_fn (lift_of_surjective f hf g hg) (coe_fn f x) = coe_fn g x :=
  sorry

@[simp] theorem Mathlib.add_monoid_hom.lift_of_surjective_comp {G₁ : Type u_3} {G₂ : Type u_4}
    {G₃ : Type u_5} [add_group G₁] [add_group G₂] [add_group G₃] (f : G₁ →+ G₂)
    (hf : function.surjective ⇑f) (g : G₁ →+ G₃)
    (hg : add_monoid_hom.ker f ≤ add_monoid_hom.ker g) :
    add_monoid_hom.comp (add_monoid_hom.lift_of_surjective f hf g hg) f = g :=
  sorry

theorem eq_lift_of_surjective {G₁ : Type u_3} {G₂ : Type u_4} {G₃ : Type u_5} [group G₁] [group G₂]
    [group G₃] (f : G₁ →* G₂) (hf : function.surjective ⇑f) (g : G₁ →* G₃) (hg : ker f ≤ ker g)
    (h : G₂ →* G₃) (hh : comp h f = g) : h = lift_of_surjective f hf g hg :=
  sorry

end monoid_hom


-- Here `H.normal` is an explicit argument so we can use dot notation with `comap`.

theorem subgroup.normal.comap {G : Type u_1} [group G] {N : Type u_3} [group N] {H : subgroup N}
    (hH : subgroup.normal H) (f : G →* N) : subgroup.normal (subgroup.comap f H) :=
  sorry

protected instance add_subgroup.normal_comap {G : Type u_1} [add_group G] {N : Type u_3}
    [add_group N] {H : add_subgroup N} [nH : add_subgroup.normal H] (f : G →+ N) :
    add_subgroup.normal (add_subgroup.comap f H) :=
  add_subgroup.normal.comap nH f

protected instance monoid_hom.normal_ker {G : Type u_1} [group G] {N : Type u_3} [group N]
    (f : G →* N) : subgroup.normal (monoid_hom.ker f) :=
  eq.mpr
    (id
      (Eq._oldrec (Eq.refl (subgroup.normal (monoid_hom.ker f)))
        (monoid_hom.ker.equations._eqn_1 f)))
    (subgroup.normal_comap f)

namespace subgroup


/-- The subgroup generated by an element. -/
def gpowers {G : Type u_1} [group G] (g : G) : subgroup G :=
  subgroup.copy (monoid_hom.range (coe_fn (gpowers_hom G) g)) (set.range (pow g)) sorry

@[simp] theorem mem_gpowers {G : Type u_1} [group G] (g : G) : g ∈ gpowers g :=
  Exists.intro 1 (gpow_one g)

theorem gpowers_eq_closure {G : Type u_1} [group G] (g : G) : gpowers g = closure (singleton g) :=
  ext fun (x : G) => iff.symm mem_closure_singleton

@[simp] theorem range_gpowers_hom {G : Type u_1} [group G] (g : G) :
    monoid_hom.range (coe_fn (gpowers_hom G) g) = gpowers g :=
  rfl

theorem gpowers_subset {G : Type u_1} [group G] {a : G} {K : subgroup G} (h : a ∈ K) :
    gpowers a ≤ K :=
  sorry

end subgroup


namespace add_subgroup


/-- The subgroup generated by an element. -/
def gmultiples {A : Type u_2} [add_group A] (a : A) : add_subgroup A :=
  add_subgroup.copy (add_monoid_hom.range (coe_fn (gmultiples_hom A) a))
    (set.range fun (_x : ℤ) => _x •ℤ a) sorry

@[simp] theorem mem_gmultiples {A : Type u_2} [add_group A] (a : A) : a ∈ gmultiples a :=
  Exists.intro 1 (one_gsmul a)

theorem gmultiples_eq_closure {A : Type u_2} [add_group A] (a : A) :
    gmultiples a = closure (singleton a) :=
  ext fun (x : A) => iff.symm mem_closure_singleton

@[simp] theorem range_gmultiples_hom {A : Type u_2} [add_group A] (a : A) :
    add_monoid_hom.range (coe_fn (gmultiples_hom A) a) = gmultiples a :=
  rfl

theorem gmultiples_subset {A : Type u_2} [add_group A] {a : A} {B : add_subgroup A} (h : a ∈ B) :
    gmultiples a ≤ B :=
  subgroup.gpowers_subset h

end add_subgroup


namespace mul_equiv


/-- Makes the identity isomorphism from a proof two subgroups of a multiplicative
    group are equal. -/
def subgroup_congr {G : Type u_1} [group G] {H : subgroup G} {K : subgroup G} (h : H = K) :
    ↥H ≃* ↥K :=
  mk (equiv.to_fun (equiv.set_congr sorry)) (equiv.inv_fun (equiv.set_congr sorry)) sorry sorry
    sorry

end mul_equiv


-- TODO : ↥(⊤ : subgroup H) ≃* H ?

namespace subgroup


theorem Mathlib.add_subgroup.mem_sup {C : Type u_4} [add_comm_group C] {s : add_subgroup C}
    {t : add_subgroup C} {x : C} :
    x ∈ s ⊔ t ↔ ∃ (y : C), ∃ (H : y ∈ s), ∃ (z : C), ∃ (H : z ∈ t), y + z = x :=
  sorry

theorem Mathlib.add_subgroup.mem_sup' {C : Type u_4} [add_comm_group C] {s : add_subgroup C}
    {t : add_subgroup C} {x : C} : x ∈ s ⊔ t ↔ ∃ (y : ↥s), ∃ (z : ↥t), ↑y + ↑z = x :=
  sorry

protected instance Mathlib.add_subgroup.is_modular_lattice {C : Type u_4} [add_comm_group C] :
    is_modular_lattice (add_subgroup C) :=
  sorry

end Mathlib