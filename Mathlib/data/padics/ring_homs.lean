/-
Copyright (c) 2020 Johan Commelin and Robert Y. Lewis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin and Robert Y. Lewis
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.data.padics.padic_integers
import Mathlib.PostPort

universes u_1 

namespace Mathlib

/-!

# Relating `ℤ_[p]` to `zmod (p ^ n)`

In this file we establish connections between the `p`-adic integers $\mathbb{Z}_p$
and the integers modulo powers of `p`, $\mathbb{Z}/p^n\mathbb{Z}$.

## Main declarations

We show that $\mathbb{Z}_p$ has a ring hom to $\mathbb{Z}/p^n\mathbb{Z}$ for each `n`.
The case for `n = 1` is handled separately, since it is used in the general construction
and we may want to use it without the `^1` getting in the way.
* `padic_int.to_zmod`: ring hom to `zmod p`
* `padic_int.to_zmod_pow`: ring hom to `zmod (p^n)`
* `padic_int.ker_to_zmod` / `padic_int.ker_to_zmod_pow`: the kernels of these maps are the ideals
  generated by `p^n`

We also establish the universal property of $\mathbb{Z}_p$ as a projective limit.
Given a family of compatible ring homs $f_k : R \to \mathbb{Z}/p^n\mathbb{Z}$,
there is a unique limit $R \to \mathbb{Z}_p$.
* `padic_int.lift`: the limit function
* `padic_int.lift_spec` / `padic_int.lift_unique`: the universal property

## Implementation notes

The ring hom constructions go through an auxiliary constructor `padic_int.to_zmod_hom`,
which removes some boilerplate code.

-/

namespace padic_int


/-! ### Ring homomorphisms to `zmod p` and `zmod (p ^ n)` -/

/--
`mod_part p r` is an integer that satisfies
`∥(r - mod_part p r : ℚ_[p])∥ < 1` when `∥(r : ℚ_[p])∥ ≤ 1`,
see `padic_int.norm_sub_mod_part`.
It is the unique non-negative integer that is `< p` with this property.

(Note that this definition assumes `r : ℚ`.
See `padic_int.zmod_repr` for a version that takes values in `ℕ`
and works for arbitrary `x : ℤ_[p]`.) -/
def mod_part (p : ℕ) (r : ℚ) : ℤ :=
  rat.num r * nat.gcd_a (rat.denom r) p % ↑p

theorem mod_part_lt_p {p : ℕ} [hp_prime : fact (nat.prime p)] (r : ℚ) : mod_part p r < ↑p := sorry

theorem mod_part_nonneg {p : ℕ} [hp_prime : fact (nat.prime p)] (r : ℚ) : 0 ≤ mod_part p r := sorry

theorem is_unit_denom {p : ℕ} [hp_prime : fact (nat.prime p)] (r : ℚ) (h : norm ↑r ≤ 1) : is_unit ↑(rat.denom r) := sorry

theorem norm_sub_mod_part_aux {p : ℕ} [hp_prime : fact (nat.prime p)] (r : ℚ) (h : norm ↑r ≤ 1) : ↑p ∣ rat.num r - rat.num r * nat.gcd_a (rat.denom r) p % ↑p * ↑(rat.denom r) := sorry

theorem norm_sub_mod_part {p : ℕ} [hp_prime : fact (nat.prime p)] (r : ℚ) (h : norm ↑r ≤ 1) : norm ({ val := ↑r, property := h } - ↑(mod_part p r)) < 1 := sorry

theorem exists_mem_range_of_norm_rat_le_one {p : ℕ} [hp_prime : fact (nat.prime p)] (r : ℚ) (h : norm ↑r ≤ 1) : ∃ (n : ℤ), 0 ≤ n ∧ n < ↑p ∧ norm ({ val := ↑r, property := h } - ↑n) < 1 :=
  Exists.intro (mod_part p r)
    { left := mod_part_nonneg r, right := { left := mod_part_lt_p r, right := norm_sub_mod_part r h } }

theorem zmod_congr_of_sub_mem_span_aux {p : ℕ} [hp_prime : fact (nat.prime p)] (n : ℕ) (x : padic_int p) (a : ℤ) (b : ℤ) (ha : x - ↑a ∈ ideal.span (singleton (↑p ^ n))) (hb : x - ↑b ∈ ideal.span (singleton (↑p ^ n))) : ↑a = ↑b := sorry

theorem zmod_congr_of_sub_mem_span {p : ℕ} [hp_prime : fact (nat.prime p)] (n : ℕ) (x : padic_int p) (a : ℕ) (b : ℕ) (ha : x - ↑a ∈ ideal.span (singleton (↑p ^ n))) (hb : x - ↑b ∈ ideal.span (singleton (↑p ^ n))) : ↑a = ↑b :=
  zmod_congr_of_sub_mem_span_aux n x (↑a) (↑b) ha hb

theorem zmod_congr_of_sub_mem_max_ideal {p : ℕ} [hp_prime : fact (nat.prime p)] (x : padic_int p) (m : ℕ) (n : ℕ) (hm : x - ↑m ∈ local_ring.maximal_ideal (padic_int p)) (hn : x - ↑n ∈ local_ring.maximal_ideal (padic_int p)) : ↑m = ↑n := sorry

theorem exists_mem_range {p : ℕ} [hp_prime : fact (nat.prime p)] (x : padic_int p) : ∃ (n : ℕ), n < p ∧ x - ↑n ∈ local_ring.maximal_ideal (padic_int p) := sorry

/--
`zmod_repr x` is the unique natural number smaller than `p`
satisfying `∥(x - zmod_repr x : ℤ_[p])∥ < 1`.
-/
def zmod_repr {p : ℕ} [hp_prime : fact (nat.prime p)] (x : padic_int p) : ℕ :=
  classical.some (exists_mem_range x)

theorem zmod_repr_spec {p : ℕ} [hp_prime : fact (nat.prime p)] (x : padic_int p) : zmod_repr x < p ∧ x - ↑(zmod_repr x) ∈ local_ring.maximal_ideal (padic_int p) :=
  classical.some_spec (exists_mem_range x)

theorem zmod_repr_lt_p {p : ℕ} [hp_prime : fact (nat.prime p)] (x : padic_int p) : zmod_repr x < p :=
  and.left (zmod_repr_spec x)

theorem sub_zmod_repr_mem {p : ℕ} [hp_prime : fact (nat.prime p)] (x : padic_int p) : x - ↑(zmod_repr x) ∈ local_ring.maximal_ideal (padic_int p) :=
  and.right (zmod_repr_spec x)

/--
`to_zmod_hom` is an auxiliary constructor for creating ring homs from `ℤ_[p]` to `zmod v`.
-/
def to_zmod_hom {p : ℕ} [hp_prime : fact (nat.prime p)] (v : ℕ) (f : padic_int p → ℕ) (f_spec : ∀ (x : padic_int p), x - ↑(f x) ∈ ideal.span (singleton ↑v)) (f_congr : ∀ (x : padic_int p) (a b : ℕ), x - ↑a ∈ ideal.span (singleton ↑v) → x - ↑b ∈ ideal.span (singleton ↑v) → ↑a = ↑b) : padic_int p →+* zmod v :=
  ring_hom.mk (fun (x : padic_int p) => ↑(f x)) sorry sorry sorry sorry

/--
`to_zmod` is a ring hom from `ℤ_[p]` to `zmod p`,
with the equality `to_zmod x = (zmod_repr x : zmod p)`.
-/
def to_zmod {p : ℕ} [hp_prime : fact (nat.prime p)] : padic_int p →+* zmod p :=
  to_zmod_hom p zmod_repr sorry sorry

/--
`z - (to_zmod z : ℤ_[p])` is contained in the maximal ideal of `ℤ_[p]`, for every `z : ℤ_[p]`.

The coercion from `zmod p` to `ℤ_[p]` is `zmod.has_coe_t`,
which coerces `zmod p` into artibrary rings.
This is unfortunate, but a consequence of the fact that we allow `zmod p`
to coerce to rings of arbitrary characteristic, instead of only rings of characteristic `p`.
This coercion is only a ring homomorphism if it coerces into a ring whose characteristic divides
`p`. While this is not the case here we can still make use of the coercion.
-/
theorem to_zmod_spec {p : ℕ} [hp_prime : fact (nat.prime p)] (z : padic_int p) : z - ↑(coe_fn to_zmod z) ∈ local_ring.maximal_ideal (padic_int p) := sorry

theorem ker_to_zmod {p : ℕ} [hp_prime : fact (nat.prime p)] : ring_hom.ker to_zmod = local_ring.maximal_ideal (padic_int p) := sorry

/-- `appr n x` gives a value `v : ℕ` such that `x` and `↑v : ℤ_p` are congruent mod `p^n`.
See `appr_spec`. -/
def appr {p : ℕ} [hp_prime : fact (nat.prime p)] : padic_int p → ℕ → ℕ :=
  sorry

theorem appr_lt {p : ℕ} [hp_prime : fact (nat.prime p)] (x : padic_int p) (n : ℕ) : appr x n < p ^ n := sorry

theorem appr_mono {p : ℕ} [hp_prime : fact (nat.prime p)] (x : padic_int p) : monotone (appr x) := sorry

theorem dvd_appr_sub_appr {p : ℕ} [hp_prime : fact (nat.prime p)] (x : padic_int p) (m : ℕ) (n : ℕ) (h : m ≤ n) : p ^ m ∣ appr x n - appr x m := sorry

theorem appr_spec {p : ℕ} [hp_prime : fact (nat.prime p)] (n : ℕ) (x : padic_int p) : x - ↑(appr x n) ∈ ideal.span (singleton (↑p ^ n)) := sorry

/-- A ring hom from `ℤ_[p]` to `zmod (p^n)`, with underlying function `padic_int.appr n`. -/
def to_zmod_pow {p : ℕ} [hp_prime : fact (nat.prime p)] (n : ℕ) : padic_int p →+* zmod (p ^ n) :=
  to_zmod_hom (p ^ n) (fun (x : padic_int p) => appr x n) sorry sorry

theorem ker_to_zmod_pow {p : ℕ} [hp_prime : fact (nat.prime p)] (n : ℕ) : ring_hom.ker (to_zmod_pow n) = ideal.span (singleton (↑p ^ n)) := sorry

@[simp] theorem zmod_cast_comp_to_zmod_pow {p : ℕ} [hp_prime : fact (nat.prime p)] (m : ℕ) (n : ℕ) (h : m ≤ n) : ring_hom.comp (zmod.cast_hom (pow_dvd_pow p h) (zmod (p ^ m))) (to_zmod_pow n) = to_zmod_pow m := sorry

@[simp] theorem cast_to_zmod_pow {p : ℕ} [hp_prime : fact (nat.prime p)] (m : ℕ) (n : ℕ) (h : m ≤ n) (x : padic_int p) : ↑(coe_fn (to_zmod_pow n) x) = coe_fn (to_zmod_pow m) x := sorry

theorem dense_range_nat_cast {p : ℕ} [hp_prime : fact (nat.prime p)] : dense_range nat.cast := sorry

theorem dense_range_int_cast {p : ℕ} [hp_prime : fact (nat.prime p)] : dense_range int.cast := sorry

/-! ### Universal property as projective limit -/

/--
Given a family of ring homs `f : Π n : ℕ, R →+* zmod (p ^ n)`,
`nth_hom f r` is an integer-valued sequence
whose `n`th value is the unique integer `k` such that `0 ≤ k < p ^ n`
and `f n r = (k : zmod (p ^ n))`.
-/
def nth_hom {p : ℕ} {R : Type u_1} [comm_ring R] (f : (k : ℕ) → R →+* zmod (p ^ k)) (r : R) : ℕ → ℤ :=
  fun (n : ℕ) => ↑(zmod.val (coe_fn (f n) r))

@[simp] theorem nth_hom_zero {p : ℕ} {R : Type u_1} [comm_ring R] (f : (k : ℕ) → R →+* zmod (p ^ k)) : nth_hom f 0 = 0 := sorry

theorem pow_dvd_nth_hom_sub {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {f : (k : ℕ) → R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), ring_hom.comp (zmod.cast_hom (pow_dvd_pow p hk) (zmod (p ^ k1))) (f k2) = f k1) (r : R) (i : ℕ) (j : ℕ) (h : i ≤ j) : ↑p ^ i ∣ nth_hom f r j - nth_hom f r i := sorry

theorem is_cau_seq_nth_hom {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {f : (k : ℕ) → R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), ring_hom.comp (zmod.cast_hom (pow_dvd_pow p hk) (zmod (p ^ k1))) (f k2) = f k1) (r : R) : is_cau_seq (padic_norm p) fun (n : ℕ) => ↑(nth_hom f r n) := sorry

/--
`nth_hom_seq f_compat r` bundles `padic_int.nth_hom f r`
as a Cauchy sequence of rationals with respect to the `p`-adic norm.
The `n`th value of the sequence is `((f n r).val : ℚ)`.
-/
def nth_hom_seq {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {f : (k : ℕ) → R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), ring_hom.comp (zmod.cast_hom (pow_dvd_pow p hk) (zmod (p ^ k1))) (f k2) = f k1) (r : R) : padic_seq p :=
  { val := fun (n : ℕ) => ↑(nth_hom f r n), property := is_cau_seq_nth_hom f_compat r }

theorem nth_hom_seq_one {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {f : (k : ℕ) → R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), ring_hom.comp (zmod.cast_hom (pow_dvd_pow p hk) (zmod (p ^ k1))) (f k2) = f k1) : nth_hom_seq f_compat 1 ≈ 1 := sorry

theorem nth_hom_seq_add {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {f : (k : ℕ) → R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), ring_hom.comp (zmod.cast_hom (pow_dvd_pow p hk) (zmod (p ^ k1))) (f k2) = f k1) (r : R) (s : R) : nth_hom_seq f_compat (r + s) ≈ nth_hom_seq f_compat r + nth_hom_seq f_compat s := sorry

theorem nth_hom_seq_mul {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {f : (k : ℕ) → R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), ring_hom.comp (zmod.cast_hom (pow_dvd_pow p hk) (zmod (p ^ k1))) (f k2) = f k1) (r : R) (s : R) : nth_hom_seq f_compat (r * s) ≈ nth_hom_seq f_compat r * nth_hom_seq f_compat s := sorry

/--
`lim_nth_hom f_compat r` is the limit of a sequence `f` of compatible ring homs `R →+* zmod (p^k)`.
This is itself a ring hom: see `padic_int.lift`.
-/
def lim_nth_hom {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {f : (k : ℕ) → R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), ring_hom.comp (zmod.cast_hom (pow_dvd_pow p hk) (zmod (p ^ k1))) (f k2) = f k1) (r : R) : padic_int p :=
  of_int_seq (nth_hom f r) (is_cau_seq_nth_hom f_compat r)

theorem lim_nth_hom_spec {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {f : (k : ℕ) → R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), ring_hom.comp (zmod.cast_hom (pow_dvd_pow p hk) (zmod (p ^ k1))) (f k2) = f k1) (r : R) (ε : ℝ) : 0 < ε → ∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → norm (lim_nth_hom f_compat r - ↑(nth_hom f r n)) < ε := sorry

theorem lim_nth_hom_zero {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {f : (k : ℕ) → R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), ring_hom.comp (zmod.cast_hom (pow_dvd_pow p hk) (zmod (p ^ k1))) (f k2) = f k1) : lim_nth_hom f_compat 0 = 0 := sorry

theorem lim_nth_hom_one {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {f : (k : ℕ) → R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), ring_hom.comp (zmod.cast_hom (pow_dvd_pow p hk) (zmod (p ^ k1))) (f k2) = f k1) : lim_nth_hom f_compat 1 = 1 :=
  subtype.ext (quot.sound (nth_hom_seq_one f_compat))

theorem lim_nth_hom_add {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {f : (k : ℕ) → R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), ring_hom.comp (zmod.cast_hom (pow_dvd_pow p hk) (zmod (p ^ k1))) (f k2) = f k1) (r : R) (s : R) : lim_nth_hom f_compat (r + s) = lim_nth_hom f_compat r + lim_nth_hom f_compat s :=
  subtype.ext (quot.sound (nth_hom_seq_add f_compat r s))

theorem lim_nth_hom_mul {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {f : (k : ℕ) → R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), ring_hom.comp (zmod.cast_hom (pow_dvd_pow p hk) (zmod (p ^ k1))) (f k2) = f k1) (r : R) (s : R) : lim_nth_hom f_compat (r * s) = lim_nth_hom f_compat r * lim_nth_hom f_compat s :=
  subtype.ext (quot.sound (nth_hom_seq_mul f_compat r s))

-- TODO: generalize this to arbitrary complete discrete valuation rings

/--
`lift f_compat` is the limit of a sequence `f` of compatible ring homs `R →+* zmod (p^k)`,
with the equality `lift f_compat r = padic_int.lim_nth_hom f_compat r`.
-/
def lift {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {f : (k : ℕ) → R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), ring_hom.comp (zmod.cast_hom (pow_dvd_pow p hk) (zmod (p ^ k1))) (f k2) = f k1) : R →+* padic_int p :=
  ring_hom.mk (lim_nth_hom f_compat) sorry sorry sorry sorry

theorem lift_sub_val_mem_span {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {f : (k : ℕ) → R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), ring_hom.comp (zmod.cast_hom (pow_dvd_pow p hk) (zmod (p ^ k1))) (f k2) = f k1) (r : R) (n : ℕ) : coe_fn (lift f_compat) r - ↑(zmod.val (coe_fn (f n) r)) ∈ ideal.span (singleton (↑p ^ n)) := sorry

/--
One part of the universal property of `ℤ_[p]` as a projective limit.
See also `padic_int.lift_unique`.
-/
theorem lift_spec {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {f : (k : ℕ) → R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), ring_hom.comp (zmod.cast_hom (pow_dvd_pow p hk) (zmod (p ^ k1))) (f k2) = f k1) (n : ℕ) : ring_hom.comp (to_zmod_pow n) (lift f_compat) = f n := sorry

/--
One part of the universal property of `ℤ_[p]` as a projective limit.
See also `padic_int.lift_spec`.
-/
theorem lift_unique {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {f : (k : ℕ) → R →+* zmod (p ^ k)} (f_compat : ∀ (k1 k2 : ℕ) (hk : k1 ≤ k2), ring_hom.comp (zmod.cast_hom (pow_dvd_pow p hk) (zmod (p ^ k1))) (f k2) = f k1) (g : R →+* padic_int p) (hg : ∀ (n : ℕ), ring_hom.comp (to_zmod_pow n) g = f n) : lift f_compat = g := sorry

@[simp] theorem lift_self {p : ℕ} [hp_prime : fact (nat.prime p)] (z : padic_int p) : coe_fn (lift zmod_cast_comp_to_zmod_pow) z = z := sorry

theorem ext_of_to_zmod_pow {p : ℕ} [hp_prime : fact (nat.prime p)] {x : padic_int p} {y : padic_int p} : (∀ (n : ℕ), coe_fn (to_zmod_pow n) x = coe_fn (to_zmod_pow n) y) ↔ x = y := sorry

theorem to_zmod_pow_eq_iff_ext {p : ℕ} [hp_prime : fact (nat.prime p)] {R : Type u_1} [comm_ring R] {g : R →+* padic_int p} {g' : R →+* padic_int p} : (∀ (n : ℕ), ring_hom.comp (to_zmod_pow n) g = ring_hom.comp (to_zmod_pow n) g') ↔ g = g' := sorry

