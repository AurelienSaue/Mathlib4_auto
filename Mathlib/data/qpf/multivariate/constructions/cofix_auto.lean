/-
Copyright (c) 2018 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: Jeremy Avigad, Simon Hudon
-/
import PrePort
import Lean3Lib.init.default
import Mathlib.control.functor.multivariate
import Mathlib.data.pfunctor.multivariate.basic
import Mathlib.data.pfunctor.multivariate.M
import Mathlib.data.qpf.multivariate.basic
import PostPort

universes u u_1 

namespace Mathlib

/-!
# The final co-algebra of a multivariate qpf is again a qpf.

For a `(n+1)`-ary QPF `F (α₀,..,αₙ)`, we take the least fixed point of `F` with
regards to its last argument `αₙ`. The result is a `n`-ary functor: `fix F (α₀,..,αₙ₋₁)`.
Making `fix F` into a functor allows us to take the fixed point, compose with other functors
and take a fixed point again.

## Main definitions

 * `cofix.mk`     - constructor
 * `cofix.dest    - destructor
 * `cofix.corec`  - corecursor: useful for formulating infinite, productive computations
 * `cofix.bisim`  - bisimulation: proof technique to show the equality of possibly infinite values
                    of `cofix F α`

## Implementation notes

For `F` a QPF`, we define `cofix F α` in terms of the M-type of the polynomial functor `P` of `F`.
We define the relation `Mcongr` and take its quotient as the definition of `cofix F α`.

`Mcongr` is taken as the weakest bisimulation on M-type.  See
[avigad-carneiro-hudon2019] for more details.

## Reference

 * [Jeremy Avigad, Mario M. Carneiro and Simon Hudon, *Data Types as Quotients of Polynomial Functors*][avigad-carneiro-hudon2019]
-/

namespace mvqpf


/-- `corecF` is used as a basis for defining the corecursor of `cofix F α`. `corecF`
uses corecursion to construct the M-type generated by `q.P` and uses function on `F`
as a corecursive step -/
def corecF {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} {β : Type u} (g : β → F (α ::: β)) : β → mvpfunctor.M (P F) α :=
  mvpfunctor.M.corec (P F) fun (x : β) => repr (g x)

theorem corecF_eq {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} {β : Type u} (g : β → F (α ::: β)) (x : β) : mvpfunctor.M.dest (P F) (corecF g x) = mvfunctor.map (typevec.id ::: corecF g) (repr (g x)) := sorry

/-- Characterization of desirable equivalence relations on M-types -/
def is_precongr {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} (r : mvpfunctor.M (P F) α → mvpfunctor.M (P F) α → Prop)  :=
  ∀ {x y : mvpfunctor.M (P F) α},
    r x y →
      abs (mvfunctor.map (typevec.id ::: Quot.mk r) (mvpfunctor.M.dest (P F) x)) =
        abs (mvfunctor.map (typevec.id ::: Quot.mk r) (mvpfunctor.M.dest (P F) y))

/-- Equivalence relation on M-types representing a value of type `cofix F` -/
def Mcongr {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} (x : mvpfunctor.M (P F) α) (y : mvpfunctor.M (P F) α)  :=
  ∃ (r : mvpfunctor.M (P F) α → mvpfunctor.M (P F) α → Prop), is_precongr r ∧ r x y

/-- Greatest fixed point of functor F. The result is a functor with one fewer parameters
than the input. For `F a b c` a ternary functor, fix F is a binary functor such that

```lean
cofix F a b = F a b (cofix F a b)
```
-/
def cofix {n : ℕ} (F : typevec (n + 1) → Type u) [mvfunctor F] [q : mvqpf F] (α : typevec n)  :=
  Quot Mcongr

protected instance cofix.inhabited {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} [Inhabited (mvpfunctor.A (P F))] [(i : fin2 n) → Inhabited (α i)] : Inhabited (cofix F α) :=
  { default := Quot.mk Mcongr Inhabited.default }

/-- maps every element of the W type to a canonical representative -/
def Mrepr {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} : mvpfunctor.M (P F) α → mvpfunctor.M (P F) α :=
  corecF (abs ∘ mvpfunctor.M.dest (P F))

/-- the map function for the functor `cofix F` -/
def cofix.map {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} {β : typevec n} (g : typevec.arrow α β) : cofix F α → cofix F β :=
  Quot.lift (fun (x : mvpfunctor.M (P F) α) => Quot.mk Mcongr (mvfunctor.map g x)) sorry

protected instance cofix.mvfunctor {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] : mvfunctor (cofix F) :=
  mvfunctor.mk cofix.map

/-- Corecursor for `cofix F` -/
def cofix.corec {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} {β : Type u} (g : β → F (α ::: β)) : β → cofix F α :=
  fun (x : β) => Quot.mk Mcongr (corecF g x)

/-- Destructor for `cofix F` -/
def cofix.dest {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} : cofix F α → F (α ::: cofix F α) :=
  Quot.lift
    (fun (x : mvpfunctor.M (P F) α) => mvfunctor.map (typevec.id ::: Quot.mk Mcongr) (abs (mvpfunctor.M.dest (P F) x)))
    sorry

/-- Abstraction function for `cofix F α` -/
def cofix.abs {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} : mvpfunctor.M (P F) α → cofix F α :=
  Quot.mk Mcongr

/-- Representation function for `cofix F α` -/
def cofix.repr {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} : cofix F α → mvpfunctor.M (P F) α :=
  mvpfunctor.M.corec (P F) (repr ∘ cofix.dest)

/-- Corecursor for `cofix F` -/
def cofix.corec'₁ {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} {β : Type u} (g : {X : Type u} → (β → X) → F (α ::: X)) (x : β) : cofix F α :=
  cofix.corec (fun (x : β) => g id) x

/-- More flexible corecursor for `cofix F`. Allows the return of a fully formed
value instead of making a recursive call -/
def cofix.corec' {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} {β : Type u} (g : β → F (α ::: (cofix F α ⊕ β))) (x : β) : cofix F α :=
  let f : typevec.arrow (α ::: cofix F α) (α ::: (cofix F α ⊕ β)) := typevec.id ::: sum.inl;
  cofix.corec (sum.elim (mvfunctor.map f ∘ cofix.dest) g) (sum.inr x)

/-- Corecursor for `cofix F`. The shape allows recursive calls to
look like recursive calls. -/
def cofix.corec₁ {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} {β : Type u} (g : {X : Type u} → (cofix F α → X) → (β → X) → β → F (α ::: X)) (x : β) : cofix F α :=
  cofix.corec' (fun (x : β) => g sum.inl sum.inr x) x

theorem cofix.dest_corec {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} {β : Type u} (g : β → F (α ::: β)) (x : β) : cofix.dest (cofix.corec g x) = mvfunctor.map (typevec.id ::: cofix.corec g) (g x) := sorry

/-- constructor for `cofix F` -/
def cofix.mk {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} : F (α ::: cofix F α) → cofix F α :=
  cofix.corec fun (x : F (α ::: cofix F α)) => mvfunctor.map (typevec.id ::: fun (i : cofix F α) => cofix.dest i) x

/-!
## Bisimulation principles for `cofix F`

The following theorems are bisimulation principles. The general idea
is to use a bisimulation relation to prove the equality between
specific values of type `cofix F α`.

A bisimulation relation `R` for values `x y : cofix F α`:

 * holds for `x y`: `R x y`
 * for any values `x y` that satisfy `R`, their root has the same shape
   and their children can be paired in such a way that they satisfy `R`.

-/

/-- Bisimulation principle using `map` and `quot.mk` to match and relate children of two trees. -/
theorem cofix.bisim_rel {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} (r : cofix F α → cofix F α → Prop) (h : ∀ (x y : cofix F α),
  r x y →
    mvfunctor.map (typevec.id ::: Quot.mk r) (cofix.dest x) = mvfunctor.map (typevec.id ::: Quot.mk r) (cofix.dest y)) (x : cofix F α) (y : cofix F α) : r x y → x = y := sorry

/-- Bisimulation principle using `liftr` to match and relate children of two trees. -/
theorem cofix.bisim {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} (r : cofix F α → cofix F α → Prop) (h : ∀ (x y : cofix F α), r x y → mvfunctor.liftr (typevec.rel_last α r) (cofix.dest x) (cofix.dest y)) (x : cofix F α) (y : cofix F α) : r x y → x = y := sorry

/-- Bisimulation principle using `liftr'` to match and relate children of two trees. -/
theorem cofix.bisim₂ {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} (r : cofix F α → cofix F α → Prop) (h : ∀ (x y : cofix F α), r x y → mvfunctor.liftr' (typevec.rel_last' α r) (cofix.dest x) (cofix.dest y)) (x : cofix F α) (y : cofix F α) : r x y → x = y := sorry

/-- Bisimulation principle the values `⟨a,f⟩` of the polynomial functor representing
`cofix F α` as well as an invariant `Q : β → Prop` and a state `β` generating the
left-hand side and right-hand side of the equality through functions `u v : β → cofix F α` -/
theorem cofix.bisim' {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} {β : Type u_1} (Q : β → Prop) (u : β → cofix F α) (v : β → cofix F α) (h : ∀ (x : β),
  Q x →
    ∃ (a : mvpfunctor.A (P F)),
      ∃ (f' : typevec.arrow (mvpfunctor.B (mvpfunctor.drop (P F)) a) α),
        ∃ (f₀ : pfunctor.B (mvpfunctor.last (P F)) a → cofix F α),
          ∃ (f₁ : pfunctor.B (mvpfunctor.last (P F)) a → cofix F α),
            cofix.dest (u x) = abs (sigma.mk a (mvpfunctor.append_contents (P F) f' f₀)) ∧
              cofix.dest (v x) = abs (sigma.mk a (mvpfunctor.append_contents (P F) f' f₁)) ∧
                ∀ (i : pfunctor.B (mvpfunctor.last (P F)) a), ∃ (x' : β), Q x' ∧ f₀ i = u x' ∧ f₁ i = v x') (x : β) : Q x → u x = v x := sorry

theorem cofix.mk_dest {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} (x : cofix F α) : cofix.mk (cofix.dest x) = x := sorry

theorem cofix.dest_mk {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} (x : F (α ::: cofix F α)) : cofix.dest (cofix.mk x) = x := sorry

theorem cofix.ext {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} (x : cofix F α) (y : cofix F α) (h : cofix.dest x = cofix.dest y) : x = y :=
  eq.mpr (id (Eq._oldrec (Eq.refl (x = y)) (Eq.symm (cofix.mk_dest x))))
    (eq.mpr (id (Eq._oldrec (Eq.refl (cofix.mk (cofix.dest x) = y)) h))
      (eq.mpr (id (Eq._oldrec (Eq.refl (cofix.mk (cofix.dest y) = y)) (cofix.mk_dest y))) (Eq.refl y)))

theorem cofix.ext_mk {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} (x : F (α ::: cofix F α)) (y : F (α ::: cofix F α)) (h : cofix.mk x = cofix.mk y) : x = y :=
  eq.mpr (id (Eq._oldrec (Eq.refl (x = y)) (Eq.symm (cofix.dest_mk x))))
    (eq.mpr (id (Eq._oldrec (Eq.refl (cofix.dest (cofix.mk x) = y)) h))
      (eq.mpr (id (Eq._oldrec (Eq.refl (cofix.dest (cofix.mk y) = y)) (cofix.dest_mk y))) (Eq.refl y)))

/-!
`liftr_map`, `liftr_map_last` and `liftr_map_last'` are useful for reasoning about
the induction step in bisimulation proofs.
-/

theorem liftr_map {n : ℕ} {α : typevec n} {β : typevec n} {F' : typevec n → Type u} [mvfunctor F'] [is_lawful_mvfunctor F'] (R : typevec.arrow (typevec.prod β β) (typevec.repeat n Prop)) (x : F' α) (f : typevec.arrow α β) (g : typevec.arrow α β) (h : typevec.arrow α (typevec.subtype_ R)) (hh : typevec.comp (typevec.subtype_val R) h = typevec.comp (typevec.prod.map f g) typevec.prod.diag) : mvfunctor.liftr' R (mvfunctor.map f x) (mvfunctor.map g x) := sorry

theorem liftr_map_last {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [is_lawful_mvfunctor F] {α : typevec n} {ι : Type u} {ι' : Type u} (R : ι' → ι' → Prop) (x : F (α ::: ι)) (f : ι → ι') (g : ι → ι') (hh : ∀ (x : ι), R (f x) (g x)) : mvfunctor.liftr' (typevec.rel_last' α R) (mvfunctor.map (typevec.id ::: f) x) (mvfunctor.map (typevec.id ::: g) x) := sorry

theorem liftr_map_last' {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [is_lawful_mvfunctor F] {α : typevec n} {ι : Type u} (R : ι → ι → Prop) (x : F (α ::: ι)) (f : ι → ι) (hh : ∀ (x : ι), R (f x) x) : mvfunctor.liftr' (typevec.rel_last' α R) (mvfunctor.map (typevec.id ::: f) x) x := sorry

theorem cofix.abs_repr {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} (x : cofix F α) : Quot.mk Mcongr (cofix.repr x) = x := sorry

/-- tactic for proof by bisimulation -/
theorem corec_roll {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} {X : Type u} {Y : Type u} {x₀ : X} (f : X → Y) (g : Y → F (α ::: X)) : cofix.corec (g ∘ f) x₀ = cofix.corec (mvfunctor.map (typevec.id ::: f) ∘ g) (f x₀) := sorry

theorem cofix.dest_corec' {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} {β : Type u} (g : β → F (α ::: (cofix F α ⊕ β))) (x : β) : cofix.dest (cofix.corec' g x) = mvfunctor.map (typevec.id ::: sum.elim id (cofix.corec' g)) (g x) := sorry

theorem cofix.dest_corec₁ {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} {β : Type u} (g : {X : Type u} → (cofix F α → X) → (β → X) → β → F (α ::: X)) (x : β) (h : ∀ (X Y : Type u) (f : cofix F α → X) (f' : β → X) (k : X → Y),
  g (k ∘ f) (k ∘ f') x = mvfunctor.map (typevec.id ::: k) (g f f' x)) : cofix.dest (cofix.corec₁ g x) = g id (cofix.corec₁ g) x := sorry

protected instance mvqpf_cofix {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] : mvqpf (cofix F) :=
  mk (mvpfunctor.Mp (P F)) (fun (α : typevec n) => Quot.mk Mcongr) (fun (α : typevec n) => cofix.repr) sorry sorry

