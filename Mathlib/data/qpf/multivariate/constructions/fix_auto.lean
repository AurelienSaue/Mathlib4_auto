/-
Copyright (c) 2018 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: Jeremy Avigad, Simon Hudon
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.data.pfunctor.multivariate.W
import Mathlib.data.qpf.multivariate.basic
import Mathlib.PostPort

universes u u_1 

namespace Mathlib

/-!
# The initial algebra of a multivariate qpf is again a qpf.

For a `(n+1)`-ary QPF `F (α₀,..,αₙ)`, we take the least fixed point of `F` with
regards to its last argument `αₙ`. The result is a `n`-ary functor: `fix F (α₀,..,αₙ₋₁)`.
Making `fix F` into a functor allows us to take the fixed point, compose with other functors
and take a fixed point again.

## Main definitions

 * `fix.mk`     - constructor
 * `fix.dest    - destructor
 * `fix.rec`    - recursor: basis for defining functions by structural recursion on `fix F α`
 * `fix.drec`   - dependent recursor: generalization of `fix.rec` where the result type of the function
                  is allowed to dependent on the `fix F α` value
 * `fix.rec_eq` - defining equation for `recursor`
 * `fix.ind`    - induction principle for `fix F α`

## Implementation notes

For `F` a QPF`, we define `fix F α` in terms of the W-type of the polynomial functor `P` of `F`.
We define the relation `Wequiv` and take its quotient as the definition of `fix F α`.

```lean
inductive Wequiv {α : typevec n} : q.P.W α → q.P.W α → Prop
| ind (a : q.P.A) (f' : q.P.drop.B a ⟹ α) (f₀ f₁ : q.P.last.B a → q.P.W α) :
    (∀ x, Wequiv (f₀ x) (f₁ x)) → Wequiv (q.P.W_mk a f' f₀) (q.P.W_mk a f' f₁)
| abs (a₀ : q.P.A) (f'₀ : q.P.drop.B a₀ ⟹ α) (f₀ : q.P.last.B a₀ → q.P.W α)
      (a₁ : q.P.A) (f'₁ : q.P.drop.B a₁ ⟹ α) (f₁ : q.P.last.B a₁ → q.P.W α) :
      abs ⟨a₀, q.P.append_contents f'₀ f₀⟩ = abs ⟨a₁, q.P.append_contents f'₁ f₁⟩ →
        Wequiv (q.P.W_mk a₀ f'₀ f₀) (q.P.W_mk a₁ f'₁ f₁)
| trans (u v w : q.P.W α) : Wequiv u v → Wequiv v w → Wequiv u w
```

See [avigad-carneiro-hudon2019] for more details.

## Reference

 * [Jeremy Avigad, Mario M. Carneiro and Simon Hudon, *Data Types as Quotients of Polynomial Functors*][avigad-carneiro-hudon2019]
-/

namespace mvqpf


/-- `recF` is used as a basis for defining the recursor on `fix F α`. `recF`
traverses recursively the W-type generated by `q.P` using a function on `F`
as a recursive step -/
def recF {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n}
    {β : Type u} (g : F (α ::: β) → β) : mvpfunctor.W (P F) α → β :=
  mvpfunctor.W_rec (P F)
    fun (a : mvpfunctor.A (P F)) (f' : typevec.arrow (mvpfunctor.B (mvpfunctor.drop (P F)) a) α)
      (f : pfunctor.B (mvpfunctor.last (P F)) a → mvpfunctor.W (P F) α)
      (rec : pfunctor.B (mvpfunctor.last (P F)) a → β) =>
      g (abs (sigma.mk a (typevec.split_fun f' rec)))

theorem recF_eq {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n}
    {β : Type u} (g : F (α ::: β) → β) (a : mvpfunctor.A (P F))
    (f' : typevec.arrow (mvpfunctor.B (mvpfunctor.drop (P F)) a) α)
    (f : pfunctor.B (mvpfunctor.last (P F)) a → mvpfunctor.W (P F) α) :
    recF g (mvpfunctor.W_mk (P F) a f' f) =
        g (abs (sigma.mk a (typevec.split_fun f' (recF g ∘ f)))) :=
  sorry

theorem recF_eq' {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n}
    {β : Type u} (g : F (α ::: β) → β) (x : mvpfunctor.W (P F) α) :
    recF g x = g (abs (mvfunctor.map (typevec.id ::: recF g) (mvpfunctor.W_dest' (P F) x))) :=
  sorry

/-- Equivalence relation on W-types that represent the same `fix F`
value -/
inductive Wequiv {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F]
    {α : typevec n} : mvpfunctor.W (P F) α → mvpfunctor.W (P F) α → Prop
    where
| ind :
    ∀ (a : mvpfunctor.A (P F)) (f' : typevec.arrow (mvpfunctor.B (mvpfunctor.drop (P F)) a) α)
      (f₀ f₁ : pfunctor.B (mvpfunctor.last (P F)) a → mvpfunctor.W (P F) α),
      (∀ (x : pfunctor.B (mvpfunctor.last (P F)) a), Wequiv (f₀ x) (f₁ x)) →
        Wequiv (mvpfunctor.W_mk (P F) a f' f₀) (mvpfunctor.W_mk (P F) a f' f₁)
| abs :
    ∀ (a₀ : mvpfunctor.A (P F)) (f'₀ : typevec.arrow (mvpfunctor.B (mvpfunctor.drop (P F)) a₀) α)
      (f₀ : pfunctor.B (mvpfunctor.last (P F)) a₀ → mvpfunctor.W (P F) α) (a₁ : mvpfunctor.A (P F))
      (f'₁ : typevec.arrow (mvpfunctor.B (mvpfunctor.drop (P F)) a₁) α)
      (f₁ : pfunctor.B (mvpfunctor.last (P F)) a₁ → mvpfunctor.W (P F) α),
      abs (sigma.mk a₀ (mvpfunctor.append_contents (P F) f'₀ f₀)) =
          abs (sigma.mk a₁ (mvpfunctor.append_contents (P F) f'₁ f₁)) →
        Wequiv (mvpfunctor.W_mk (P F) a₀ f'₀ f₀) (mvpfunctor.W_mk (P F) a₁ f'₁ f₁)
| trans : ∀ (u v w : mvpfunctor.W (P F) α), Wequiv u v → Wequiv v w → Wequiv u w

theorem recF_eq_of_Wequiv {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F]
    (α : typevec n) {β : Type u} (u : F (α ::: β) → β) (x : mvpfunctor.W (P F) α)
    (y : mvpfunctor.W (P F) α) : Wequiv x y → recF u x = recF u y :=
  sorry

theorem Wequiv.abs' {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F]
    {α : typevec n} (x : mvpfunctor.W (P F) α) (y : mvpfunctor.W (P F) α)
    (h : abs (mvpfunctor.W_dest' (P F) x) = abs (mvpfunctor.W_dest' (P F) y)) : Wequiv x y :=
  sorry

theorem Wequiv.refl {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F]
    {α : typevec n} (x : mvpfunctor.W (P F) α) : Wequiv x x :=
  sorry

theorem Wequiv.symm {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F]
    {α : typevec n} (x : mvpfunctor.W (P F) α) (y : mvpfunctor.W (P F) α) :
    Wequiv x y → Wequiv y x :=
  sorry

/-- maps every element of the W type to a canonical representative -/
def Wrepr {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} :
    mvpfunctor.W (P F) α → mvpfunctor.W (P F) α :=
  recF (mvpfunctor.W_mk' (P F) ∘ repr)

theorem Wrepr_W_mk {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F]
    {α : typevec n} (a : mvpfunctor.A (P F))
    (f' : typevec.arrow (mvpfunctor.B (mvpfunctor.drop (P F)) a) α)
    (f : pfunctor.B (mvpfunctor.last (P F)) a → mvpfunctor.W (P F) α) :
    Wrepr (mvpfunctor.W_mk (P F) a f' f) =
        mvpfunctor.W_mk' (P F)
          (repr
            (abs
              (mvfunctor.map (typevec.id ::: Wrepr)
                (sigma.mk a (mvpfunctor.append_contents (P F) f' f))))) :=
  sorry

theorem Wrepr_equiv {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F]
    {α : typevec n} (x : mvpfunctor.W (P F) α) : Wequiv (Wrepr x) x :=
  sorry

theorem Wequiv_map {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F]
    {α : typevec n} {β : typevec n} (g : typevec.arrow α β) (x : mvpfunctor.W (P F) α)
    (y : mvpfunctor.W (P F) α) : Wequiv x y → Wequiv (mvfunctor.map g x) (mvfunctor.map g y) :=
  sorry

/--
Define the fixed point as the quotient of trees under the equivalence relation.
-/
def W_setoid {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] (α : typevec n) :
    setoid (mvpfunctor.W (P F) α) :=
  setoid.mk Wequiv sorry

/-- Least fixed point of functor F. The result is a functor with one fewer parameters
than the input. For `F a b c` a ternary functor, fix F is a binary functor such that

```lean
fix F a b = F a b (fix F a b)
```
-/
def fix {n : ℕ} (F : typevec (n + 1) → Type u_1) [mvfunctor F] [q : mvqpf F] (α : typevec n) :=
  quotient (W_setoid α)

/-- `fix F` is a functor -/
def fix.map {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n}
    {β : typevec n} (g : typevec.arrow α β) : fix F α → fix F β :=
  quotient.lift (fun (x : mvpfunctor.W (P F) α) => quotient.mk (mvpfunctor.W_map (P F) g x)) sorry

protected instance fix.mvfunctor {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F]
    [q : mvqpf F] : mvfunctor (fix F) :=
  mvfunctor.mk fix.map

/-- Recursor for `fix F` -/
def fix.rec {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n}
    {β : Type u} (g : F (α ::: β) → β) : fix F α → β :=
  Quot.lift (recF g) (recF_eq_of_Wequiv α g)

/-- Access W-type underlying `fix F`  -/
def fix_to_W {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} :
    fix F α → mvpfunctor.W (P F) α :=
  quotient.lift Wrepr sorry

/-- Constructor for `fix F` -/
def fix.mk {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n}
    (x : F (α ::: fix F α)) : fix F α :=
  Quot.mk setoid.r (mvpfunctor.W_mk' (P F) (mvfunctor.map (typevec.id ::: fix_to_W) (repr x)))

/-- Destructor for `fix F` -/
def fix.dest {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n} :
    fix F α → F (α ::: fix F α) :=
  fix.rec (mvfunctor.map (typevec.id ::: fix.mk))

theorem fix.rec_eq {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F]
    {α : typevec n} {β : Type u} (g : F (α ::: β) → β) (x : F (α ::: fix F α)) :
    fix.rec g (fix.mk x) = g (mvfunctor.map (typevec.id ::: fix.rec g) x) :=
  sorry

theorem fix.ind_aux {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F]
    {α : typevec n} (a : mvpfunctor.A (P F))
    (f' : typevec.arrow (mvpfunctor.B (mvpfunctor.drop (P F)) a) α)
    (f : pfunctor.B (mvpfunctor.last (P F)) a → mvpfunctor.W (P F) α) :
    fix.mk
          (abs
            (sigma.mk a
              (mvpfunctor.append_contents (P F) f'
                fun (x : pfunctor.B (mvpfunctor.last (P F)) a) => quotient.mk (f x)))) =
        quotient.mk (mvpfunctor.W_mk (P F) a f' f) :=
  sorry

theorem fix.ind_rec {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F]
    {α : typevec n} {β : Type u} (g₁ : fix F α → β) (g₂ : fix F α → β)
    (h :
      ∀ (x : F (α ::: fix F α)),
        mvfunctor.map (typevec.id ::: g₁) x = mvfunctor.map (typevec.id ::: g₂) x →
          g₁ (fix.mk x) = g₂ (fix.mk x))
    (x : fix F α) : g₁ x = g₂ x :=
  sorry

theorem fix.rec_unique {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F]
    {α : typevec n} {β : Type u} (g : F (α ::: β) → β) (h : fix F α → β)
    (hyp : ∀ (x : F (α ::: fix F α)), h (fix.mk x) = g (mvfunctor.map (typevec.id ::: h) x)) :
    fix.rec g = h :=
  sorry

theorem fix.mk_dest {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F]
    {α : typevec n} (x : fix F α) : fix.mk (fix.dest x) = x :=
  sorry

theorem fix.dest_mk {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F]
    {α : typevec n} (x : F (α ::: fix F α)) : fix.dest (fix.mk x) = x :=
  sorry

theorem fix.ind {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n}
    (p : fix F α → Prop)
    (h : ∀ (x : F (α ::: fix F α)), mvfunctor.liftp (typevec.pred_last α p) x → p (fix.mk x))
    (x : fix F α) : p x :=
  sorry

protected instance mvqpf_fix {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] :
    mvqpf (fix F) :=
  mk (mvpfunctor.Wp (P F)) (fun (α : typevec n) => Quot.mk Wequiv) (fun (α : typevec n) => fix_to_W)
    sorry sorry

/-- Dependent recursor for `fix F` -/
def fix.drec {n : ℕ} {F : typevec (n + 1) → Type u} [mvfunctor F] [q : mvqpf F] {α : typevec n}
    {β : fix F α → Type u}
    (g : (x : F (α ::: sigma β)) → β (fix.mk (mvfunctor.map (typevec.id ::: sigma.fst) x)))
    (x : fix F α) : β x :=
  let y : sigma β :=
    fix.rec
      (fun (i : F (α ::: sigma β)) =>
        sigma.mk (fix.mk (mvfunctor.map (typevec.id ::: sigma.fst) i)) (g i))
      x;
  (fun (this : x = sigma.fst y) => cast sorry (sigma.snd y)) sorry

end Mathlib