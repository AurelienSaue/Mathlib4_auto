/-
Copyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes HÃ¶lzl, Yury Kudryashov
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.measure_theory.measure_space
import Mathlib.measure_theory.ae_measurable_sequence
import Mathlib.analysis.complex.basic
import Mathlib.analysis.normed_space.finite_dimension
import Mathlib.topology.G_delta
import Mathlib.PostPort

universes u u_1 u_2 u_6 l u_3 u_5 u_4 u_7 u_8 

namespace Mathlib

/-!
# Borel (measurable) space

## Main definitions

* `borel Î±` : the least `Ïƒ`-algebra that contains all open sets;
* `class borel_space` : a space with `topological_space` and `measurable_space` structures
  such that `â€¹measurable_space Î±â€º = borel Î±`;
* `class opens_measurable_space` : a space with `topological_space` and `measurable_space`
  structures such that all open sets are measurable; equivalently, `borel Î± â‰¤ â€¹measurable_space Î±â€º`.
* `borel_space` instances on `empty`, `unit`, `bool`, `nat`, `int`, `rat`;
* `measurable` and `borel_space` instances on `â„`, `â„â‰¥0`, `ennreal`.
* A measure is `regular` if it is finite on compact sets, inner regular and outer regular.

## Main statements

* `is_open.is_measurable`, `is_closed.is_measurable`: open and closed sets are measurable;
* `continuous.measurable` : a continuous function is measurable;
* `continuous.measurable2` : if `f : Î± â†’ Î²` and `g : Î± â†’ Î³` are measurable and `op : Î² Ã— Î³ â†’ Î´`
  is continuous, then `Î» x, op (f x, g y)` is measurable;
* `measurable.add` etc : dot notation for arithmetic operations on `measurable` predicates,
  and similarly for `dist` and `edist`;
* `ae_measurable.add` : similar dot notation for almost everywhere measurable functions;
* `measurable.ennreal*` : special cases for arithmetic operations on `ennreal`s.
-/

/-- `measurable_space` structure generated by `topological_space`. -/
def borel (Î± : Type u) [topological_space Î±] : measurable_space Î± :=
  measurable_space.generate_from (set_of fun (s : set Î±) => is_open s)

theorem borel_eq_top_of_discrete {Î± : Type u_1} [topological_space Î±] [discrete_topology Î±] :
    borel Î± = âŠ¤ :=
  iff.mp top_le_iff
    fun (s : set Î±) (hs : measurable_space.is_measurable' âŠ¤ s) =>
      measurable_space.generate_measurable.basic s (is_open_discrete s)

theorem borel_eq_top_of_encodable {Î± : Type u_1} [topological_space Î±] [t1_space Î±] [encodable Î±] :
    borel Î± = âŠ¤ :=
  sorry

theorem borel_eq_generate_from_of_subbasis {Î± : Type u_1} {s : set (set Î±)}
    [t : topological_space Î±] [topological_space.second_countable_topology Î±]
    (hs : t = topological_space.generate_from s) : borel Î± = measurable_space.generate_from s :=
  sorry

theorem is_pi_system_is_open {Î± : Type u_1} [topological_space Î±] : is_pi_system is_open :=
  fun (s t : set Î±) (hs : s âˆˆ is_open) (ht : t âˆˆ is_open) (hst : set.nonempty (s âˆ© t)) =>
    is_open_inter hs ht

theorem borel_eq_generate_Iio (Î± : Type u_1) [topological_space Î±]
    [topological_space.second_countable_topology Î±] [linear_order Î±] [order_topology Î±] :
    borel Î± = measurable_space.generate_from (set.range set.Iio) :=
  sorry

theorem borel_eq_generate_Ioi (Î± : Type u_1) [topological_space Î±]
    [topological_space.second_countable_topology Î±] [linear_order Î±] [order_topology Î±] :
    borel Î± = measurable_space.generate_from (set.range set.Ioi) :=
  borel_eq_generate_Iio (order_dual Î±)

theorem borel_comap {Î± : Type u_1} {Î² : Type u_2} {f : Î± â†’ Î²} {t : topological_space Î²} :
    borel Î± = measurable_space.comap f (borel Î²) :=
  Eq.symm measurable_space.comap_generate_from

theorem continuous.borel_measurable {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±]
    [topological_space Î²] {f : Î± â†’ Î²} (hf : continuous f) : measurable f :=
  sorry

/-- A space with `measurable_space` and `topological_space` structures such that
all open sets are measurable. -/
class opens_measurable_space (Î± : Type u_6) [topological_space Î±] [h : measurable_space Î±] where
  borel_le : borel Î± â‰¤ h

/-- A space with `measurable_space` and `topological_space` structures such that
the `Ïƒ`-algebra of measurable sets is exactly the `Ïƒ`-algebra generated by open sets. -/
class borel_space (Î± : Type u_6) [topological_space Î±] [measurable_space Î±] where
  measurable_eq : _inst_2 = borel Î±

/-- In a `borel_space` all open sets are measurable. -/
protected instance borel_space.opens_measurable {Î± : Type u_1} [topological_space Î±]
    [measurable_space Î±] [borel_space Î±] : opens_measurable_space Î± :=
  opens_measurable_space.mk (ge_of_eq borel_space.measurable_eq)

protected instance subtype.borel_space {Î± : Type u_1} [topological_space Î±] [measurable_space Î±]
    [hÎ± : borel_space Î±] (s : set Î±) : borel_space â†¥s :=
  borel_space.mk
    (eq.mpr
      (id (Eq._oldrec (Eq.refl (subtype.measurable_space = borel â†¥s)) borel_space.measurable_eq))
      (eq.mpr
        (id
          (Eq._oldrec (Eq.refl (subtype.measurable_space = borel â†¥s))
            subtype.measurable_space.equations._eqn_1))
        (eq.mpr
          (id
            (Eq._oldrec (Eq.refl (measurable_space.comap coe (borel Î±) = borel â†¥s))
              (Eq.symm borel_comap)))
          (Eq.refl (borel (Subtype fun (x : Î±) => x âˆˆ s))))))

protected instance subtype.opens_measurable_space {Î± : Type u_1} [topological_space Î±]
    [measurable_space Î±] [h : opens_measurable_space Î±] (s : set Î±) : opens_measurable_space â†¥s :=
  opens_measurable_space.mk
    (eq.mpr (id (Eq._oldrec (Eq.refl (borel â†¥s â‰¤ subtype.measurable_space)) borel_comap))
      (measurable_space.comap_mono opens_measurable_space.borel_le))

theorem is_open.is_measurable {Î± : Type u_1} {s : set Î±} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] (h : is_open s) : is_measurable s :=
  opens_measurable_space.borel_le s (measurable_space.generate_measurable.basic s h)

theorem is_measurable_interior {Î± : Type u_1} {s : set Î±} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] : is_measurable (interior s) :=
  is_open.is_measurable is_open_interior

theorem is_GÎ´.is_measurable {Î± : Type u_1} {s : set Î±} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] (h : is_GÎ´ s) : is_measurable s :=
  sorry

theorem is_measurable_set_of_continuous_at {Î± : Type u_1} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] {Î² : Type u_2} [emetric_space Î²] (f : Î± â†’ Î²) :
    is_measurable (set_of fun (x : Î±) => continuous_at f x) :=
  is_GÎ´.is_measurable (is_GÎ´_set_of_continuous_at f)

theorem is_closed.is_measurable {Î± : Type u_1} {s : set Î±} [topological_space Î±]
    [measurable_space Î±] [opens_measurable_space Î±] (h : is_closed s) : is_measurable s :=
  is_measurable.of_compl (is_open.is_measurable h)

theorem is_compact.is_measurable {Î± : Type u_1} {s : set Î±} [topological_space Î±]
    [measurable_space Î±] [opens_measurable_space Î±] [t2_space Î±] (h : is_compact s) :
    is_measurable s :=
  is_closed.is_measurable (is_compact.is_closed h)

theorem is_measurable_closure {Î± : Type u_1} {s : set Î±} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] : is_measurable (closure s) :=
  is_closed.is_measurable is_closed_closure

theorem measurable_of_is_open {Î³ : Type u_3} {Î´ : Type u_5} [topological_space Î³]
    [measurable_space Î³] [borel_space Î³] [measurable_space Î´] {f : Î´ â†’ Î³}
    (hf : âˆ€ (s : set Î³), is_open s â†’ is_measurable (f â»Â¹' s)) : measurable f :=
  eq.mpr (id (Eq._oldrec (Eq.refl (measurable f)) borel_space.measurable_eq))
    (measurable_generate_from hf)

theorem measurable_of_is_closed {Î³ : Type u_3} {Î´ : Type u_5} [topological_space Î³]
    [measurable_space Î³] [borel_space Î³] [measurable_space Î´] {f : Î´ â†’ Î³}
    (hf : âˆ€ (s : set Î³), is_closed s â†’ is_measurable (f â»Â¹' s)) : measurable f :=
  sorry

theorem measurable_of_is_closed' {Î³ : Type u_3} {Î´ : Type u_5} [topological_space Î³]
    [measurable_space Î³] [borel_space Î³] [measurable_space Î´] {f : Î´ â†’ Î³}
    (hf : âˆ€ (s : set Î³), is_closed s â†’ set.nonempty s â†’ s â‰  set.univ â†’ is_measurable (f â»Â¹' s)) :
    measurable f :=
  sorry

protected instance nhds_is_measurably_generated {Î± : Type u_1} [topological_space Î±]
    [measurable_space Î±] [opens_measurable_space Î±] (a : Î±) :
    filter.is_measurably_generated (nhds a) :=
  eq.mpr
    (id (Eq._oldrec (Eq.refl (filter.is_measurably_generated (nhds a))) (nhds.equations._eqn_1 a)))
    (eq.mpr
      (id
        (Eq._oldrec
          (Eq.refl
            (filter.is_measurably_generated
              (infi
                fun (s : set Î±) =>
                  infi
                    fun (H : s âˆˆ set_of fun (s : set Î±) => a âˆˆ s âˆ§ is_open s) =>
                      filter.principal s)))
          infi_subtype'))
      filter.infi_is_measurably_generated)

/-- If `s` is a measurable set, then `ð“[s] a` is a measurably generated filter for
each `a`. This cannot be an `instance` because it depends on a non-instance `hs : is_measurable s`.
-/
theorem is_measurable.nhds_within_is_measurably_generated {Î± : Type u_1} [topological_space Î±]
    [measurable_space Î±] [opens_measurable_space Î±] {s : set Î±} (hs : is_measurable s) (a : Î±) :
    filter.is_measurably_generated (nhds_within a s) :=
  filter.inf_is_measurably_generated (nhds a) (filter.principal s)

protected instance opens_measurable_space.to_measurable_singleton_class {Î± : Type u_1}
    [topological_space Î±] [measurable_space Î±] [opens_measurable_space Î±] [t1_space Î±] :
    measurable_singleton_class Î± :=
  measurable_singleton_class.mk fun (x : Î±) => is_closed.is_measurable is_closed_singleton

protected instance pi.opens_measurable_space {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [fintype Î¹]
    [t' : (i : Î¹) â†’ topological_space (Ï€ i)] [(i : Î¹) â†’ measurable_space (Ï€ i)]
    [âˆ€ (i : Î¹), topological_space.second_countable_topology (Ï€ i)]
    [âˆ€ (i : Î¹), opens_measurable_space (Ï€ i)] : opens_measurable_space ((i : Î¹) â†’ Ï€ i) :=
  sorry

protected instance prod.opens_measurable_space {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±]
    [measurable_space Î±] [opens_measurable_space Î±] [topological_space Î²] [measurable_space Î²]
    [opens_measurable_space Î²] [topological_space.second_countable_topology Î±]
    [topological_space.second_countable_topology Î²] : opens_measurable_space (Î± Ã— Î²) :=
  sorry

@[simp] theorem is_measurable_Ici {Î± : Type u_1} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [preorder Î±] [order_closed_topology Î±] {a : Î±} :
    is_measurable (set.Ici a) :=
  is_closed.is_measurable is_closed_Ici

@[simp] theorem is_measurable_Iic {Î± : Type u_1} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [preorder Î±] [order_closed_topology Î±] {a : Î±} :
    is_measurable (set.Iic a) :=
  is_closed.is_measurable is_closed_Iic

@[simp] theorem is_measurable_Icc {Î± : Type u_1} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [preorder Î±] [order_closed_topology Î±] {a : Î±} {b : Î±} :
    is_measurable (set.Icc a b) :=
  is_closed.is_measurable is_closed_Icc

protected instance nhds_within_Ici_is_measurably_generated {Î± : Type u_1} [topological_space Î±]
    [measurable_space Î±] [opens_measurable_space Î±] [preorder Î±] [order_closed_topology Î±] {a : Î±}
    {b : Î±} : filter.is_measurably_generated (nhds_within a (set.Ici b)) :=
  is_measurable.nhds_within_is_measurably_generated is_measurable_Ici a

protected instance nhds_within_Iic_is_measurably_generated {Î± : Type u_1} [topological_space Î±]
    [measurable_space Î±] [opens_measurable_space Î±] [preorder Î±] [order_closed_topology Î±] {a : Î±}
    {b : Î±} : filter.is_measurably_generated (nhds_within a (set.Iic b)) :=
  is_measurable.nhds_within_is_measurably_generated is_measurable_Iic a

protected instance at_top_is_measurably_generated {Î± : Type u_1} [topological_space Î±]
    [measurable_space Î±] [opens_measurable_space Î±] [preorder Î±] [order_closed_topology Î±] :
    filter.is_measurably_generated filter.at_top :=
  filter.infi_is_measurably_generated

protected instance at_bot_is_measurably_generated {Î± : Type u_1} [topological_space Î±]
    [measurable_space Î±] [opens_measurable_space Î±] [preorder Î±] [order_closed_topology Î±] :
    filter.is_measurably_generated filter.at_bot :=
  filter.infi_is_measurably_generated

theorem is_measurable_le' {Î± : Type u_1} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [partial_order Î±] [order_closed_topology Î±]
    [topological_space.second_countable_topology Î±] :
    is_measurable (set_of fun (p : Î± Ã— Î±) => prod.fst p â‰¤ prod.snd p) :=
  is_closed.is_measurable order_closed_topology.is_closed_le'

theorem is_measurable_le {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [measurable_space Î´] [partial_order Î±] [order_closed_topology Î±]
    [topological_space.second_countable_topology Î±] {f : Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : measurable f)
    (hg : measurable g) : is_measurable (set_of fun (a : Î´) => f a â‰¤ g a) :=
  measurable.prod_mk hf hg is_measurable_le'

@[simp] theorem is_measurable_Iio {Î± : Type u_1} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [linear_order Î±] [order_closed_topology Î±] {a : Î±} :
    is_measurable (set.Iio a) :=
  is_open.is_measurable is_open_Iio

@[simp] theorem is_measurable_Ioi {Î± : Type u_1} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [linear_order Î±] [order_closed_topology Î±] {a : Î±} :
    is_measurable (set.Ioi a) :=
  is_open.is_measurable is_open_Ioi

@[simp] theorem is_measurable_Ioo {Î± : Type u_1} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [linear_order Î±] [order_closed_topology Î±] {a : Î±} {b : Î±} :
    is_measurable (set.Ioo a b) :=
  is_open.is_measurable is_open_Ioo

@[simp] theorem is_measurable_Ioc {Î± : Type u_1} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [linear_order Î±] [order_closed_topology Î±] {a : Î±} {b : Î±} :
    is_measurable (set.Ioc a b) :=
  is_measurable.inter is_measurable_Ioi is_measurable_Iic

@[simp] theorem is_measurable_Ico {Î± : Type u_1} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [linear_order Î±] [order_closed_topology Î±] {a : Î±} {b : Î±} :
    is_measurable (set.Ico a b) :=
  is_measurable.inter is_measurable_Ici is_measurable_Iio

protected instance nhds_within_Ioi_is_measurably_generated {Î± : Type u_1} [topological_space Î±]
    [measurable_space Î±] [opens_measurable_space Î±] [linear_order Î±] [order_closed_topology Î±]
    {a : Î±} {b : Î±} : filter.is_measurably_generated (nhds_within a (set.Ioi b)) :=
  is_measurable.nhds_within_is_measurably_generated is_measurable_Ioi a

protected instance nhds_within_Iio_is_measurably_generated {Î± : Type u_1} [topological_space Î±]
    [measurable_space Î±] [opens_measurable_space Î±] [linear_order Î±] [order_closed_topology Î±]
    {a : Î±} {b : Î±} : filter.is_measurably_generated (nhds_within a (set.Iio b)) :=
  is_measurable.nhds_within_is_measurably_generated is_measurable_Iio a

theorem is_measurable_lt' {Î± : Type u_1} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [linear_order Î±] [order_closed_topology Î±]
    [topological_space.second_countable_topology Î±] :
    is_measurable (set_of fun (p : Î± Ã— Î±) => prod.fst p < prod.snd p) :=
  is_open.is_measurable (is_open_lt continuous_fst continuous_snd)

theorem is_measurable_lt {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [measurable_space Î´] [linear_order Î±] [order_closed_topology Î±]
    [topological_space.second_countable_topology Î±] {f : Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : measurable f)
    (hg : measurable g) : is_measurable (set_of fun (a : Î´) => f a < g a) :=
  measurable.prod_mk hf hg is_measurable_lt'

theorem is_measurable_interval {Î± : Type u_1} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [linear_order Î±] [order_closed_topology Î±] {a : Î±} {b : Î±} :
    is_measurable (set.interval a b) :=
  is_measurable_Icc

theorem measurable.max {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [measurable_space Î´] [linear_order Î±] [order_closed_topology Î±]
    [topological_space.second_countable_topology Î±] {f : Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : measurable f)
    (hg : measurable g) : measurable fun (a : Î´) => max (f a) (g a) :=
  measurable.piecewise (is_measurable_le hg hf) hf hg

theorem ae_measurable.max {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [measurable_space Î´] [linear_order Î±] [order_closed_topology Î±]
    [topological_space.second_countable_topology Î±] {f : Î´ â†’ Î±} {g : Î´ â†’ Î±}
    {Î¼ : measure_theory.measure Î´} (hf : ae_measurable f) (hg : ae_measurable g) :
    ae_measurable fun (a : Î´) => max (f a) (g a) :=
  Exists.intro (fun (a : Î´) => max (ae_measurable.mk f hf a) (ae_measurable.mk g hg a))
    { left := measurable.max (ae_measurable.measurable_mk hf) (ae_measurable.measurable_mk hg),
      right :=
        filter.eventually_eq.compâ‚‚ (ae_measurable.ae_eq_mk hf) max (ae_measurable.ae_eq_mk hg) }

theorem measurable.min {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [measurable_space Î´] [linear_order Î±] [order_closed_topology Î±]
    [topological_space.second_countable_topology Î±] {f : Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : measurable f)
    (hg : measurable g) : measurable fun (a : Î´) => min (f a) (g a) :=
  measurable.piecewise (is_measurable_le hf hg) hf hg

theorem ae_measurable.min {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [measurable_space Î´] [linear_order Î±] [order_closed_topology Î±]
    [topological_space.second_countable_topology Î±] {f : Î´ â†’ Î±} {g : Î´ â†’ Î±}
    {Î¼ : measure_theory.measure Î´} (hf : ae_measurable f) (hg : ae_measurable g) :
    ae_measurable fun (a : Î´) => min (f a) (g a) :=
  Exists.intro (fun (a : Î´) => min (ae_measurable.mk f hf a) (ae_measurable.mk g hg a))
    { left := measurable.min (ae_measurable.measurable_mk hf) (ae_measurable.measurable_mk hg),
      right :=
        filter.eventually_eq.compâ‚‚ (ae_measurable.ae_eq_mk hf) min (ae_measurable.ae_eq_mk hg) }

/-- A continuous function from an `opens_measurable_space` to a `borel_space`
is measurable. -/
theorem continuous.measurable {Î± : Type u_1} {Î³ : Type u_3} [topological_space Î±]
    [measurable_space Î±] [opens_measurable_space Î±] [topological_space Î³] [measurable_space Î³]
    [borel_space Î³] {f : Î± â†’ Î³} (hf : continuous f) : measurable f :=
  measurable.mono (continuous.borel_measurable hf) opens_measurable_space.borel_le
    (le_of_eq borel_space.measurable_eq)

/-- A homeomorphism between two Borel spaces is a measurable equivalence.-/
def homeomorph.to_measurable_equiv {Î³ : Type u_3} {Î³â‚‚ : Type u_4} [topological_space Î³]
    [measurable_space Î³] [borel_space Î³] [topological_space Î³â‚‚] [measurable_space Î³â‚‚]
    [borel_space Î³â‚‚] (h : Î³ â‰ƒâ‚œ Î³â‚‚) : Î³ â‰ƒáµ Î³â‚‚ :=
  measurable_equiv.mk (homeomorph.to_equiv h) sorry sorry

@[simp] theorem homeomorph.to_measurable_equiv_coe {Î³ : Type u_3} {Î³â‚‚ : Type u_4}
    [topological_space Î³] [measurable_space Î³] [borel_space Î³] [topological_space Î³â‚‚]
    [measurable_space Î³â‚‚] [borel_space Î³â‚‚] (h : Î³ â‰ƒâ‚œ Î³â‚‚) :
    â‡‘(homeomorph.to_measurable_equiv h) = â‡‘h :=
  rfl

@[simp] theorem homeomorph.to_measurable_equiv_symm_coe {Î³ : Type u_3} {Î³â‚‚ : Type u_4}
    [topological_space Î³] [measurable_space Î³] [borel_space Î³] [topological_space Î³â‚‚]
    [measurable_space Î³â‚‚] [borel_space Î³â‚‚] (h : Î³ â‰ƒâ‚œ Î³â‚‚) :
    â‡‘(measurable_equiv.symm (homeomorph.to_measurable_equiv h)) = â‡‘(homeomorph.symm h) :=
  rfl

theorem measurable_of_continuous_on_compl_singleton {Î± : Type u_1} {Î³ : Type u_3}
    [topological_space Î±] [measurable_space Î±] [opens_measurable_space Î±] [topological_space Î³]
    [measurable_space Î³] [borel_space Î³] [t1_space Î±] {f : Î± â†’ Î³} (a : Î±)
    (hf : continuous_on f (set_of fun (x : Î±) => x â‰  a)) : measurable f :=
  measurable_of_measurable_on_compl_singleton a
    (continuous.measurable (iff.mp continuous_on_iff_continuous_restrict hf))

theorem continuous.measurable2 {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_5}
    [topological_space Î±] [measurable_space Î±] [opens_measurable_space Î±] [topological_space Î²]
    [measurable_space Î²] [opens_measurable_space Î²] [topological_space Î³] [measurable_space Î³]
    [borel_space Î³] [measurable_space Î´] [topological_space.second_countable_topology Î±]
    [topological_space.second_countable_topology Î²] {f : Î´ â†’ Î±} {g : Î´ â†’ Î²} {c : Î± â†’ Î² â†’ Î³}
    (h : continuous fun (p : Î± Ã— Î²) => c (prod.fst p) (prod.snd p)) (hf : measurable f)
    (hg : measurable g) : measurable fun (a : Î´) => c (f a) (g a) :=
  measurable.comp (continuous.measurable h) (measurable.prod_mk hf hg)

theorem continuous.ae_measurable2 {Î± : Type u_1} {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_5}
    [topological_space Î±] [measurable_space Î±] [opens_measurable_space Î±] [topological_space Î²]
    [measurable_space Î²] [opens_measurable_space Î²] [topological_space Î³] [measurable_space Î³]
    [borel_space Î³] [measurable_space Î´] [topological_space.second_countable_topology Î±]
    [topological_space.second_countable_topology Î²] {f : Î´ â†’ Î±} {g : Î´ â†’ Î²} {c : Î± â†’ Î² â†’ Î³}
    {Î¼ : measure_theory.measure Î´} (h : continuous fun (p : Î± Ã— Î²) => c (prod.fst p) (prod.snd p))
    (hf : ae_measurable f) (hg : ae_measurable g) : ae_measurable fun (a : Î´) => c (f a) (g a) :=
  measurable.comp_ae_measurable (continuous.measurable h) (ae_measurable.prod_mk hf hg)

theorem measurable.smul {Î± : Type u_1} {Î³ : Type u_3} {Î´ : Type u_5} [topological_space Î±]
    [measurable_space Î±] [opens_measurable_space Î±] [topological_space Î³] [measurable_space Î³]
    [borel_space Î³] [measurable_space Î´] [semiring Î±]
    [topological_space.second_countable_topology Î±] [add_comm_monoid Î³]
    [topological_space.second_countable_topology Î³] [semimodule Î± Î³] [topological_semimodule Î± Î³]
    {f : Î´ â†’ Î±} {g : Î´ â†’ Î³} (hf : measurable f) (hg : measurable g) :
    measurable fun (c : Î´) => f c â€¢ g c :=
  continuous.measurable2 continuous_smul hf hg

theorem ae_measurable.smul {Î± : Type u_1} {Î³ : Type u_3} {Î´ : Type u_5} [topological_space Î±]
    [measurable_space Î±] [opens_measurable_space Î±] [topological_space Î³] [measurable_space Î³]
    [borel_space Î³] [measurable_space Î´] [semiring Î±]
    [topological_space.second_countable_topology Î±] [add_comm_monoid Î³]
    [topological_space.second_countable_topology Î³] [semimodule Î± Î³] [topological_semimodule Î± Î³]
    {f : Î´ â†’ Î±} {g : Î´ â†’ Î³} {Î¼ : measure_theory.measure Î´} (hf : ae_measurable f)
    (hg : ae_measurable g) : ae_measurable fun (c : Î´) => f c â€¢ g c :=
  continuous.ae_measurable2 continuous_smul hf hg

theorem measurable.const_smul {Î´ : Type u_5} [measurable_space Î´] {R : Type u_1} {M : Type u_2}
    [topological_space R] [semiring R] [add_comm_monoid M] [semimodule R M] [topological_space M]
    [topological_semimodule R M] [measurable_space M] [borel_space M] {f : Î´ â†’ M}
    (hf : measurable f) (c : R) : measurable fun (x : Î´) => c â€¢ f x :=
  measurable.comp (continuous.measurable (continuous.smul continuous_const continuous_id)) hf

theorem ae_measurable.const_smul {Î´ : Type u_5} [measurable_space Î´] {R : Type u_1} {M : Type u_2}
    [topological_space R] [semiring R] [add_comm_monoid M] [semimodule R M] [topological_space M]
    [topological_semimodule R M] [measurable_space M] [borel_space M] {f : Î´ â†’ M}
    {Î¼ : measure_theory.measure Î´} (hf : ae_measurable f) (c : R) :
    ae_measurable fun (x : Î´) => c â€¢ f x :=
  measurable.comp_ae_measurable
    (continuous.measurable (continuous.smul continuous_const continuous_id)) hf

theorem measurable_const_smul_iff {Î³ : Type u_3} {Î´ : Type u_5} [topological_space Î³]
    [measurable_space Î³] [borel_space Î³] [measurable_space Î´] {Î± : Type u_1} [topological_space Î±]
    [division_ring Î±] [add_comm_monoid Î³] [semimodule Î± Î³] [topological_semimodule Î± Î³] {f : Î´ â†’ Î³}
    {c : Î±} (hc : c â‰  0) : (measurable fun (x : Î´) => c â€¢ f x) â†” measurable f :=
  sorry

theorem ae_measurable_const_smul_iff {Î³ : Type u_3} {Î´ : Type u_5} [topological_space Î³]
    [measurable_space Î³] [borel_space Î³] [measurable_space Î´] {Î± : Type u_1} [topological_space Î±]
    [division_ring Î±] [add_comm_monoid Î³] [semimodule Î± Î³] [topological_semimodule Î± Î³] {f : Î´ â†’ Î³}
    {Î¼ : measure_theory.measure Î´} {c : Î±} (hc : c â‰  0) :
    (ae_measurable fun (x : Î´) => c â€¢ f x) â†” ae_measurable f :=
  sorry

theorem measurable.const_mul {Î´ : Type u_5} [measurable_space Î´] {R : Type u_1}
    [topological_space R] [measurable_space R] [borel_space R] [semiring R] [topological_semiring R]
    {f : Î´ â†’ R} (hf : measurable f) (c : R) : measurable fun (x : Î´) => c * f x :=
  measurable.const_smul hf c

theorem measurable.mul_const {Î´ : Type u_5} [measurable_space Î´] {R : Type u_1}
    [topological_space R] [measurable_space R] [borel_space R] [semiring R] [topological_semiring R]
    {f : Î´ â†’ R} (hf : measurable f) (c : R) : measurable fun (x : Î´) => f x * c :=
  measurable.comp (continuous.measurable (continuous.mul continuous_id continuous_const)) hf

theorem pi_le_borel_pi {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [(i : Î¹) â†’ topological_space (Ï€ i)]
    [(i : Î¹) â†’ measurable_space (Ï€ i)] [âˆ€ (i : Î¹), borel_space (Ï€ i)] :
    measurable_space.pi â‰¤ borel ((a : Î¹) â†’ Ï€ a) :=
  sorry

theorem prod_le_borel_prod {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [topological_space Î²] [measurable_space Î²] [borel_space Î²] :
    prod.measurable_space â‰¤ borel (Î± Ã— Î²) :=
  sorry

protected instance pi.borel_space {Î¹ : Type u_1} {Ï€ : Î¹ â†’ Type u_2} [fintype Î¹]
    [t' : (i : Î¹) â†’ topological_space (Ï€ i)] [(i : Î¹) â†’ measurable_space (Ï€ i)]
    [âˆ€ (i : Î¹), topological_space.second_countable_topology (Ï€ i)] [âˆ€ (i : Î¹), borel_space (Ï€ i)] :
    borel_space ((i : Î¹) â†’ Ï€ i) :=
  borel_space.mk (le_antisymm pi_le_borel_pi opens_measurable_space.borel_le)

protected instance prod.borel_space {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±]
    [measurable_space Î±] [borel_space Î±] [topological_space Î²] [measurable_space Î²] [borel_space Î²]
    [topological_space.second_countable_topology Î±]
    [topological_space.second_countable_topology Î²] : borel_space (Î± Ã— Î²) :=
  borel_space.mk (le_antisymm prod_le_borel_prod opens_measurable_space.borel_le)

theorem measurable_add {Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±]
    [Add Î±] [has_continuous_add Î±] [topological_space.second_countable_topology Î±] :
    measurable fun (p : Î± Ã— Î±) => prod.fst p + prod.snd p :=
  continuous.measurable continuous_add

theorem measurable.mul {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [Mul Î±] [has_continuous_mul Î±]
    [topological_space.second_countable_topology Î±] {f : Î´ â†’ Î±} {g : Î´ â†’ Î±} :
    measurable f â†’ measurable g â†’ measurable fun (a : Î´) => f a * g a :=
  continuous.measurable2 continuous_mul

theorem ae_measurable.mul {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [Mul Î±] [has_continuous_mul Î±]
    [topological_space.second_countable_topology Î±] {f : Î´ â†’ Î±} {g : Î´ â†’ Î±}
    {Î¼ : measure_theory.measure Î´} (hf : ae_measurable f) (hg : ae_measurable g) :
    ae_measurable fun (a : Î´) => f a * g a :=
  continuous.ae_measurable2 continuous_mul hf hg

/-- A variant of `measurable.mul` that uses `*` on functions -/
theorem measurable.add' {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [Add Î±] [has_continuous_add Î±]
    [topological_space.second_countable_topology Î±] {f : Î´ â†’ Î±} {g : Î´ â†’ Î±} :
    measurable f â†’ measurable g â†’ measurable (f + g) :=
  measurable.add

theorem measurable_add_left {Î± : Type u_1} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [Add Î±] [has_continuous_add Î±] (x : Î±) : measurable fun (y : Î±) => x + y :=
  continuous.measurable (continuous.add continuous_const continuous_id)

theorem measurable_add_right {Î± : Type u_1} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [Add Î±] [has_continuous_add Î±] (x : Î±) : measurable fun (y : Î±) => y + x :=
  continuous.measurable (continuous.add continuous_id continuous_const)

theorem finset.measurable_prod {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±]
    [measurable_space Î±] [borel_space Î±] [measurable_space Î´] {Î¹ : Type u_2} [comm_monoid Î±]
    [has_continuous_mul Î±] [topological_space.second_countable_topology Î±] {f : Î¹ â†’ Î´ â†’ Î±}
    (s : finset Î¹) (hf : âˆ€ (i : Î¹), measurable (f i)) :
    measurable fun (a : Î´) => finset.prod s fun (i : Î¹) => f i a :=
  sorry

theorem measurable_neg {Î± : Type u_1} [topological_space Î±] [measurable_space Î±] [borel_space Î±]
    [add_group Î±] [topological_add_group Î±] : measurable Neg.neg :=
  continuous.measurable continuous_neg

theorem measurable.inv {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [group Î±] [topological_group Î±] {f : Î´ â†’ Î±}
    (hf : measurable f) : measurable fun (a : Î´) => f aâ»Â¹ :=
  measurable.comp measurable_inv hf

theorem ae_measurable.inv {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [group Î±] [topological_group Î±] {f : Î´ â†’ Î±}
    {Î¼ : measure_theory.measure Î´} (hf : ae_measurable f) : ae_measurable fun (a : Î´) => f aâ»Â¹ :=
  measurable.comp_ae_measurable measurable_inv hf

theorem measurable_inv' {Î± : Type u_1} [normed_field Î±] [measurable_space Î±] [borel_space Î±] :
    measurable has_inv.inv :=
  measurable_of_continuous_on_compl_singleton 0 continuous_on_inv'

theorem measurable.inv' {Î´ : Type u_5} [measurable_space Î´] {Î± : Type u_1} [normed_field Î±]
    [measurable_space Î±] [borel_space Î±] {f : Î´ â†’ Î±} (hf : measurable f) :
    measurable fun (a : Î´) => f aâ»Â¹ :=
  measurable.comp measurable_inv' hf

theorem measurable.of_inv {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [group Î±] [topological_group Î±] {f : Î´ â†’ Î±}
    (hf : measurable fun (a : Î´) => f aâ»Â¹) : measurable f :=
  sorry

@[simp] theorem measurable_inv_iff {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±]
    [measurable_space Î±] [borel_space Î±] [measurable_space Î´] [group Î±] [topological_group Î±]
    {f : Î´ â†’ Î±} : (measurable fun (a : Î´) => f aâ»Â¹) â†” measurable f :=
  { mp := measurable.of_inv, mpr := measurable.inv }

theorem measurable.sub {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [add_group Î±] [topological_add_group Î±]
    [topological_space.second_countable_topology Î±] {f : Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : measurable f)
    (hg : measurable g) : measurable fun (x : Î´) => f x - g x :=
  sorry

theorem ae_measurable.sub {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [add_group Î±] [topological_add_group Î±]
    [topological_space.second_countable_topology Î±] {f : Î´ â†’ Î±} {g : Î´ â†’ Î±}
    {Î¼ : measure_theory.measure Î´} (hf : ae_measurable f) (hg : ae_measurable g) :
    ae_measurable fun (x : Î´) => f x - g x :=
  sorry

theorem closed_embedding.measurable_inv_fun {Î² : Type u_2} {Î³ : Type u_3} [topological_space Î²]
    [measurable_space Î²] [borel_space Î²] [topological_space Î³] [measurable_space Î³] [borel_space Î³]
    [n : Nonempty Î²] {g : Î² â†’ Î³} (hg : closed_embedding g) : measurable (function.inv_fun g) :=
  sorry

theorem measurable_comp_iff_of_closed_embedding {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_5}
    [topological_space Î²] [measurable_space Î²] [borel_space Î²] [topological_space Î³]
    [measurable_space Î³] [borel_space Î³] [measurable_space Î´] {f : Î´ â†’ Î²} (g : Î² â†’ Î³)
    (hg : closed_embedding g) : measurable (g âˆ˜ f) â†” measurable f :=
  sorry

theorem ae_measurable_comp_iff_of_closed_embedding {Î² : Type u_2} {Î³ : Type u_3} {Î´ : Type u_5}
    [topological_space Î²] [measurable_space Î²] [borel_space Î²] [topological_space Î³]
    [measurable_space Î³] [borel_space Î³] [measurable_space Î´] {f : Î´ â†’ Î²}
    {Î¼ : measure_theory.measure Î´} (g : Î² â†’ Î³) (hg : closed_embedding g) :
    ae_measurable (g âˆ˜ f) â†” ae_measurable f :=
  sorry

theorem measurable_of_Iio {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {f : Î´ â†’ Î±}
    (hf : âˆ€ (x : Î±), is_measurable (f â»Â¹' set.Iio x)) : measurable f :=
  sorry

theorem measurable_of_Ioi {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {f : Î´ â†’ Î±}
    (hf : âˆ€ (x : Î±), is_measurable (f â»Â¹' set.Ioi x)) : measurable f :=
  sorry

theorem measurable_of_Iic {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {f : Î´ â†’ Î±}
    (hf : âˆ€ (x : Î±), is_measurable (f â»Â¹' set.Iic x)) : measurable f :=
  sorry

theorem measurable_of_Ici {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {f : Î´ â†’ Î±}
    (hf : âˆ€ (x : Î±), is_measurable (f â»Â¹' set.Ici x)) : measurable f :=
  sorry

theorem measurable.is_lub {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {Î¹ : Type u_2} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±}
    {g : Î´ â†’ Î±} (hf : âˆ€ (i : Î¹), measurable (f i))
    (hg : âˆ€ (b : Î´), is_lub (set_of fun (a : Î±) => âˆƒ (i : Î¹), f i b = a) (g b)) : measurable g :=
  sorry

theorem ae_measurable.is_lub {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±]
    [measurable_space Î±] [borel_space Î±] [measurable_space Î´] [linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {Î¹ : Type u_2} {Î¼ : measure_theory.measure Î´}
    [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : âˆ€ (i : Î¹), ae_measurable (f i))
    (hg :
      filter.eventually (fun (b : Î´) => is_lub (set_of fun (a : Î±) => âˆƒ (i : Î¹), f i b = a) (g b))
        (measure_theory.measure.ae Î¼)) :
    ae_measurable g :=
  sorry

theorem measurable.is_glb {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {Î¹ : Type u_2} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±}
    {g : Î´ â†’ Î±} (hf : âˆ€ (i : Î¹), measurable (f i))
    (hg : âˆ€ (b : Î´), is_glb (set_of fun (a : Î±) => âˆƒ (i : Î¹), f i b = a) (g b)) : measurable g :=
  sorry

theorem ae_measurable.is_glb {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±]
    [measurable_space Î±] [borel_space Î±] [measurable_space Î´] [linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {Î¹ : Type u_2} {Î¼ : measure_theory.measure Î´}
    [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : âˆ€ (i : Î¹), ae_measurable (f i))
    (hg :
      filter.eventually (fun (b : Î´) => is_glb (set_of fun (a : Î±) => âˆƒ (i : Î¹), f i b = a) (g b))
        (measure_theory.measure.ae Î¼)) :
    ae_measurable g :=
  sorry

theorem measurable.supr_Prop {Î´ : Type u_5} [measurable_space Î´] {Î± : Type u_1} [measurable_space Î±]
    [complete_lattice Î±] (p : Prop) {f : Î´ â†’ Î±} (hf : measurable f) :
    measurable fun (b : Î´) => supr fun (h : p) => f b :=
  sorry

theorem measurable.infi_Prop {Î´ : Type u_5} [measurable_space Î´] {Î± : Type u_1} [measurable_space Î±]
    [complete_lattice Î±] (p : Prop) {f : Î´ â†’ Î±} (hf : measurable f) :
    measurable fun (b : Î´) => infi fun (h : p) => f b :=
  sorry

theorem measurable_supr {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [complete_linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {Î¹ : Type u_2} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±}
    (hf : âˆ€ (i : Î¹), measurable (f i)) : measurable fun (b : Î´) => supr fun (i : Î¹) => f i b :=
  measurable.is_lub hf fun (b : Î´) => is_lub_supr

theorem ae_measurable_supr {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [complete_linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {Î¹ : Type u_2} {Î¼ : measure_theory.measure Î´}
    [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ (i : Î¹), ae_measurable (f i)) :
    ae_measurable fun (b : Î´) => supr fun (i : Î¹) => f i b :=
  ae_measurable.is_lub hf (measure_theory.ae_of_all Î¼ fun (b : Î´) => is_lub_supr)

theorem measurable_infi {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [complete_linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {Î¹ : Type u_2} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±}
    (hf : âˆ€ (i : Î¹), measurable (f i)) : measurable fun (b : Î´) => infi fun (i : Î¹) => f i b :=
  measurable.is_glb hf fun (b : Î´) => is_glb_infi

theorem ae_measurable_infi {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [complete_linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {Î¹ : Type u_2} {Î¼ : measure_theory.measure Î´}
    [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ (i : Î¹), ae_measurable (f i)) :
    ae_measurable fun (b : Î´) => infi fun (i : Î¹) => f i b :=
  ae_measurable.is_glb hf (measure_theory.ae_of_all Î¼ fun (b : Î´) => is_glb_infi)

theorem measurable_bsupr {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [complete_linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {Î¹ : Type u_2} (s : set Î¹) {f : Î¹ â†’ Î´ â†’ Î±}
    (hs : set.countable s) (hf : âˆ€ (i : Î¹), measurable (f i)) :
    measurable fun (b : Î´) => supr fun (i : Î¹) => supr fun (H : i âˆˆ s) => f i b :=
  sorry

theorem ae_measurable_bsupr {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [complete_linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {Î¹ : Type u_2} {Î¼ : measure_theory.measure Î´}
    (s : set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : set.countable s) (hf : âˆ€ (i : Î¹), ae_measurable (f i)) :
    ae_measurable fun (b : Î´) => supr fun (i : Î¹) => supr fun (H : i âˆˆ s) => f i b :=
  sorry

theorem measurable_binfi {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [complete_linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {Î¹ : Type u_2} (s : set Î¹) {f : Î¹ â†’ Î´ â†’ Î±}
    (hs : set.countable s) (hf : âˆ€ (i : Î¹), measurable (f i)) :
    measurable fun (b : Î´) => infi fun (i : Î¹) => infi fun (H : i âˆˆ s) => f i b :=
  sorry

theorem ae_measurable_binfi {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [complete_linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {Î¹ : Type u_2} {Î¼ : measure_theory.measure Î´}
    (s : set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : set.countable s) (hf : âˆ€ (i : Î¹), ae_measurable (f i)) :
    ae_measurable fun (b : Î´) => infi fun (i : Î¹) => infi fun (H : i âˆˆ s) => f i b :=
  sorry

/-- `liminf` over a general filter is measurable. See `measurable_liminf` for the version over `â„•`.
-/
theorem measurable_liminf' {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [complete_linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {Î¹ : Type u_2} {Î¹' : Type u_3} {f : Î¹ â†’ Î´ â†’ Î±}
    {u : filter Î¹} (hf : âˆ€ (i : Î¹), measurable (f i)) {p : Î¹' â†’ Prop} {s : Î¹' â†’ set Î¹}
    (hu : filter.has_countable_basis u p s) (hs : âˆ€ (i : Î¹'), set.countable (s i)) :
    measurable fun (x : Î´) => filter.liminf u fun (i : Î¹) => f i x :=
  sorry

/-- `limsup` over a general filter is measurable. See `measurable_limsup` for the version over `â„•`.
-/
theorem measurable_limsup' {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [complete_linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {Î¹ : Type u_2} {Î¹' : Type u_3} {f : Î¹ â†’ Î´ â†’ Î±}
    {u : filter Î¹} (hf : âˆ€ (i : Î¹), measurable (f i)) {p : Î¹' â†’ Prop} {s : Î¹' â†’ set Î¹}
    (hu : filter.has_countable_basis u p s) (hs : âˆ€ (i : Î¹'), set.countable (s i)) :
    measurable fun (x : Î´) => filter.limsup u fun (i : Î¹) => f i x :=
  sorry

/-- `liminf` over `â„•` is measurable. See `measurable_liminf'` for a version with a general filter.
-/
theorem measurable_liminf {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [complete_linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {f : â„• â†’ Î´ â†’ Î±}
    (hf : âˆ€ (i : â„•), measurable (f i)) :
    measurable fun (x : Î´) => filter.liminf filter.at_top fun (i : â„•) => f i x :=
  measurable_liminf' hf filter.at_top_countable_basis
    fun (i : â„•) => set.countable_encodable (set.Ici i)

/-- `limsup` over `â„•` is measurable. See `measurable_limsup'` for a version with a general filter.
-/
theorem measurable_limsup {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [complete_linear_order Î±] [order_topology Î±]
    [topological_space.second_countable_topology Î±] {f : â„• â†’ Î´ â†’ Î±}
    (hf : âˆ€ (i : â„•), measurable (f i)) :
    measurable fun (x : Î´) => filter.limsup filter.at_top fun (i : â„•) => f i x :=
  measurable_limsup' hf filter.at_top_countable_basis
    fun (i : â„•) => set.countable_encodable (set.Ici i)

theorem measurable_cSup {Î± : Type u_1} {Î´ : Type u_5} [topological_space Î±] [measurable_space Î±]
    [borel_space Î±] [measurable_space Î´] [conditionally_complete_linear_order Î±]
    [topological_space.second_countable_topology Î±] [order_topology Î±] {Î¹ : Type u_2}
    {f : Î¹ â†’ Î´ â†’ Î±} {s : set Î¹} (hs : set.countable s) (hf : âˆ€ (i : Î¹), measurable (f i))
    (bdd : âˆ€ (x : Î´), bdd_above ((fun (i : Î¹) => f i x) '' s)) :
    measurable fun (x : Î´) => Sup ((fun (i : Î¹) => f i x) '' s) :=
  sorry

/-- Convert a `homeomorph` to a `measurable_equiv`. -/
def homemorph.to_measurable_equiv {Î± : Type u_1} {Î² : Type u_2} [topological_space Î±]
    [measurable_space Î±] [borel_space Î±] [topological_space Î²] [measurable_space Î²] [borel_space Î²]
    (h : Î± â‰ƒâ‚œ Î²) : Î± â‰ƒáµ Î² :=
  measurable_equiv.mk (homeomorph.to_equiv h) sorry sorry

protected instance empty.borel_space : borel_space empty :=
  borel_space.mk (Eq.symm borel_eq_top_of_discrete)

protected instance unit.borel_space : borel_space Unit :=
  borel_space.mk (Eq.symm borel_eq_top_of_discrete)

protected instance bool.borel_space : borel_space Bool :=
  borel_space.mk (Eq.symm borel_eq_top_of_discrete)

protected instance nat.borel_space : borel_space â„• :=
  borel_space.mk (Eq.symm borel_eq_top_of_discrete)

protected instance int.borel_space : borel_space â„¤ :=
  borel_space.mk (Eq.symm borel_eq_top_of_discrete)

protected instance rat.borel_space : borel_space â„š :=
  borel_space.mk (Eq.symm borel_eq_top_of_encodable)

protected instance real.measurable_space : measurable_space â„ := borel â„

protected instance real.borel_space : borel_space â„ := borel_space.mk rfl

protected instance nnreal.measurable_space : measurable_space nnreal := borel nnreal

protected instance nnreal.borel_space : borel_space nnreal := borel_space.mk rfl

protected instance ennreal.measurable_space : measurable_space ennreal := borel ennreal

protected instance ennreal.borel_space : borel_space ennreal := borel_space.mk rfl

protected instance complex.measurable_space : measurable_space â„‚ := borel â„‚

protected instance complex.borel_space : borel_space â„‚ := borel_space.mk rfl

theorem is_measurable_ball {Î± : Type u_1} [metric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] {x : Î±} {Îµ : â„} : is_measurable (metric.ball x Îµ) :=
  is_open.is_measurable metric.is_open_ball

theorem is_measurable_closed_ball {Î± : Type u_1} [metric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] {x : Î±} {Îµ : â„} : is_measurable (metric.closed_ball x Îµ) :=
  is_closed.is_measurable metric.is_closed_ball

theorem measurable_inf_dist {Î± : Type u_1} [metric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] {s : set Î±} : measurable fun (x : Î±) => metric.inf_dist x s :=
  continuous.measurable (metric.continuous_inf_dist_pt s)

theorem measurable.inf_dist {Î± : Type u_1} {Î² : Type u_2} [metric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [measurable_space Î²] {f : Î² â†’ Î±} (hf : measurable f) {s : set Î±} :
    measurable fun (x : Î²) => metric.inf_dist (f x) s :=
  measurable.comp measurable_inf_dist hf

theorem measurable_inf_nndist {Î± : Type u_1} [metric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] {s : set Î±} : measurable fun (x : Î±) => metric.inf_nndist x s :=
  continuous.measurable (metric.continuous_inf_nndist_pt s)

theorem measurable.inf_nndist {Î± : Type u_1} {Î² : Type u_2} [metric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [measurable_space Î²] {f : Î² â†’ Î±} (hf : measurable f) {s : set Î±} :
    measurable fun (x : Î²) => metric.inf_nndist (f x) s :=
  measurable.comp measurable_inf_nndist hf

theorem measurable_dist {Î± : Type u_1} [metric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [topological_space.second_countable_topology Î±] :
    measurable fun (p : Î± Ã— Î±) => dist (prod.fst p) (prod.snd p) :=
  continuous.measurable continuous_dist

theorem measurable.dist {Î± : Type u_1} {Î² : Type u_2} [metric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [measurable_space Î²] [topological_space.second_countable_topology Î±]
    {f : Î² â†’ Î±} {g : Î² â†’ Î±} (hf : measurable f) (hg : measurable g) :
    measurable fun (b : Î²) => dist (f b) (g b) :=
  continuous.measurable2 continuous_dist hf hg

theorem measurable_nndist {Î± : Type u_1} [metric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [topological_space.second_countable_topology Î±] :
    measurable fun (p : Î± Ã— Î±) => nndist (prod.fst p) (prod.snd p) :=
  continuous.measurable continuous_nndist

theorem measurable.nndist {Î± : Type u_1} {Î² : Type u_2} [metric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [measurable_space Î²] [topological_space.second_countable_topology Î±]
    {f : Î² â†’ Î±} {g : Î² â†’ Î±} (hf : measurable f) (hg : measurable g) :
    measurable fun (b : Î²) => nndist (f b) (g b) :=
  continuous.measurable2 continuous_nndist hf hg

theorem is_measurable_eball {Î± : Type u_1} [emetric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] {x : Î±} {Îµ : ennreal} : is_measurable (emetric.ball x Îµ) :=
  is_open.is_measurable emetric.is_open_ball

theorem measurable_edist_right {Î± : Type u_1} [emetric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] {x : Î±} : measurable (edist x) :=
  continuous.measurable (continuous.edist continuous_const continuous_id)

theorem measurable_edist_left {Î± : Type u_1} [emetric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] {x : Î±} : measurable fun (y : Î±) => edist y x :=
  continuous.measurable (continuous.edist continuous_id continuous_const)

theorem measurable_inf_edist {Î± : Type u_1} [emetric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] {s : set Î±} : measurable fun (x : Î±) => emetric.inf_edist x s :=
  continuous.measurable emetric.continuous_inf_edist

theorem measurable.inf_edist {Î± : Type u_1} {Î² : Type u_2} [emetric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [measurable_space Î²] {f : Î² â†’ Î±} (hf : measurable f) {s : set Î±} :
    measurable fun (x : Î²) => emetric.inf_edist (f x) s :=
  measurable.comp measurable_inf_edist hf

theorem measurable_edist {Î± : Type u_1} [emetric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [topological_space.second_countable_topology Î±] :
    measurable fun (p : Î± Ã— Î±) => edist (prod.fst p) (prod.snd p) :=
  continuous.measurable continuous_edist

theorem measurable.edist {Î± : Type u_1} {Î² : Type u_2} [emetric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [measurable_space Î²] [topological_space.second_countable_topology Î±]
    {f : Î² â†’ Î±} {g : Î² â†’ Î±} (hf : measurable f) (hg : measurable g) :
    measurable fun (b : Î²) => edist (f b) (g b) :=
  continuous.measurable2 continuous_edist hf hg

theorem ae_measurable.edist {Î± : Type u_1} {Î² : Type u_2} [emetric_space Î±] [measurable_space Î±]
    [opens_measurable_space Î±] [measurable_space Î²] [topological_space.second_countable_topology Î±]
    {f : Î² â†’ Î±} {g : Î² â†’ Î±} {Î¼ : measure_theory.measure Î²} (hf : ae_measurable f)
    (hg : ae_measurable g) : ae_measurable fun (a : Î²) => edist (f a) (g a) :=
  continuous.ae_measurable2 continuous_edist hf hg

namespace real


theorem borel_eq_generate_from_Ioo_rat :
    borel â„ =
        measurable_space.generate_from
          (set.Union
            fun (a : â„š) =>
              set.Union fun (b : â„š) => set.Union fun (h : a < b) => singleton (set.Ioo â†‘a â†‘b)) :=
  borel_eq_generate_from_of_subbasis (and.right (and.right is_topological_basis_Ioo_rat))

theorem measure_ext_Ioo_rat {Î¼ : measure_theory.measure â„} {Î½ : measure_theory.measure â„}
    [measure_theory.locally_finite_measure Î¼]
    (h : âˆ€ (a b : â„š), coe_fn Î¼ (set.Ioo â†‘a â†‘b) = coe_fn Î½ (set.Ioo â†‘a â†‘b)) : Î¼ = Î½ :=
  sorry

theorem borel_eq_generate_from_Iio_rat :
    borel â„ = measurable_space.generate_from (set.Union fun (a : â„š) => singleton (set.Iio â†‘a)) :=
  sorry

end real


theorem measurable.sub_nnreal {Î± : Type u_1} [measurable_space Î±] {f : Î± â†’ nnreal}
    {g : Î± â†’ nnreal} : measurable f â†’ measurable g â†’ measurable fun (a : Î±) => f a - g a :=
  continuous.measurable2 continuous_sub

theorem measurable.nnreal_of_real {Î± : Type u_1} [measurable_space Î±] {f : Î± â†’ â„}
    (hf : measurable f) : measurable fun (x : Î±) => nnreal.of_real (f x) :=
  measurable.comp (continuous.measurable nnreal.continuous_of_real) hf

theorem nnreal.measurable_coe : measurable coe := continuous.measurable nnreal.continuous_coe

theorem measurable.nnreal_coe {Î± : Type u_1} [measurable_space Î±] {f : Î± â†’ nnreal}
    (hf : measurable f) : measurable fun (x : Î±) => â†‘(f x) :=
  measurable.comp nnreal.measurable_coe hf

theorem measurable.ennreal_coe {Î± : Type u_1} [measurable_space Î±] {f : Î± â†’ nnreal}
    (hf : measurable f) : measurable fun (x : Î±) => â†‘(f x) :=
  measurable.comp (continuous.measurable ennreal.continuous_coe) hf

theorem ae_measurable.ennreal_coe {Î± : Type u_1} [measurable_space Î±] {f : Î± â†’ nnreal}
    {Î¼ : measure_theory.measure Î±} (hf : ae_measurable f) : ae_measurable fun (x : Î±) => â†‘(f x) :=
  measurable.comp_ae_measurable (continuous.measurable ennreal.continuous_coe) hf

theorem measurable.ennreal_of_real {Î± : Type u_1} [measurable_space Î±] {f : Î± â†’ â„}
    (hf : measurable f) : measurable fun (x : Î±) => ennreal.of_real (f x) :=
  measurable.comp (continuous.measurable ennreal.continuous_of_real) hf

/-- The set of finite `ennreal` numbers is `measurable_equiv` to `â„â‰¥0`. -/
def measurable_equiv.ennreal_equiv_nnreal : â†¥(set_of fun (r : ennreal) => r â‰  âŠ¤) â‰ƒáµ nnreal :=
  homeomorph.to_measurable_equiv ennreal.ne_top_homeomorph_nnreal

namespace ennreal


theorem measurable_coe : measurable coe := measurable.ennreal_coe measurable_id

theorem measurable_of_measurable_nnreal {Î± : Type u_1} [measurable_space Î±] {f : ennreal â†’ Î±}
    (h : measurable fun (p : nnreal) => f â†‘p) : measurable f :=
  measurable_of_measurable_on_compl_singleton âŠ¤
    (iff.mp
      (measurable_equiv.measurable_coe_iff
        (measurable_equiv.symm measurable_equiv.ennreal_equiv_nnreal))
      h)

/-- `ennreal` is `measurable_equiv` to `â„â‰¥0 âŠ• unit`. -/
def ennreal_equiv_sum : ennreal â‰ƒáµ nnreal âŠ• Unit :=
  measurable_equiv.mk
    (equiv.mk (equiv.to_fun (equiv.option_equiv_sum_punit nnreal))
      (equiv.inv_fun (equiv.option_equiv_sum_punit nnreal)) sorry sorry)
    sorry sorry

theorem measurable_of_measurable_nnreal_prod {Î² : Type u_2} {Î³ : Type u_3} [measurable_space Î²]
    [measurable_space Î³] {f : ennreal Ã— Î² â†’ Î³}
    (Hâ‚ : measurable fun (p : nnreal Ã— Î²) => f (â†‘(prod.fst p), prod.snd p))
    (Hâ‚‚ : measurable fun (x : Î²) => f (âŠ¤, x)) : measurable f :=
  sorry

theorem measurable_of_measurable_nnreal_nnreal {Î² : Type u_2} [measurable_space Î²]
    {f : ennreal Ã— ennreal â†’ Î²}
    (hâ‚ : measurable fun (p : nnreal Ã— nnreal) => f (â†‘(prod.fst p), â†‘(prod.snd p)))
    (hâ‚‚ : measurable fun (r : nnreal) => f (âŠ¤, â†‘r))
    (hâ‚ƒ : measurable fun (r : nnreal) => f (â†‘r, âŠ¤)) : measurable f :=
  measurable_of_measurable_nnreal_prod
    (iff.mp measurable_swap_iff
      (measurable_of_measurable_nnreal_prod (measurable.comp hâ‚ measurable_swap) hâ‚ƒ))
    (measurable_of_measurable_nnreal hâ‚‚)

theorem measurable_of_real : measurable ennreal.of_real := continuous.measurable continuous_of_real

theorem measurable_to_real : measurable ennreal.to_real :=
  measurable_of_measurable_nnreal nnreal.measurable_coe

theorem measurable_to_nnreal : measurable ennreal.to_nnreal :=
  measurable_of_measurable_nnreal measurable_id

theorem measurable_mul : measurable fun (p : ennreal Ã— ennreal) => prod.fst p * prod.snd p := sorry

theorem measurable_sub : measurable fun (p : ennreal Ã— ennreal) => prod.fst p - prod.snd p := sorry

theorem measurable_inv : measurable has_inv.inv := continuous.measurable ennreal.continuous_inv

theorem measurable_div : measurable fun (p : ennreal Ã— ennreal) => prod.fst p / prod.snd p :=
  measurable.comp measurable_mul
    (measurable.prod_mk measurable_fst (measurable.comp measurable_inv measurable_snd))

end ennreal


theorem measurable.to_nnreal {Î± : Type u_1} [measurable_space Î±] {f : Î± â†’ ennreal}
    (hf : measurable f) : measurable fun (x : Î±) => ennreal.to_nnreal (f x) :=
  measurable.comp ennreal.measurable_to_nnreal hf

theorem measurable_ennreal_coe_iff {Î± : Type u_1} [measurable_space Î±] {f : Î± â†’ nnreal} :
    (measurable fun (x : Î±) => â†‘(f x)) â†” measurable f :=
  { mp := fun (h : measurable fun (x : Î±) => â†‘(f x)) => measurable.to_nnreal h,
    mpr := fun (h : measurable f) => measurable.ennreal_coe h }

theorem measurable.to_real {Î± : Type u_1} [measurable_space Î±] {f : Î± â†’ ennreal}
    (hf : measurable f) : measurable fun (x : Î±) => ennreal.to_real (f x) :=
  measurable.comp ennreal.measurable_to_real hf

theorem ae_measurable.to_real {Î± : Type u_1} [measurable_space Î±] {f : Î± â†’ ennreal}
    {Î¼ : measure_theory.measure Î±} (hf : ae_measurable f) :
    ae_measurable fun (x : Î±) => ennreal.to_real (f x) :=
  measurable.comp_ae_measurable ennreal.measurable_to_real hf

theorem measurable.ennreal_mul {Î± : Type u_1} [measurable_space Î±] {f : Î± â†’ ennreal}
    {g : Î± â†’ ennreal} (hf : measurable f) (hg : measurable g) :
    measurable fun (a : Î±) => f a * g a :=
  measurable.comp ennreal.measurable_mul (measurable.prod_mk hf hg)

theorem ae_measurable.ennreal_mul {Î± : Type u_1} [measurable_space Î±] {f : Î± â†’ ennreal}
    {g : Î± â†’ ennreal} {Î¼ : measure_theory.measure Î±} (hf : ae_measurable f) (hg : ae_measurable g) :
    ae_measurable fun (a : Î±) => f a * g a :=
  measurable.comp_ae_measurable ennreal.measurable_mul (ae_measurable.prod_mk hf hg)

theorem measurable.ennreal_sub {Î± : Type u_1} [measurable_space Î±] {f : Î± â†’ ennreal}
    {g : Î± â†’ ennreal} (hf : measurable f) (hg : measurable g) :
    measurable fun (a : Î±) => f a - g a :=
  measurable.comp ennreal.measurable_sub (measurable.prod_mk hf hg)

/-- note: `ennreal` can probably be generalized in a future version of this lemma. -/
theorem measurable.ennreal_tsum {Î± : Type u_1} [measurable_space Î±] {Î¹ : Type u_2} [encodable Î¹]
    {f : Î¹ â†’ Î± â†’ ennreal} (h : âˆ€ (i : Î¹), measurable (f i)) :
    measurable fun (x : Î±) => tsum fun (i : Î¹) => f i x :=
  sorry

theorem measurable.ennreal_inv {Î± : Type u_1} [measurable_space Î±] {f : Î± â†’ ennreal}
    (hf : measurable f) : measurable fun (a : Î±) => f aâ»Â¹ :=
  measurable.comp ennreal.measurable_inv hf

theorem measurable.ennreal_div {Î± : Type u_1} [measurable_space Î±] {f : Î± â†’ ennreal}
    {g : Î± â†’ ennreal} (hf : measurable f) (hg : measurable g) :
    measurable fun (a : Î±) => f a / g a :=
  measurable.comp ennreal.measurable_div (measurable.prod_mk hf hg)

theorem measurable_norm {Î± : Type u_1} [measurable_space Î±] [normed_group Î±]
    [opens_measurable_space Î±] : measurable norm :=
  continuous.measurable continuous_norm

theorem measurable.norm {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [normed_group Î±]
    [opens_measurable_space Î±] [measurable_space Î²] {f : Î² â†’ Î±} (hf : measurable f) :
    measurable fun (a : Î²) => norm (f a) :=
  measurable.comp measurable_norm hf

theorem ae_measurable.norm {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [normed_group Î±]
    [opens_measurable_space Î±] [measurable_space Î²] {f : Î² â†’ Î±} {Î¼ : measure_theory.measure Î²}
    (hf : ae_measurable f) : ae_measurable fun (a : Î²) => norm (f a) :=
  measurable.comp_ae_measurable measurable_norm hf

theorem measurable_nnnorm {Î± : Type u_1} [measurable_space Î±] [normed_group Î±]
    [opens_measurable_space Î±] : measurable nnnorm :=
  continuous.measurable continuous_nnnorm

theorem measurable.nnnorm {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [normed_group Î±]
    [opens_measurable_space Î±] [measurable_space Î²] {f : Î² â†’ Î±} (hf : measurable f) :
    measurable fun (a : Î²) => nnnorm (f a) :=
  measurable.comp measurable_nnnorm hf

theorem ae_measurable.nnnorm {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [normed_group Î±]
    [opens_measurable_space Î±] [measurable_space Î²] {f : Î² â†’ Î±} {Î¼ : measure_theory.measure Î²}
    (hf : ae_measurable f) : ae_measurable fun (a : Î²) => nnnorm (f a) :=
  measurable.comp_ae_measurable measurable_nnnorm hf

theorem measurable_ennnorm {Î± : Type u_1} [measurable_space Î±] [normed_group Î±]
    [opens_measurable_space Î±] : measurable fun (x : Î±) => â†‘(nnnorm x) :=
  measurable.ennreal_coe measurable_nnnorm

theorem measurable.ennnorm {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [normed_group Î±]
    [opens_measurable_space Î±] [measurable_space Î²] {f : Î² â†’ Î±} (hf : measurable f) :
    measurable fun (a : Î²) => â†‘(nnnorm (f a)) :=
  measurable.ennreal_coe (measurable.nnnorm hf)

theorem ae_measurable.ennnorm {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [normed_group Î±]
    [opens_measurable_space Î±] [measurable_space Î²] {f : Î² â†’ Î±} {Î¼ : measure_theory.measure Î²}
    (hf : ae_measurable f) : ae_measurable fun (a : Î²) => â†‘(nnnorm (f a)) :=
  measurable.comp_ae_measurable measurable_ennnorm hf

/-- A limit (over a general filter) of measurable `â„â‰¥0` valued functions is measurable.
The assumption `hs` can be dropped using `filter.is_countably_generated.has_antimono_basis`, but we
don't need that case yet. -/
theorem measurable_of_tendsto_nnreal' {Î± : Type u_1} [measurable_space Î±] {Î¹ : Type u_2}
    {Î¹' : Type u_3} {f : Î¹ â†’ Î± â†’ nnreal} {g : Î± â†’ nnreal} (u : filter Î¹) [filter.ne_bot u]
    (hf : âˆ€ (i : Î¹), measurable (f i)) (lim : filter.tendsto f u (nhds g)) {p : Î¹' â†’ Prop}
    {s : Î¹' â†’ set Î¹} (hu : filter.has_countable_basis u p s)
    (hs : âˆ€ (i : Î¹'), set.countable (s i)) : measurable g :=
  sorry

/-- A sequential limit of measurable `â„â‰¥0` valued functions is measurable. -/
theorem measurable_of_tendsto_nnreal {Î± : Type u_1} [measurable_space Î±] {f : â„• â†’ Î± â†’ nnreal}
    {g : Î± â†’ nnreal} (hf : âˆ€ (i : â„•), measurable (f i))
    (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g :=
  measurable_of_tendsto_nnreal' filter.at_top hf lim filter.at_top_countable_basis
    fun (i : â„•) => set.countable_encodable (set.Ici i)

/-- A limit (over a general filter) of measurable functions valued in a metric space is measurable.
The assumption `hs` can be dropped using `filter.is_countably_generated.has_antimono_basis`, but we
don't need that case yet. -/
theorem measurable_of_tendsto_metric' {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±]
    [measurable_space Î²] [metric_space Î²] [borel_space Î²] {Î¹ : Type u_3} {Î¹' : Type u_4}
    {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (u : filter Î¹) [filter.ne_bot u] (hf : âˆ€ (i : Î¹), measurable (f i))
    (lim : filter.tendsto f u (nhds g)) {p : Î¹' â†’ Prop} {s : Î¹' â†’ set Î¹}
    (hu : filter.has_countable_basis u p s) (hs : âˆ€ (i : Î¹'), set.countable (s i)) : measurable g :=
  sorry

/-- A sequential limit of measurable functions valued in a metric space is measurable. -/
theorem measurable_of_tendsto_metric {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±]
    [measurable_space Î²] [metric_space Î²] [borel_space Î²] {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²}
    (hf : âˆ€ (i : â„•), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) :
    measurable g :=
  measurable_of_tendsto_metric' filter.at_top hf lim filter.at_top_countable_basis
    fun (i : â„•) => set.countable_encodable (set.Ici i)

theorem ae_measurable_of_tendsto_metric_ae {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±]
    [measurable_space Î²] [metric_space Î²] [borel_space Î²] {Î¼ : measure_theory.measure Î±}
    {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hf : âˆ€ (n : â„•), ae_measurable (f n))
    (h_ae_tendsto :
      filter.eventually
        (fun (x : Î±) => filter.tendsto (fun (n : â„•) => f n x) filter.at_top (nhds (g x)))
        (measure_theory.measure.ae Î¼)) :
    ae_measurable g :=
  sorry

theorem measurable_of_tendsto_metric_ae {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±]
    [measurable_space Î²] [metric_space Î²] [borel_space Î²] {Î¼ : measure_theory.measure Î±}
    [measure_theory.measure.is_complete Î¼] {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²}
    (hf : âˆ€ (n : â„•), measurable (f n))
    (h_ae_tendsto :
      filter.eventually
        (fun (x : Î±) => filter.tendsto (fun (n : â„•) => f n x) filter.at_top (nhds (g x)))
        (measure_theory.measure.ae Î¼)) :
    measurable g :=
  iff.mp ae_measurable_iff_measurable
    (ae_measurable_of_tendsto_metric_ae (fun (i : â„•) => measurable.ae_measurable (hf i))
      h_ae_tendsto)

theorem measurable_limit_of_tendsto_metric_ae {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±]
    [measurable_space Î²] [metric_space Î²] [borel_space Î²] {Î¼ : measure_theory.measure Î±}
    {f : â„• â†’ Î± â†’ Î²} (hf : âˆ€ (n : â„•), ae_measurable (f n))
    (h_ae_tendsto :
      filter.eventually
        (fun (x : Î±) => âˆƒ (l : Î²), filter.tendsto (fun (n : â„•) => f n x) filter.at_top (nhds l))
        (measure_theory.measure.ae Î¼)) :
    âˆƒ (f_lim : Î± â†’ Î²),
        âˆƒ (hf_lim_meas : measurable f_lim),
          filter.eventually
            (fun (x : Î±) => filter.tendsto (fun (n : â„•) => f n x) filter.at_top (nhds (f_lim x)))
            (measure_theory.measure.ae Î¼) :=
  sorry

namespace continuous_linear_map


protected theorem measurable {ð•œ : Type u_6} [normed_field ð•œ] {E : Type u_7} [normed_group E]
    [normed_space ð•œ E] [measurable_space E] [opens_measurable_space E] {F : Type u_8}
    [normed_group F] [normed_space ð•œ F] [measurable_space F] [borel_space F]
    (L : continuous_linear_map ð•œ E F) : measurable â‡‘L :=
  continuous.measurable (continuous_linear_map.continuous L)

theorem measurable_comp {Î± : Type u_1} [measurable_space Î±] {ð•œ : Type u_6} [normed_field ð•œ]
    {E : Type u_7} [normed_group E] [normed_space ð•œ E] [measurable_space E]
    [opens_measurable_space E] {F : Type u_8} [normed_group F] [normed_space ð•œ F]
    [measurable_space F] [borel_space F] (L : continuous_linear_map ð•œ E F) {Ï† : Î± â†’ E}
    (Ï†_meas : measurable Ï†) : measurable fun (a : Î±) => coe_fn L (Ï† a) :=
  measurable.comp (continuous_linear_map.measurable L) Ï†_meas

end continuous_linear_map


theorem measurable_smul_const {Î± : Type u_1} [measurable_space Î±] {ð•œ : Type u_6}
    [nondiscrete_normed_field ð•œ] [complete_space ð•œ] [measurable_space ð•œ] [borel_space ð•œ]
    {E : Type u_7} [normed_group E] [normed_space ð•œ E] [measurable_space E] [borel_space E]
    {f : Î± â†’ ð•œ} {c : E} (hc : c â‰  0) : (measurable fun (x : Î±) => f x â€¢ c) â†” measurable f :=
  measurable_comp_iff_of_closed_embedding (fun (y : ð•œ) => y â€¢ c) (closed_embedding_smul_left hc)

theorem ae_measurable_smul_const {Î± : Type u_1} [measurable_space Î±] {ð•œ : Type u_6}
    [nondiscrete_normed_field ð•œ] [complete_space ð•œ] [measurable_space ð•œ] [borel_space ð•œ]
    {E : Type u_7} [normed_group E] [normed_space ð•œ E] [measurable_space E] [borel_space E]
    {f : Î± â†’ ð•œ} {Î¼ : measure_theory.measure Î±} {c : E} (hc : c â‰  0) :
    (ae_measurable fun (x : Î±) => f x â€¢ c) â†” ae_measurable f :=
  ae_measurable_comp_iff_of_closed_embedding (fun (y : ð•œ) => y â€¢ c) (closed_embedding_smul_left hc)

namespace measure_theory


namespace measure


/-- A measure `Î¼` is regular if
  - it is finite on all compact sets;
  - it is outer regular: `Î¼(A) = inf { Î¼(U) | A âŠ† U open }` for `A` measurable;
  - it is inner regular: `Î¼(U) = sup { Î¼(K) | K âŠ† U compact }` for `U` open. -/
structure regular {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] (Î¼ : measure Î±) where
  lt_top_of_is_compact : âˆ€ {K : set Î±}, is_compact K â†’ coe_fn Î¼ K < âŠ¤
  outer_regular :
    âˆ€ {A : set Î±},
      is_measurable A â†’
        (infi fun (U : set Î±) => infi fun (h : is_open U) => infi fun (h2 : A âŠ† U) => coe_fn Î¼ U) â‰¤
          coe_fn Î¼ A
  inner_regular :
    âˆ€ {U : set Î±},
      is_open U â†’
        coe_fn Î¼ U â‰¤
          supr fun (K : set Î±) => supr fun (h : is_compact K) => supr fun (h2 : K âŠ† U) => coe_fn Î¼ K

namespace regular


theorem outer_regular_eq {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure Î±}
    (hÎ¼ : regular Î¼) {A : set Î±} (hA : is_measurable A) :
    (infi fun (U : set Î±) => infi fun (h : is_open U) => infi fun (h2 : A âŠ† U) => coe_fn Î¼ U) =
        coe_fn Î¼ A :=
  sorry

theorem inner_regular_eq {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure Î±}
    (hÎ¼ : regular Î¼) {U : set Î±} (hU : is_open U) :
    (supr fun (K : set Î±) => supr fun (h : is_compact K) => supr fun (h2 : K âŠ† U) => coe_fn Î¼ K) =
        coe_fn Î¼ U :=
  sorry

theorem exists_compact_not_null {Î± : Type u_1} [measurable_space Î±] [topological_space Î±]
    {Î¼ : measure Î±} (hÎ¼ : regular Î¼) : (âˆƒ (K : set Î±), is_compact K âˆ§ coe_fn Î¼ K â‰  0) â†” Î¼ â‰  0 :=
  sorry

protected theorem map {Î± : Type u_1} {Î² : Type u_2} [measurable_space Î±] [topological_space Î±]
    {Î¼ : measure Î±} [opens_measurable_space Î±] [measurable_space Î²] [topological_space Î²]
    [t2_space Î²] [borel_space Î²] (hÎ¼ : regular Î¼) (f : Î± â‰ƒâ‚œ Î²) : regular (coe_fn (map â‡‘f) Î¼) :=
  sorry

protected theorem smul {Î± : Type u_1} [measurable_space Î±] [topological_space Î±] {Î¼ : measure Î±}
    (hÎ¼ : regular Î¼) {x : ennreal} (hx : x < âŠ¤) : regular (x â€¢ Î¼) :=
  sorry

/-- A regular measure in a Ïƒ-compact space is Ïƒ-finite. -/
protected theorem sigma_finite {Î± : Type u_1} [measurable_space Î±] [topological_space Î±]
    {Î¼ : measure Î±} [opens_measurable_space Î±] [t2_space Î±] [sigma_compact_space Î±]
    (hÎ¼ : regular Î¼) : sigma_finite Î¼ :=
  sorry

end regular


end measure


end measure_theory


theorem is_compact.measure_lt_top_of_nhds_within {Î± : Type u_1} [measurable_space Î±]
    [topological_space Î±] {s : set Î±} {Î¼ : measure_theory.measure Î±} (h : is_compact s)
    (hÎ¼ : âˆ€ (x : Î±), x âˆˆ s â†’ measure_theory.measure.finite_at_filter Î¼ (nhds_within x s)) :
    coe_fn Î¼ s < âŠ¤ :=
  sorry

theorem is_compact.measure_lt_top {Î± : Type u_1} [measurable_space Î±] [topological_space Î±]
    {s : set Î±} {Î¼ : measure_theory.measure Î±} [measure_theory.locally_finite_measure Î¼]
    (h : is_compact s) : coe_fn Î¼ s < âŠ¤ :=
  is_compact.measure_lt_top_of_nhds_within h
    fun (x : Î±) (hx : x âˆˆ s) => measure_theory.measure.finite_at_nhds_within Î¼ x s

end Mathlib