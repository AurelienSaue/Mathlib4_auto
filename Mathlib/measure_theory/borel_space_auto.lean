/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Yury Kudryashov
-/
import PrePort
import Lean3Lib.init.default
import Mathlib.measure_theory.measure_space
import Mathlib.measure_theory.ae_measurable_sequence
import Mathlib.analysis.complex.basic
import Mathlib.analysis.normed_space.finite_dimension
import Mathlib.topology.G_delta
import PostPort

universes u u_1 u_2 u_6 l u_3 u_5 u_4 u_7 u_8 

namespace Mathlib

/-!
# Borel (measurable) space

## Main definitions

* `borel Œ±` : the least `œÉ`-algebra that contains all open sets;
* `class borel_space` : a space with `topological_space` and `measurable_space` structures
  such that `‚Äπmeasurable_space Œ±‚Ä∫ = borel Œ±`;
* `class opens_measurable_space` : a space with `topological_space` and `measurable_space`
  structures such that all open sets are measurable; equivalently, `borel Œ± ‚â§ ‚Äπmeasurable_space Œ±‚Ä∫`.
* `borel_space` instances on `empty`, `unit`, `bool`, `nat`, `int`, `rat`;
* `measurable` and `borel_space` instances on `‚Ñù`, `‚Ñù‚â•0`, `ennreal`.
* A measure is `regular` if it is finite on compact sets, inner regular and outer regular.

## Main statements

* `is_open.is_measurable`, `is_closed.is_measurable`: open and closed sets are measurable;
* `continuous.measurable` : a continuous function is measurable;
* `continuous.measurable2` : if `f : Œ± ‚Üí Œ≤` and `g : Œ± ‚Üí Œ≥` are measurable and `op : Œ≤ √ó Œ≥ ‚Üí Œ¥`
  is continuous, then `Œª x, op (f x, g y)` is measurable;
* `measurable.add` etc : dot notation for arithmetic operations on `measurable` predicates,
  and similarly for `dist` and `edist`;
* `ae_measurable.add` : similar dot notation for almost everywhere measurable functions;
* `measurable.ennreal*` : special cases for arithmetic operations on `ennreal`s.
-/

/-- `measurable_space` structure generated by `topological_space`. -/
def borel (Œ± : Type u) [topological_space Œ±] : measurable_space Œ± :=
  measurable_space.generate_from (set_of fun (s : set Œ±) => is_open s)

theorem borel_eq_top_of_discrete {Œ± : Type u_1} [topological_space Œ±] [discrete_topology Œ±] : borel Œ± = ‚ä§ :=
  iff.mp top_le_iff
    fun (s : set Œ±) (hs : measurable_space.is_measurable' ‚ä§ s) =>
      measurable_space.generate_measurable.basic s (is_open_discrete s)

theorem borel_eq_top_of_encodable {Œ± : Type u_1} [topological_space Œ±] [t1_space Œ±] [encodable Œ±] : borel Œ± = ‚ä§ := sorry

theorem borel_eq_generate_from_of_subbasis {Œ± : Type u_1} {s : set (set Œ±)} [t : topological_space Œ±] [topological_space.second_countable_topology Œ±] (hs : t = topological_space.generate_from s) : borel Œ± = measurable_space.generate_from s := sorry

theorem is_pi_system_is_open {Œ± : Type u_1} [topological_space Œ±] : is_pi_system is_open :=
  fun (s t : set Œ±) (hs : s ‚àà is_open) (ht : t ‚àà is_open) (hst : set.nonempty (s ‚à© t)) => is_open_inter hs ht

theorem borel_eq_generate_Iio (Œ± : Type u_1) [topological_space Œ±] [topological_space.second_countable_topology Œ±] [linear_order Œ±] [order_topology Œ±] : borel Œ± = measurable_space.generate_from (set.range set.Iio) := sorry

theorem borel_eq_generate_Ioi (Œ± : Type u_1) [topological_space Œ±] [topological_space.second_countable_topology Œ±] [linear_order Œ±] [order_topology Œ±] : borel Œ± = measurable_space.generate_from (set.range set.Ioi) :=
  borel_eq_generate_Iio (order_dual Œ±)

theorem borel_comap {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {t : topological_space Œ≤} : borel Œ± = measurable_space.comap f (borel Œ≤) :=
  Eq.symm measurable_space.comap_generate_from

theorem continuous.borel_measurable {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} (hf : continuous f) : measurable f := sorry

/-- A space with `measurable_space` and `topological_space` structures such that
all open sets are measurable. -/
class opens_measurable_space (Œ± : Type u_6) [topological_space Œ±] [h : measurable_space Œ±] 
where
  borel_le : borel Œ± ‚â§ h

/-- A space with `measurable_space` and `topological_space` structures such that
the `œÉ`-algebra of measurable sets is exactly the `œÉ`-algebra generated by open sets. -/
class borel_space (Œ± : Type u_6) [topological_space Œ±] [measurable_space Œ±] 
where
  measurable_eq : _inst_2 = borel Œ±

/-- In a `borel_space` all open sets are measurable. -/
protected instance borel_space.opens_measurable {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] : opens_measurable_space Œ± :=
  opens_measurable_space.mk (ge_of_eq borel_space.measurable_eq)

protected instance subtype.borel_space {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [hŒ± : borel_space Œ±] (s : set Œ±) : borel_space ‚Ü•s :=
  borel_space.mk
    (eq.mpr (id (Eq._oldrec (Eq.refl (subtype.measurable_space = borel ‚Ü•s)) borel_space.measurable_eq))
      (eq.mpr (id (Eq._oldrec (Eq.refl (subtype.measurable_space = borel ‚Ü•s)) subtype.measurable_space.equations._eqn_1))
        (eq.mpr (id (Eq._oldrec (Eq.refl (measurable_space.comap coe (borel Œ±) = borel ‚Ü•s)) (Eq.symm borel_comap)))
          (Eq.refl (borel (Subtype fun (x : Œ±) => x ‚àà s))))))

protected instance subtype.opens_measurable_space {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [h : opens_measurable_space Œ±] (s : set Œ±) : opens_measurable_space ‚Ü•s :=
  opens_measurable_space.mk
    (eq.mpr (id (Eq._oldrec (Eq.refl (borel ‚Ü•s ‚â§ subtype.measurable_space)) borel_comap))
      (measurable_space.comap_mono opens_measurable_space.borel_le))

theorem is_open.is_measurable {Œ± : Type u_1} {s : set Œ±} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] (h : is_open s) : is_measurable s :=
  opens_measurable_space.borel_le s (measurable_space.generate_measurable.basic s h)

theorem is_measurable_interior {Œ± : Type u_1} {s : set Œ±} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] : is_measurable (interior s) :=
  is_open.is_measurable is_open_interior

theorem is_GŒ¥.is_measurable {Œ± : Type u_1} {s : set Œ±} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] (h : is_GŒ¥ s) : is_measurable s := sorry

theorem is_measurable_set_of_continuous_at {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] {Œ≤ : Type u_2} [emetric_space Œ≤] (f : Œ± ‚Üí Œ≤) : is_measurable (set_of fun (x : Œ±) => continuous_at f x) :=
  is_GŒ¥.is_measurable (is_GŒ¥_set_of_continuous_at f)

theorem is_closed.is_measurable {Œ± : Type u_1} {s : set Œ±} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] (h : is_closed s) : is_measurable s :=
  is_measurable.of_compl (is_open.is_measurable h)

theorem is_compact.is_measurable {Œ± : Type u_1} {s : set Œ±} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [t2_space Œ±] (h : is_compact s) : is_measurable s :=
  is_closed.is_measurable (is_compact.is_closed h)

theorem is_measurable_closure {Œ± : Type u_1} {s : set Œ±} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] : is_measurable (closure s) :=
  is_closed.is_measurable is_closed_closure

theorem measurable_of_is_open {Œ≥ : Type u_3} {Œ¥ : Type u_5} [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] [measurable_space Œ¥] {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ (s : set Œ≥), is_open s ‚Üí is_measurable (f ‚Åª¬π' s)) : measurable f :=
  eq.mpr (id (Eq._oldrec (Eq.refl (measurable f)) borel_space.measurable_eq)) (measurable_generate_from hf)

theorem measurable_of_is_closed {Œ≥ : Type u_3} {Œ¥ : Type u_5} [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] [measurable_space Œ¥] {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ (s : set Œ≥), is_closed s ‚Üí is_measurable (f ‚Åª¬π' s)) : measurable f := sorry

theorem measurable_of_is_closed' {Œ≥ : Type u_3} {Œ¥ : Type u_5} [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] [measurable_space Œ¥] {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ (s : set Œ≥), is_closed s ‚Üí set.nonempty s ‚Üí s ‚â† set.univ ‚Üí is_measurable (f ‚Åª¬π' s)) : measurable f := sorry

protected instance nhds_is_measurably_generated {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] (a : Œ±) : filter.is_measurably_generated (nhds a) :=
  eq.mpr (id (Eq._oldrec (Eq.refl (filter.is_measurably_generated (nhds a))) (nhds.equations._eqn_1 a)))
    (eq.mpr
      (id
        (Eq._oldrec
          (Eq.refl
            (filter.is_measurably_generated
              (infi
                fun (s : set Œ±) => infi fun (H : s ‚àà set_of fun (s : set Œ±) => a ‚àà s ‚àß is_open s) => filter.principal s)))
          infi_subtype'))
      filter.infi_is_measurably_generated)

/-- If `s` is a measurable set, then `ùìù[s] a` is a measurably generated filter for
each `a`. This cannot be an `instance` because it depends on a non-instance `hs : is_measurable s`.
-/
theorem is_measurable.nhds_within_is_measurably_generated {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] {s : set Œ±} (hs : is_measurable s) (a : Œ±) : filter.is_measurably_generated (nhds_within a s) :=
  filter.inf_is_measurably_generated (nhds a) (filter.principal s)

protected instance opens_measurable_space.to_measurable_singleton_class {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [t1_space Œ±] : measurable_singleton_class Œ± :=
  measurable_singleton_class.mk fun (x : Œ±) => is_closed.is_measurable is_closed_singleton

protected instance pi.opens_measurable_space {Œπ : Type u_1} {œÄ : Œπ ‚Üí Type u_2} [fintype Œπ] [t' : (i : Œπ) ‚Üí topological_space (œÄ i)] [(i : Œπ) ‚Üí measurable_space (œÄ i)] [‚àÄ (i : Œπ), topological_space.second_countable_topology (œÄ i)] [‚àÄ (i : Œπ), opens_measurable_space (œÄ i)] : opens_measurable_space ((i : Œπ) ‚Üí œÄ i) := sorry

protected instance prod.opens_measurable_space {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [topological_space Œ≤] [measurable_space Œ≤] [opens_measurable_space Œ≤] [topological_space.second_countable_topology Œ±] [topological_space.second_countable_topology Œ≤] : opens_measurable_space (Œ± √ó Œ≤) := sorry

@[simp] theorem is_measurable_Ici {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [preorder Œ±] [order_closed_topology Œ±] {a : Œ±} : is_measurable (set.Ici a) :=
  is_closed.is_measurable is_closed_Ici

@[simp] theorem is_measurable_Iic {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [preorder Œ±] [order_closed_topology Œ±] {a : Œ±} : is_measurable (set.Iic a) :=
  is_closed.is_measurable is_closed_Iic

@[simp] theorem is_measurable_Icc {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [preorder Œ±] [order_closed_topology Œ±] {a : Œ±} {b : Œ±} : is_measurable (set.Icc a b) :=
  is_closed.is_measurable is_closed_Icc

protected instance nhds_within_Ici_is_measurably_generated {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [preorder Œ±] [order_closed_topology Œ±] {a : Œ±} {b : Œ±} : filter.is_measurably_generated (nhds_within a (set.Ici b)) :=
  is_measurable.nhds_within_is_measurably_generated is_measurable_Ici a

protected instance nhds_within_Iic_is_measurably_generated {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [preorder Œ±] [order_closed_topology Œ±] {a : Œ±} {b : Œ±} : filter.is_measurably_generated (nhds_within a (set.Iic b)) :=
  is_measurable.nhds_within_is_measurably_generated is_measurable_Iic a

protected instance at_top_is_measurably_generated {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [preorder Œ±] [order_closed_topology Œ±] : filter.is_measurably_generated filter.at_top :=
  filter.infi_is_measurably_generated

protected instance at_bot_is_measurably_generated {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [preorder Œ±] [order_closed_topology Œ±] : filter.is_measurably_generated filter.at_bot :=
  filter.infi_is_measurably_generated

theorem is_measurable_le' {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [partial_order Œ±] [order_closed_topology Œ±] [topological_space.second_countable_topology Œ±] : is_measurable (set_of fun (p : Œ± √ó Œ±) => prod.fst p ‚â§ prod.snd p) :=
  is_closed.is_measurable order_closed_topology.is_closed_le'

theorem is_measurable_le {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [measurable_space Œ¥] [partial_order Œ±] [order_closed_topology Œ±] [topological_space.second_countable_topology Œ±] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) : is_measurable (set_of fun (a : Œ¥) => f a ‚â§ g a) :=
  measurable.prod_mk hf hg is_measurable_le'

@[simp] theorem is_measurable_Iio {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] {a : Œ±} : is_measurable (set.Iio a) :=
  is_open.is_measurable is_open_Iio

@[simp] theorem is_measurable_Ioi {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] {a : Œ±} : is_measurable (set.Ioi a) :=
  is_open.is_measurable is_open_Ioi

@[simp] theorem is_measurable_Ioo {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] {a : Œ±} {b : Œ±} : is_measurable (set.Ioo a b) :=
  is_open.is_measurable is_open_Ioo

@[simp] theorem is_measurable_Ioc {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] {a : Œ±} {b : Œ±} : is_measurable (set.Ioc a b) :=
  is_measurable.inter is_measurable_Ioi is_measurable_Iic

@[simp] theorem is_measurable_Ico {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] {a : Œ±} {b : Œ±} : is_measurable (set.Ico a b) :=
  is_measurable.inter is_measurable_Ici is_measurable_Iio

protected instance nhds_within_Ioi_is_measurably_generated {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] {a : Œ±} {b : Œ±} : filter.is_measurably_generated (nhds_within a (set.Ioi b)) :=
  is_measurable.nhds_within_is_measurably_generated is_measurable_Ioi a

protected instance nhds_within_Iio_is_measurably_generated {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] {a : Œ±} {b : Œ±} : filter.is_measurably_generated (nhds_within a (set.Iio b)) :=
  is_measurable.nhds_within_is_measurably_generated is_measurable_Iio a

theorem is_measurable_lt' {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] [topological_space.second_countable_topology Œ±] : is_measurable (set_of fun (p : Œ± √ó Œ±) => prod.fst p < prod.snd p) :=
  is_open.is_measurable (is_open_lt continuous_fst continuous_snd)

theorem is_measurable_lt {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [measurable_space Œ¥] [linear_order Œ±] [order_closed_topology Œ±] [topological_space.second_countable_topology Œ±] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) : is_measurable (set_of fun (a : Œ¥) => f a < g a) :=
  measurable.prod_mk hf hg is_measurable_lt'

theorem is_measurable_interval {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] {a : Œ±} {b : Œ±} : is_measurable (set.interval a b) :=
  is_measurable_Icc

theorem measurable.max {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [measurable_space Œ¥] [linear_order Œ±] [order_closed_topology Œ±] [topological_space.second_countable_topology Œ±] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) : measurable fun (a : Œ¥) => max (f a) (g a) :=
  measurable.piecewise (is_measurable_le hg hf) hf hg

theorem ae_measurable.max {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [measurable_space Œ¥] [linear_order Œ±] [order_closed_topology Œ±] [topological_space.second_countable_topology Œ±] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} {Œº : measure_theory.measure Œ¥} (hf : ae_measurable f) (hg : ae_measurable g) : ae_measurable fun (a : Œ¥) => max (f a) (g a) :=
  Exists.intro (fun (a : Œ¥) => max (ae_measurable.mk f hf a) (ae_measurable.mk g hg a))
    { left := measurable.max (ae_measurable.measurable_mk hf) (ae_measurable.measurable_mk hg),
      right := filter.eventually_eq.comp‚ÇÇ (ae_measurable.ae_eq_mk hf) max (ae_measurable.ae_eq_mk hg) }

theorem measurable.min {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [measurable_space Œ¥] [linear_order Œ±] [order_closed_topology Œ±] [topological_space.second_countable_topology Œ±] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) : measurable fun (a : Œ¥) => min (f a) (g a) :=
  measurable.piecewise (is_measurable_le hf hg) hf hg

theorem ae_measurable.min {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [measurable_space Œ¥] [linear_order Œ±] [order_closed_topology Œ±] [topological_space.second_countable_topology Œ±] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} {Œº : measure_theory.measure Œ¥} (hf : ae_measurable f) (hg : ae_measurable g) : ae_measurable fun (a : Œ¥) => min (f a) (g a) :=
  Exists.intro (fun (a : Œ¥) => min (ae_measurable.mk f hf a) (ae_measurable.mk g hg a))
    { left := measurable.min (ae_measurable.measurable_mk hf) (ae_measurable.measurable_mk hg),
      right := filter.eventually_eq.comp‚ÇÇ (ae_measurable.ae_eq_mk hf) min (ae_measurable.ae_eq_mk hg) }

/-- A continuous function from an `opens_measurable_space` to a `borel_space`
is measurable. -/
theorem continuous.measurable {Œ± : Type u_1} {Œ≥ : Type u_3} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] {f : Œ± ‚Üí Œ≥} (hf : continuous f) : measurable f :=
  measurable.mono (continuous.borel_measurable hf) opens_measurable_space.borel_le (le_of_eq borel_space.measurable_eq)

/-- A homeomorphism between two Borel spaces is a measurable equivalence.-/
def homeomorph.to_measurable_equiv {Œ≥ : Type u_3} {Œ≥‚ÇÇ : Type u_4} [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] [topological_space Œ≥‚ÇÇ] [measurable_space Œ≥‚ÇÇ] [borel_space Œ≥‚ÇÇ] (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : Œ≥ ‚âÉ·µê Œ≥‚ÇÇ :=
  measurable_equiv.mk (homeomorph.to_equiv h) sorry sorry

@[simp] theorem homeomorph.to_measurable_equiv_coe {Œ≥ : Type u_3} {Œ≥‚ÇÇ : Type u_4} [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] [topological_space Œ≥‚ÇÇ] [measurable_space Œ≥‚ÇÇ] [borel_space Œ≥‚ÇÇ] (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : ‚áë(homeomorph.to_measurable_equiv h) = ‚áëh :=
  rfl

@[simp] theorem homeomorph.to_measurable_equiv_symm_coe {Œ≥ : Type u_3} {Œ≥‚ÇÇ : Type u_4} [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] [topological_space Œ≥‚ÇÇ] [measurable_space Œ≥‚ÇÇ] [borel_space Œ≥‚ÇÇ] (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : ‚áë(measurable_equiv.symm (homeomorph.to_measurable_equiv h)) = ‚áë(homeomorph.symm h) :=
  rfl

theorem measurable_of_continuous_on_compl_singleton {Œ± : Type u_1} {Œ≥ : Type u_3} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] [t1_space Œ±] {f : Œ± ‚Üí Œ≥} (a : Œ±) (hf : continuous_on f (set_of fun (x : Œ±) => x ‚â† a)) : measurable f :=
  measurable_of_measurable_on_compl_singleton a (continuous.measurable (iff.mp continuous_on_iff_continuous_restrict hf))

theorem continuous.measurable2 {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [topological_space Œ≤] [measurable_space Œ≤] [opens_measurable_space Œ≤] [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] [measurable_space Œ¥] [topological_space.second_countable_topology Œ±] [topological_space.second_countable_topology Œ≤] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ≤} {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (h : continuous fun (p : Œ± √ó Œ≤) => c (prod.fst p) (prod.snd p)) (hf : measurable f) (hg : measurable g) : measurable fun (a : Œ¥) => c (f a) (g a) :=
  measurable.comp (continuous.measurable h) (measurable.prod_mk hf hg)

theorem continuous.ae_measurable2 {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [topological_space Œ≤] [measurable_space Œ≤] [opens_measurable_space Œ≤] [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] [measurable_space Œ¥] [topological_space.second_countable_topology Œ±] [topological_space.second_countable_topology Œ≤] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ≤} {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {Œº : measure_theory.measure Œ¥} (h : continuous fun (p : Œ± √ó Œ≤) => c (prod.fst p) (prod.snd p)) (hf : ae_measurable f) (hg : ae_measurable g) : ae_measurable fun (a : Œ¥) => c (f a) (g a) :=
  measurable.comp_ae_measurable (continuous.measurable h) (ae_measurable.prod_mk hf hg)

theorem measurable.smul {Œ± : Type u_1} {Œ≥ : Type u_3} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] [measurable_space Œ¥] [semiring Œ±] [topological_space.second_countable_topology Œ±] [add_comm_monoid Œ≥] [topological_space.second_countable_topology Œ≥] [semimodule Œ± Œ≥] [topological_semimodule Œ± Œ≥] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ≥} (hf : measurable f) (hg : measurable g) : measurable fun (c : Œ¥) => f c ‚Ä¢ g c :=
  continuous.measurable2 continuous_smul hf hg

theorem ae_measurable.smul {Œ± : Type u_1} {Œ≥ : Type u_3} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] [measurable_space Œ¥] [semiring Œ±] [topological_space.second_countable_topology Œ±] [add_comm_monoid Œ≥] [topological_space.second_countable_topology Œ≥] [semimodule Œ± Œ≥] [topological_semimodule Œ± Œ≥] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ≥} {Œº : measure_theory.measure Œ¥} (hf : ae_measurable f) (hg : ae_measurable g) : ae_measurable fun (c : Œ¥) => f c ‚Ä¢ g c :=
  continuous.ae_measurable2 continuous_smul hf hg

theorem measurable.const_smul {Œ¥ : Type u_5} [measurable_space Œ¥] {R : Type u_1} {M : Type u_2} [topological_space R] [semiring R] [add_comm_monoid M] [semimodule R M] [topological_space M] [topological_semimodule R M] [measurable_space M] [borel_space M] {f : Œ¥ ‚Üí M} (hf : measurable f) (c : R) : measurable fun (x : Œ¥) => c ‚Ä¢ f x :=
  measurable.comp (continuous.measurable (continuous.smul continuous_const continuous_id)) hf

theorem ae_measurable.const_smul {Œ¥ : Type u_5} [measurable_space Œ¥] {R : Type u_1} {M : Type u_2} [topological_space R] [semiring R] [add_comm_monoid M] [semimodule R M] [topological_space M] [topological_semimodule R M] [measurable_space M] [borel_space M] {f : Œ¥ ‚Üí M} {Œº : measure_theory.measure Œ¥} (hf : ae_measurable f) (c : R) : ae_measurable fun (x : Œ¥) => c ‚Ä¢ f x :=
  measurable.comp_ae_measurable (continuous.measurable (continuous.smul continuous_const continuous_id)) hf

theorem measurable_const_smul_iff {Œ≥ : Type u_3} {Œ¥ : Type u_5} [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] [measurable_space Œ¥] {Œ± : Type u_1} [topological_space Œ±] [division_ring Œ±] [add_comm_monoid Œ≥] [semimodule Œ± Œ≥] [topological_semimodule Œ± Œ≥] {f : Œ¥ ‚Üí Œ≥} {c : Œ±} (hc : c ‚â† 0) : (measurable fun (x : Œ¥) => c ‚Ä¢ f x) ‚Üî measurable f := sorry

theorem ae_measurable_const_smul_iff {Œ≥ : Type u_3} {Œ¥ : Type u_5} [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] [measurable_space Œ¥] {Œ± : Type u_1} [topological_space Œ±] [division_ring Œ±] [add_comm_monoid Œ≥] [semimodule Œ± Œ≥] [topological_semimodule Œ± Œ≥] {f : Œ¥ ‚Üí Œ≥} {Œº : measure_theory.measure Œ¥} {c : Œ±} (hc : c ‚â† 0) : (ae_measurable fun (x : Œ¥) => c ‚Ä¢ f x) ‚Üî ae_measurable f := sorry

theorem measurable.const_mul {Œ¥ : Type u_5} [measurable_space Œ¥] {R : Type u_1} [topological_space R] [measurable_space R] [borel_space R] [semiring R] [topological_semiring R] {f : Œ¥ ‚Üí R} (hf : measurable f) (c : R) : measurable fun (x : Œ¥) => c * f x :=
  measurable.const_smul hf c

theorem measurable.mul_const {Œ¥ : Type u_5} [measurable_space Œ¥] {R : Type u_1} [topological_space R] [measurable_space R] [borel_space R] [semiring R] [topological_semiring R] {f : Œ¥ ‚Üí R} (hf : measurable f) (c : R) : measurable fun (x : Œ¥) => f x * c :=
  measurable.comp (continuous.measurable (continuous.mul continuous_id continuous_const)) hf

theorem pi_le_borel_pi {Œπ : Type u_1} {œÄ : Œπ ‚Üí Type u_2} [(i : Œπ) ‚Üí topological_space (œÄ i)] [(i : Œπ) ‚Üí measurable_space (œÄ i)] [‚àÄ (i : Œπ), borel_space (œÄ i)] : measurable_space.pi ‚â§ borel ((a : Œπ) ‚Üí œÄ a) := sorry

theorem prod_le_borel_prod {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [topological_space Œ≤] [measurable_space Œ≤] [borel_space Œ≤] : prod.measurable_space ‚â§ borel (Œ± √ó Œ≤) := sorry

protected instance pi.borel_space {Œπ : Type u_1} {œÄ : Œπ ‚Üí Type u_2} [fintype Œπ] [t' : (i : Œπ) ‚Üí topological_space (œÄ i)] [(i : Œπ) ‚Üí measurable_space (œÄ i)] [‚àÄ (i : Œπ), topological_space.second_countable_topology (œÄ i)] [‚àÄ (i : Œπ), borel_space (œÄ i)] : borel_space ((i : Œπ) ‚Üí œÄ i) :=
  borel_space.mk (le_antisymm pi_le_borel_pi opens_measurable_space.borel_le)

protected instance prod.borel_space {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [topological_space Œ≤] [measurable_space Œ≤] [borel_space Œ≤] [topological_space.second_countable_topology Œ±] [topological_space.second_countable_topology Œ≤] : borel_space (Œ± √ó Œ≤) :=
  borel_space.mk (le_antisymm prod_le_borel_prod opens_measurable_space.borel_le)

theorem measurable_add {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [Add Œ±] [has_continuous_add Œ±] [topological_space.second_countable_topology Œ±] : measurable fun (p : Œ± √ó Œ±) => prod.fst p + prod.snd p :=
  continuous.measurable continuous_add

theorem measurable.mul {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [Mul Œ±] [has_continuous_mul Œ±] [topological_space.second_countable_topology Œ±] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} : measurable f ‚Üí measurable g ‚Üí measurable fun (a : Œ¥) => f a * g a :=
  continuous.measurable2 continuous_mul

theorem ae_measurable.mul {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [Mul Œ±] [has_continuous_mul Œ±] [topological_space.second_countable_topology Œ±] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} {Œº : measure_theory.measure Œ¥} (hf : ae_measurable f) (hg : ae_measurable g) : ae_measurable fun (a : Œ¥) => f a * g a :=
  continuous.ae_measurable2 continuous_mul hf hg

/-- A variant of `measurable.mul` that uses `*` on functions -/
theorem measurable.add' {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [Add Œ±] [has_continuous_add Œ±] [topological_space.second_countable_topology Œ±] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} : measurable f ‚Üí measurable g ‚Üí measurable (f + g) :=
  measurable.add

theorem measurable_add_left {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [Add Œ±] [has_continuous_add Œ±] (x : Œ±) : measurable fun (y : Œ±) => x + y :=
  continuous.measurable (continuous.add continuous_const continuous_id)

theorem measurable_add_right {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [Add Œ±] [has_continuous_add Œ±] (x : Œ±) : measurable fun (y : Œ±) => y + x :=
  continuous.measurable (continuous.add continuous_id continuous_const)

theorem finset.measurable_prod {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] {Œπ : Type u_2} [comm_monoid Œ±] [has_continuous_mul Œ±] [topological_space.second_countable_topology Œ±] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (s : finset Œπ) (hf : ‚àÄ (i : Œπ), measurable (f i)) : measurable fun (a : Œ¥) => finset.prod s fun (i : Œπ) => f i a := sorry

theorem measurable_neg {Œ± : Type u_1} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [add_group Œ±] [topological_add_group Œ±] : measurable Neg.neg :=
  continuous.measurable continuous_neg

theorem measurable.inv {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [group Œ±] [topological_group Œ±] {f : Œ¥ ‚Üí Œ±} (hf : measurable f) : measurable fun (a : Œ¥) => f a‚Åª¬π :=
  measurable.comp measurable_inv hf

theorem ae_measurable.inv {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [group Œ±] [topological_group Œ±] {f : Œ¥ ‚Üí Œ±} {Œº : measure_theory.measure Œ¥} (hf : ae_measurable f) : ae_measurable fun (a : Œ¥) => f a‚Åª¬π :=
  measurable.comp_ae_measurable measurable_inv hf

theorem measurable_inv' {Œ± : Type u_1} [normed_field Œ±] [measurable_space Œ±] [borel_space Œ±] : measurable has_inv.inv :=
  measurable_of_continuous_on_compl_singleton 0 continuous_on_inv'

theorem measurable.inv' {Œ¥ : Type u_5} [measurable_space Œ¥] {Œ± : Type u_1} [normed_field Œ±] [measurable_space Œ±] [borel_space Œ±] {f : Œ¥ ‚Üí Œ±} (hf : measurable f) : measurable fun (a : Œ¥) => f a‚Åª¬π :=
  measurable.comp measurable_inv' hf

theorem measurable.of_inv {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [group Œ±] [topological_group Œ±] {f : Œ¥ ‚Üí Œ±} (hf : measurable fun (a : Œ¥) => f a‚Åª¬π) : measurable f := sorry

@[simp] theorem measurable_inv_iff {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [group Œ±] [topological_group Œ±] {f : Œ¥ ‚Üí Œ±} : (measurable fun (a : Œ¥) => f a‚Åª¬π) ‚Üî measurable f :=
  { mp := measurable.of_inv, mpr := measurable.inv }

theorem measurable.sub {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [add_group Œ±] [topological_add_group Œ±] [topological_space.second_countable_topology Œ±] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) : measurable fun (x : Œ¥) => f x - g x := sorry

theorem ae_measurable.sub {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [add_group Œ±] [topological_add_group Œ±] [topological_space.second_countable_topology Œ±] {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} {Œº : measure_theory.measure Œ¥} (hf : ae_measurable f) (hg : ae_measurable g) : ae_measurable fun (x : Œ¥) => f x - g x := sorry

theorem closed_embedding.measurable_inv_fun {Œ≤ : Type u_2} {Œ≥ : Type u_3} [topological_space Œ≤] [measurable_space Œ≤] [borel_space Œ≤] [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] [n : Nonempty Œ≤] {g : Œ≤ ‚Üí Œ≥} (hg : closed_embedding g) : measurable (function.inv_fun g) := sorry

theorem measurable_comp_iff_of_closed_embedding {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_5} [topological_space Œ≤] [measurable_space Œ≤] [borel_space Œ≤] [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] [measurable_space Œ¥] {f : Œ¥ ‚Üí Œ≤} (g : Œ≤ ‚Üí Œ≥) (hg : closed_embedding g) : measurable (g ‚àò f) ‚Üî measurable f := sorry

theorem ae_measurable_comp_iff_of_closed_embedding {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_5} [topological_space Œ≤] [measurable_space Œ≤] [borel_space Œ≤] [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥] [measurable_space Œ¥] {f : Œ¥ ‚Üí Œ≤} {Œº : measure_theory.measure Œ¥} (g : Œ≤ ‚Üí Œ≥) (hg : closed_embedding g) : ae_measurable (g ‚àò f) ‚Üî ae_measurable f := sorry

theorem measurable_of_Iio {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ (x : Œ±), is_measurable (f ‚Åª¬π' set.Iio x)) : measurable f := sorry

theorem measurable_of_Ioi {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ (x : Œ±), is_measurable (f ‚Åª¬π' set.Ioi x)) : measurable f := sorry

theorem measurable_of_Iic {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ (x : Œ±), is_measurable (f ‚Åª¬π' set.Iic x)) : measurable f := sorry

theorem measurable_of_Ici {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ (x : Œ±), is_measurable (f ‚Åª¬π' set.Ici x)) : measurable f := sorry

theorem measurable.is_lub {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {Œπ : Type u_2} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ (i : Œπ), measurable (f i)) (hg : ‚àÄ (b : Œ¥), is_lub (set_of fun (a : Œ±) => ‚àÉ (i : Œπ), f i b = a) (g b)) : measurable g := sorry

theorem ae_measurable.is_lub {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {Œπ : Type u_2} {Œº : measure_theory.measure Œ¥} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ (i : Œπ), ae_measurable (f i)) (hg : filter.eventually (fun (b : Œ¥) => is_lub (set_of fun (a : Œ±) => ‚àÉ (i : Œπ), f i b = a) (g b))
  (measure_theory.measure.ae Œº)) : ae_measurable g := sorry

theorem measurable.is_glb {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {Œπ : Type u_2} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ (i : Œπ), measurable (f i)) (hg : ‚àÄ (b : Œ¥), is_glb (set_of fun (a : Œ±) => ‚àÉ (i : Œπ), f i b = a) (g b)) : measurable g := sorry

theorem ae_measurable.is_glb {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {Œπ : Type u_2} {Œº : measure_theory.measure Œ¥} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ (i : Œπ), ae_measurable (f i)) (hg : filter.eventually (fun (b : Œ¥) => is_glb (set_of fun (a : Œ±) => ‚àÉ (i : Œπ), f i b = a) (g b))
  (measure_theory.measure.ae Œº)) : ae_measurable g := sorry

theorem measurable.supr_Prop {Œ¥ : Type u_5} [measurable_space Œ¥] {Œ± : Type u_1} [measurable_space Œ±] [complete_lattice Œ±] (p : Prop) {f : Œ¥ ‚Üí Œ±} (hf : measurable f) : measurable fun (b : Œ¥) => supr fun (h : p) => f b := sorry

theorem measurable.infi_Prop {Œ¥ : Type u_5} [measurable_space Œ¥] {Œ± : Type u_1} [measurable_space Œ±] [complete_lattice Œ±] (p : Prop) {f : Œ¥ ‚Üí Œ±} (hf : measurable f) : measurable fun (b : Œ¥) => infi fun (h : p) => f b := sorry

theorem measurable_supr {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [complete_linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {Œπ : Type u_2} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ (i : Œπ), measurable (f i)) : measurable fun (b : Œ¥) => supr fun (i : Œπ) => f i b :=
  measurable.is_lub hf fun (b : Œ¥) => is_lub_supr

theorem ae_measurable_supr {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [complete_linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {Œπ : Type u_2} {Œº : measure_theory.measure Œ¥} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ (i : Œπ), ae_measurable (f i)) : ae_measurable fun (b : Œ¥) => supr fun (i : Œπ) => f i b :=
  ae_measurable.is_lub hf (measure_theory.ae_of_all Œº fun (b : Œ¥) => is_lub_supr)

theorem measurable_infi {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [complete_linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {Œπ : Type u_2} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ (i : Œπ), measurable (f i)) : measurable fun (b : Œ¥) => infi fun (i : Œπ) => f i b :=
  measurable.is_glb hf fun (b : Œ¥) => is_glb_infi

theorem ae_measurable_infi {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [complete_linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {Œπ : Type u_2} {Œº : measure_theory.measure Œ¥} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ (i : Œπ), ae_measurable (f i)) : ae_measurable fun (b : Œ¥) => infi fun (i : Œπ) => f i b :=
  ae_measurable.is_glb hf (measure_theory.ae_of_all Œº fun (b : Œ¥) => is_glb_infi)

theorem measurable_bsupr {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [complete_linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {Œπ : Type u_2} (s : set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : set.countable s) (hf : ‚àÄ (i : Œπ), measurable (f i)) : measurable fun (b : Œ¥) => supr fun (i : Œπ) => supr fun (H : i ‚àà s) => f i b := sorry

theorem ae_measurable_bsupr {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [complete_linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {Œπ : Type u_2} {Œº : measure_theory.measure Œ¥} (s : set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : set.countable s) (hf : ‚àÄ (i : Œπ), ae_measurable (f i)) : ae_measurable fun (b : Œ¥) => supr fun (i : Œπ) => supr fun (H : i ‚àà s) => f i b := sorry

theorem measurable_binfi {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [complete_linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {Œπ : Type u_2} (s : set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : set.countable s) (hf : ‚àÄ (i : Œπ), measurable (f i)) : measurable fun (b : Œ¥) => infi fun (i : Œπ) => infi fun (H : i ‚àà s) => f i b := sorry

theorem ae_measurable_binfi {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [complete_linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {Œπ : Type u_2} {Œº : measure_theory.measure Œ¥} (s : set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : set.countable s) (hf : ‚àÄ (i : Œπ), ae_measurable (f i)) : ae_measurable fun (b : Œ¥) => infi fun (i : Œπ) => infi fun (H : i ‚àà s) => f i b := sorry

/-- `liminf` over a general filter is measurable. See `measurable_liminf` for the version over `‚Ñï`.
-/
theorem measurable_liminf' {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [complete_linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {Œπ : Type u_2} {Œπ' : Type u_3} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {u : filter Œπ} (hf : ‚àÄ (i : Œπ), measurable (f i)) {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí set Œπ} (hu : filter.has_countable_basis u p s) (hs : ‚àÄ (i : Œπ'), set.countable (s i)) : measurable fun (x : Œ¥) => filter.liminf u fun (i : Œπ) => f i x := sorry

/-- `limsup` over a general filter is measurable. See `measurable_limsup` for the version over `‚Ñï`.
-/
theorem measurable_limsup' {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [complete_linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {Œπ : Type u_2} {Œπ' : Type u_3} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {u : filter Œπ} (hf : ‚àÄ (i : Œπ), measurable (f i)) {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí set Œπ} (hu : filter.has_countable_basis u p s) (hs : ‚àÄ (i : Œπ'), set.countable (s i)) : measurable fun (x : Œ¥) => filter.limsup u fun (i : Œπ) => f i x := sorry

/-- `liminf` over `‚Ñï` is measurable. See `measurable_liminf'` for a version with a general filter.
-/
theorem measurable_liminf {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [complete_linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ (i : ‚Ñï), measurable (f i)) : measurable fun (x : Œ¥) => filter.liminf filter.at_top fun (i : ‚Ñï) => f i x :=
  measurable_liminf' hf filter.at_top_countable_basis fun (i : ‚Ñï) => set.countable_encodable (set.Ici i)

/-- `limsup` over `‚Ñï` is measurable. See `measurable_limsup'` for a version with a general filter.
-/
theorem measurable_limsup {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [complete_linear_order Œ±] [order_topology Œ±] [topological_space.second_countable_topology Œ±] {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ (i : ‚Ñï), measurable (f i)) : measurable fun (x : Œ¥) => filter.limsup filter.at_top fun (i : ‚Ñï) => f i x :=
  measurable_limsup' hf filter.at_top_countable_basis fun (i : ‚Ñï) => set.countable_encodable (set.Ici i)

theorem measurable_cSup {Œ± : Type u_1} {Œ¥ : Type u_5} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [measurable_space Œ¥] [conditionally_complete_linear_order Œ±] [topological_space.second_countable_topology Œ±] [order_topology Œ±] {Œπ : Type u_2} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {s : set Œπ} (hs : set.countable s) (hf : ‚àÄ (i : Œπ), measurable (f i)) (bdd : ‚àÄ (x : Œ¥), bdd_above ((fun (i : Œπ) => f i x) '' s)) : measurable fun (x : Œ¥) => Sup ((fun (i : Œπ) => f i x) '' s) := sorry

/-- Convert a `homeomorph` to a `measurable_equiv`. -/
def homemorph.to_measurable_equiv {Œ± : Type u_1} {Œ≤ : Type u_2} [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±] [topological_space Œ≤] [measurable_space Œ≤] [borel_space Œ≤] (h : Œ± ‚âÉ‚Çú Œ≤) : Œ± ‚âÉ·µê Œ≤ :=
  measurable_equiv.mk (homeomorph.to_equiv h) sorry sorry

protected instance empty.borel_space : borel_space empty :=
  borel_space.mk (Eq.symm borel_eq_top_of_discrete)

protected instance unit.borel_space : borel_space Unit :=
  borel_space.mk (Eq.symm borel_eq_top_of_discrete)

protected instance bool.borel_space : borel_space Bool :=
  borel_space.mk (Eq.symm borel_eq_top_of_discrete)

protected instance nat.borel_space : borel_space ‚Ñï :=
  borel_space.mk (Eq.symm borel_eq_top_of_discrete)

protected instance int.borel_space : borel_space ‚Ñ§ :=
  borel_space.mk (Eq.symm borel_eq_top_of_discrete)

protected instance rat.borel_space : borel_space ‚Ñö :=
  borel_space.mk (Eq.symm borel_eq_top_of_encodable)

protected instance real.measurable_space : measurable_space ‚Ñù :=
  borel ‚Ñù

protected instance real.borel_space : borel_space ‚Ñù :=
  borel_space.mk rfl

protected instance nnreal.measurable_space : measurable_space nnreal :=
  borel nnreal

protected instance nnreal.borel_space : borel_space nnreal :=
  borel_space.mk rfl

protected instance ennreal.measurable_space : measurable_space ennreal :=
  borel ennreal

protected instance ennreal.borel_space : borel_space ennreal :=
  borel_space.mk rfl

protected instance complex.measurable_space : measurable_space ‚ÑÇ :=
  borel ‚ÑÇ

protected instance complex.borel_space : borel_space ‚ÑÇ :=
  borel_space.mk rfl

theorem is_measurable_ball {Œ± : Type u_1} [metric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] {x : Œ±} {Œµ : ‚Ñù} : is_measurable (metric.ball x Œµ) :=
  is_open.is_measurable metric.is_open_ball

theorem is_measurable_closed_ball {Œ± : Type u_1} [metric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] {x : Œ±} {Œµ : ‚Ñù} : is_measurable (metric.closed_ball x Œµ) :=
  is_closed.is_measurable metric.is_closed_ball

theorem measurable_inf_dist {Œ± : Type u_1} [metric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] {s : set Œ±} : measurable fun (x : Œ±) => metric.inf_dist x s :=
  continuous.measurable (metric.continuous_inf_dist_pt s)

theorem measurable.inf_dist {Œ± : Type u_1} {Œ≤ : Type u_2} [metric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [measurable_space Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : measurable f) {s : set Œ±} : measurable fun (x : Œ≤) => metric.inf_dist (f x) s :=
  measurable.comp measurable_inf_dist hf

theorem measurable_inf_nndist {Œ± : Type u_1} [metric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] {s : set Œ±} : measurable fun (x : Œ±) => metric.inf_nndist x s :=
  continuous.measurable (metric.continuous_inf_nndist_pt s)

theorem measurable.inf_nndist {Œ± : Type u_1} {Œ≤ : Type u_2} [metric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [measurable_space Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : measurable f) {s : set Œ±} : measurable fun (x : Œ≤) => metric.inf_nndist (f x) s :=
  measurable.comp measurable_inf_nndist hf

theorem measurable_dist {Œ± : Type u_1} [metric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [topological_space.second_countable_topology Œ±] : measurable fun (p : Œ± √ó Œ±) => dist (prod.fst p) (prod.snd p) :=
  continuous.measurable continuous_dist

theorem measurable.dist {Œ± : Type u_1} {Œ≤ : Type u_2} [metric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [measurable_space Œ≤] [topological_space.second_countable_topology Œ±] {f : Œ≤ ‚Üí Œ±} {g : Œ≤ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) : measurable fun (b : Œ≤) => dist (f b) (g b) :=
  continuous.measurable2 continuous_dist hf hg

theorem measurable_nndist {Œ± : Type u_1} [metric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [topological_space.second_countable_topology Œ±] : measurable fun (p : Œ± √ó Œ±) => nndist (prod.fst p) (prod.snd p) :=
  continuous.measurable continuous_nndist

theorem measurable.nndist {Œ± : Type u_1} {Œ≤ : Type u_2} [metric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [measurable_space Œ≤] [topological_space.second_countable_topology Œ±] {f : Œ≤ ‚Üí Œ±} {g : Œ≤ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) : measurable fun (b : Œ≤) => nndist (f b) (g b) :=
  continuous.measurable2 continuous_nndist hf hg

theorem is_measurable_eball {Œ± : Type u_1} [emetric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] {x : Œ±} {Œµ : ennreal} : is_measurable (emetric.ball x Œµ) :=
  is_open.is_measurable emetric.is_open_ball

theorem measurable_edist_right {Œ± : Type u_1} [emetric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] {x : Œ±} : measurable (edist x) :=
  continuous.measurable (continuous.edist continuous_const continuous_id)

theorem measurable_edist_left {Œ± : Type u_1} [emetric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] {x : Œ±} : measurable fun (y : Œ±) => edist y x :=
  continuous.measurable (continuous.edist continuous_id continuous_const)

theorem measurable_inf_edist {Œ± : Type u_1} [emetric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] {s : set Œ±} : measurable fun (x : Œ±) => emetric.inf_edist x s :=
  continuous.measurable emetric.continuous_inf_edist

theorem measurable.inf_edist {Œ± : Type u_1} {Œ≤ : Type u_2} [emetric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [measurable_space Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : measurable f) {s : set Œ±} : measurable fun (x : Œ≤) => emetric.inf_edist (f x) s :=
  measurable.comp measurable_inf_edist hf

theorem measurable_edist {Œ± : Type u_1} [emetric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [topological_space.second_countable_topology Œ±] : measurable fun (p : Œ± √ó Œ±) => edist (prod.fst p) (prod.snd p) :=
  continuous.measurable continuous_edist

theorem measurable.edist {Œ± : Type u_1} {Œ≤ : Type u_2} [emetric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [measurable_space Œ≤] [topological_space.second_countable_topology Œ±] {f : Œ≤ ‚Üí Œ±} {g : Œ≤ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) : measurable fun (b : Œ≤) => edist (f b) (g b) :=
  continuous.measurable2 continuous_edist hf hg

theorem ae_measurable.edist {Œ± : Type u_1} {Œ≤ : Type u_2} [emetric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±] [measurable_space Œ≤] [topological_space.second_countable_topology Œ±] {f : Œ≤ ‚Üí Œ±} {g : Œ≤ ‚Üí Œ±} {Œº : measure_theory.measure Œ≤} (hf : ae_measurable f) (hg : ae_measurable g) : ae_measurable fun (a : Œ≤) => edist (f a) (g a) :=
  continuous.ae_measurable2 continuous_edist hf hg

namespace real


theorem borel_eq_generate_from_Ioo_rat : borel ‚Ñù =
  measurable_space.generate_from
    (set.Union fun (a : ‚Ñö) => set.Union fun (b : ‚Ñö) => set.Union fun (h : a < b) => singleton (set.Ioo ‚Üëa ‚Üëb)) :=
  borel_eq_generate_from_of_subbasis (and.right (and.right is_topological_basis_Ioo_rat))

theorem measure_ext_Ioo_rat {Œº : measure_theory.measure ‚Ñù} {ŒΩ : measure_theory.measure ‚Ñù} [measure_theory.locally_finite_measure Œº] (h : ‚àÄ (a b : ‚Ñö), coe_fn Œº (set.Ioo ‚Üëa ‚Üëb) = coe_fn ŒΩ (set.Ioo ‚Üëa ‚Üëb)) : Œº = ŒΩ := sorry

theorem borel_eq_generate_from_Iio_rat : borel ‚Ñù = measurable_space.generate_from (set.Union fun (a : ‚Ñö) => singleton (set.Iio ‚Üëa)) := sorry

end real


theorem measurable.sub_nnreal {Œ± : Type u_1} [measurable_space Œ±] {f : Œ± ‚Üí nnreal} {g : Œ± ‚Üí nnreal} : measurable f ‚Üí measurable g ‚Üí measurable fun (a : Œ±) => f a - g a :=
  continuous.measurable2 continuous_sub

theorem measurable.nnreal_of_real {Œ± : Type u_1} [measurable_space Œ±] {f : Œ± ‚Üí ‚Ñù} (hf : measurable f) : measurable fun (x : Œ±) => nnreal.of_real (f x) :=
  measurable.comp (continuous.measurable nnreal.continuous_of_real) hf

theorem nnreal.measurable_coe : measurable coe :=
  continuous.measurable nnreal.continuous_coe

theorem measurable.nnreal_coe {Œ± : Type u_1} [measurable_space Œ±] {f : Œ± ‚Üí nnreal} (hf : measurable f) : measurable fun (x : Œ±) => ‚Üë(f x) :=
  measurable.comp nnreal.measurable_coe hf

theorem measurable.ennreal_coe {Œ± : Type u_1} [measurable_space Œ±] {f : Œ± ‚Üí nnreal} (hf : measurable f) : measurable fun (x : Œ±) => ‚Üë(f x) :=
  measurable.comp (continuous.measurable ennreal.continuous_coe) hf

theorem ae_measurable.ennreal_coe {Œ± : Type u_1} [measurable_space Œ±] {f : Œ± ‚Üí nnreal} {Œº : measure_theory.measure Œ±} (hf : ae_measurable f) : ae_measurable fun (x : Œ±) => ‚Üë(f x) :=
  measurable.comp_ae_measurable (continuous.measurable ennreal.continuous_coe) hf

theorem measurable.ennreal_of_real {Œ± : Type u_1} [measurable_space Œ±] {f : Œ± ‚Üí ‚Ñù} (hf : measurable f) : measurable fun (x : Œ±) => ennreal.of_real (f x) :=
  measurable.comp (continuous.measurable ennreal.continuous_of_real) hf

/-- The set of finite `ennreal` numbers is `measurable_equiv` to `‚Ñù‚â•0`. -/
def measurable_equiv.ennreal_equiv_nnreal : ‚Ü•(set_of fun (r : ennreal) => r ‚â† ‚ä§) ‚âÉ·µê nnreal :=
  homeomorph.to_measurable_equiv ennreal.ne_top_homeomorph_nnreal

namespace ennreal


theorem measurable_coe : measurable coe :=
  measurable.ennreal_coe measurable_id

theorem measurable_of_measurable_nnreal {Œ± : Type u_1} [measurable_space Œ±] {f : ennreal ‚Üí Œ±} (h : measurable fun (p : nnreal) => f ‚Üëp) : measurable f :=
  measurable_of_measurable_on_compl_singleton ‚ä§
    (iff.mp (measurable_equiv.measurable_coe_iff (measurable_equiv.symm measurable_equiv.ennreal_equiv_nnreal)) h)

/-- `ennreal` is `measurable_equiv` to `‚Ñù‚â•0 ‚äï unit`. -/
def ennreal_equiv_sum : ennreal ‚âÉ·µê nnreal ‚äï Unit :=
  measurable_equiv.mk
    (equiv.mk (equiv.to_fun (equiv.option_equiv_sum_punit nnreal)) (equiv.inv_fun (equiv.option_equiv_sum_punit nnreal))
      sorry sorry)
    sorry sorry

theorem measurable_of_measurable_nnreal_prod {Œ≤ : Type u_2} {Œ≥ : Type u_3} [measurable_space Œ≤] [measurable_space Œ≥] {f : ennreal √ó Œ≤ ‚Üí Œ≥} (H‚ÇÅ : measurable fun (p : nnreal √ó Œ≤) => f (‚Üë(prod.fst p), prod.snd p)) (H‚ÇÇ : measurable fun (x : Œ≤) => f (‚ä§, x)) : measurable f := sorry

theorem measurable_of_measurable_nnreal_nnreal {Œ≤ : Type u_2} [measurable_space Œ≤] {f : ennreal √ó ennreal ‚Üí Œ≤} (h‚ÇÅ : measurable fun (p : nnreal √ó nnreal) => f (‚Üë(prod.fst p), ‚Üë(prod.snd p))) (h‚ÇÇ : measurable fun (r : nnreal) => f (‚ä§, ‚Üër)) (h‚ÇÉ : measurable fun (r : nnreal) => f (‚Üër, ‚ä§)) : measurable f :=
  measurable_of_measurable_nnreal_prod
    (iff.mp measurable_swap_iff (measurable_of_measurable_nnreal_prod (measurable.comp h‚ÇÅ measurable_swap) h‚ÇÉ))
    (measurable_of_measurable_nnreal h‚ÇÇ)

theorem measurable_of_real : measurable ennreal.of_real :=
  continuous.measurable continuous_of_real

theorem measurable_to_real : measurable ennreal.to_real :=
  measurable_of_measurable_nnreal nnreal.measurable_coe

theorem measurable_to_nnreal : measurable ennreal.to_nnreal :=
  measurable_of_measurable_nnreal measurable_id

theorem measurable_mul : measurable fun (p : ennreal √ó ennreal) => prod.fst p * prod.snd p := sorry

theorem measurable_sub : measurable fun (p : ennreal √ó ennreal) => prod.fst p - prod.snd p := sorry

theorem measurable_inv : measurable has_inv.inv :=
  continuous.measurable ennreal.continuous_inv

theorem measurable_div : measurable fun (p : ennreal √ó ennreal) => prod.fst p / prod.snd p :=
  measurable.comp measurable_mul (measurable.prod_mk measurable_fst (measurable.comp measurable_inv measurable_snd))

end ennreal


theorem measurable.to_nnreal {Œ± : Type u_1} [measurable_space Œ±] {f : Œ± ‚Üí ennreal} (hf : measurable f) : measurable fun (x : Œ±) => ennreal.to_nnreal (f x) :=
  measurable.comp ennreal.measurable_to_nnreal hf

theorem measurable_ennreal_coe_iff {Œ± : Type u_1} [measurable_space Œ±] {f : Œ± ‚Üí nnreal} : (measurable fun (x : Œ±) => ‚Üë(f x)) ‚Üî measurable f :=
  { mp := fun (h : measurable fun (x : Œ±) => ‚Üë(f x)) => measurable.to_nnreal h,
    mpr := fun (h : measurable f) => measurable.ennreal_coe h }

theorem measurable.to_real {Œ± : Type u_1} [measurable_space Œ±] {f : Œ± ‚Üí ennreal} (hf : measurable f) : measurable fun (x : Œ±) => ennreal.to_real (f x) :=
  measurable.comp ennreal.measurable_to_real hf

theorem ae_measurable.to_real {Œ± : Type u_1} [measurable_space Œ±] {f : Œ± ‚Üí ennreal} {Œº : measure_theory.measure Œ±} (hf : ae_measurable f) : ae_measurable fun (x : Œ±) => ennreal.to_real (f x) :=
  measurable.comp_ae_measurable ennreal.measurable_to_real hf

theorem measurable.ennreal_mul {Œ± : Type u_1} [measurable_space Œ±] {f : Œ± ‚Üí ennreal} {g : Œ± ‚Üí ennreal} (hf : measurable f) (hg : measurable g) : measurable fun (a : Œ±) => f a * g a :=
  measurable.comp ennreal.measurable_mul (measurable.prod_mk hf hg)

theorem ae_measurable.ennreal_mul {Œ± : Type u_1} [measurable_space Œ±] {f : Œ± ‚Üí ennreal} {g : Œ± ‚Üí ennreal} {Œº : measure_theory.measure Œ±} (hf : ae_measurable f) (hg : ae_measurable g) : ae_measurable fun (a : Œ±) => f a * g a :=
  measurable.comp_ae_measurable ennreal.measurable_mul (ae_measurable.prod_mk hf hg)

theorem measurable.ennreal_sub {Œ± : Type u_1} [measurable_space Œ±] {f : Œ± ‚Üí ennreal} {g : Œ± ‚Üí ennreal} (hf : measurable f) (hg : measurable g) : measurable fun (a : Œ±) => f a - g a :=
  measurable.comp ennreal.measurable_sub (measurable.prod_mk hf hg)

/-- note: `ennreal` can probably be generalized in a future version of this lemma. -/
theorem measurable.ennreal_tsum {Œ± : Type u_1} [measurable_space Œ±] {Œπ : Type u_2} [encodable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ennreal} (h : ‚àÄ (i : Œπ), measurable (f i)) : measurable fun (x : Œ±) => tsum fun (i : Œπ) => f i x := sorry

theorem measurable.ennreal_inv {Œ± : Type u_1} [measurable_space Œ±] {f : Œ± ‚Üí ennreal} (hf : measurable f) : measurable fun (a : Œ±) => f a‚Åª¬π :=
  measurable.comp ennreal.measurable_inv hf

theorem measurable.ennreal_div {Œ± : Type u_1} [measurable_space Œ±] {f : Œ± ‚Üí ennreal} {g : Œ± ‚Üí ennreal} (hf : measurable f) (hg : measurable g) : measurable fun (a : Œ±) => f a / g a :=
  measurable.comp ennreal.measurable_div (measurable.prod_mk hf hg)

theorem measurable_norm {Œ± : Type u_1} [measurable_space Œ±] [normed_group Œ±] [opens_measurable_space Œ±] : measurable norm :=
  continuous.measurable continuous_norm

theorem measurable.norm {Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [normed_group Œ±] [opens_measurable_space Œ±] [measurable_space Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : measurable f) : measurable fun (a : Œ≤) => norm (f a) :=
  measurable.comp measurable_norm hf

theorem ae_measurable.norm {Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [normed_group Œ±] [opens_measurable_space Œ±] [measurable_space Œ≤] {f : Œ≤ ‚Üí Œ±} {Œº : measure_theory.measure Œ≤} (hf : ae_measurable f) : ae_measurable fun (a : Œ≤) => norm (f a) :=
  measurable.comp_ae_measurable measurable_norm hf

theorem measurable_nnnorm {Œ± : Type u_1} [measurable_space Œ±] [normed_group Œ±] [opens_measurable_space Œ±] : measurable nnnorm :=
  continuous.measurable continuous_nnnorm

theorem measurable.nnnorm {Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [normed_group Œ±] [opens_measurable_space Œ±] [measurable_space Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : measurable f) : measurable fun (a : Œ≤) => nnnorm (f a) :=
  measurable.comp measurable_nnnorm hf

theorem ae_measurable.nnnorm {Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [normed_group Œ±] [opens_measurable_space Œ±] [measurable_space Œ≤] {f : Œ≤ ‚Üí Œ±} {Œº : measure_theory.measure Œ≤} (hf : ae_measurable f) : ae_measurable fun (a : Œ≤) => nnnorm (f a) :=
  measurable.comp_ae_measurable measurable_nnnorm hf

theorem measurable_ennnorm {Œ± : Type u_1} [measurable_space Œ±] [normed_group Œ±] [opens_measurable_space Œ±] : measurable fun (x : Œ±) => ‚Üë(nnnorm x) :=
  measurable.ennreal_coe measurable_nnnorm

theorem measurable.ennnorm {Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [normed_group Œ±] [opens_measurable_space Œ±] [measurable_space Œ≤] {f : Œ≤ ‚Üí Œ±} (hf : measurable f) : measurable fun (a : Œ≤) => ‚Üë(nnnorm (f a)) :=
  measurable.ennreal_coe (measurable.nnnorm hf)

theorem ae_measurable.ennnorm {Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [normed_group Œ±] [opens_measurable_space Œ±] [measurable_space Œ≤] {f : Œ≤ ‚Üí Œ±} {Œº : measure_theory.measure Œ≤} (hf : ae_measurable f) : ae_measurable fun (a : Œ≤) => ‚Üë(nnnorm (f a)) :=
  measurable.comp_ae_measurable measurable_ennnorm hf

/-- A limit (over a general filter) of measurable `‚Ñù‚â•0` valued functions is measurable.
The assumption `hs` can be dropped using `filter.is_countably_generated.has_antimono_basis`, but we
don't need that case yet. -/
theorem measurable_of_tendsto_nnreal' {Œ± : Type u_1} [measurable_space Œ±] {Œπ : Type u_2} {Œπ' : Type u_3} {f : Œπ ‚Üí Œ± ‚Üí nnreal} {g : Œ± ‚Üí nnreal} (u : filter Œπ) [filter.ne_bot u] (hf : ‚àÄ (i : Œπ), measurable (f i)) (lim : filter.tendsto f u (nhds g)) {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí set Œπ} (hu : filter.has_countable_basis u p s) (hs : ‚àÄ (i : Œπ'), set.countable (s i)) : measurable g := sorry

/-- A sequential limit of measurable `‚Ñù‚â•0` valued functions is measurable. -/
theorem measurable_of_tendsto_nnreal {Œ± : Type u_1} [measurable_space Œ±] {f : ‚Ñï ‚Üí Œ± ‚Üí nnreal} {g : Œ± ‚Üí nnreal} (hf : ‚àÄ (i : ‚Ñï), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g :=
  measurable_of_tendsto_nnreal' filter.at_top hf lim filter.at_top_countable_basis
    fun (i : ‚Ñï) => set.countable_encodable (set.Ici i)

/-- A limit (over a general filter) of measurable functions valued in a metric space is measurable.
The assumption `hs` can be dropped using `filter.is_countably_generated.has_antimono_basis`, but we
don't need that case yet. -/
theorem measurable_of_tendsto_metric' {Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] [metric_space Œ≤] [borel_space Œ≤] {Œπ : Type u_3} {Œπ' : Type u_4} {f : Œπ ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (u : filter Œπ) [filter.ne_bot u] (hf : ‚àÄ (i : Œπ), measurable (f i)) (lim : filter.tendsto f u (nhds g)) {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí set Œπ} (hu : filter.has_countable_basis u p s) (hs : ‚àÄ (i : Œπ'), set.countable (s i)) : measurable g := sorry

/-- A sequential limit of measurable functions valued in a metric space is measurable. -/
theorem measurable_of_tendsto_metric {Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] [metric_space Œ≤] [borel_space Œ≤] {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (hf : ‚àÄ (i : ‚Ñï), measurable (f i)) (lim : filter.tendsto f filter.at_top (nhds g)) : measurable g :=
  measurable_of_tendsto_metric' filter.at_top hf lim filter.at_top_countable_basis
    fun (i : ‚Ñï) => set.countable_encodable (set.Ici i)

theorem ae_measurable_of_tendsto_metric_ae {Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] [metric_space Œ≤] [borel_space Œ≤] {Œº : measure_theory.measure Œ±} {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (hf : ‚àÄ (n : ‚Ñï), ae_measurable (f n)) (h_ae_tendsto : filter.eventually (fun (x : Œ±) => filter.tendsto (fun (n : ‚Ñï) => f n x) filter.at_top (nhds (g x)))
  (measure_theory.measure.ae Œº)) : ae_measurable g := sorry

theorem measurable_of_tendsto_metric_ae {Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] [metric_space Œ≤] [borel_space Œ≤] {Œº : measure_theory.measure Œ±} [measure_theory.measure.is_complete Œº] {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (hf : ‚àÄ (n : ‚Ñï), measurable (f n)) (h_ae_tendsto : filter.eventually (fun (x : Œ±) => filter.tendsto (fun (n : ‚Ñï) => f n x) filter.at_top (nhds (g x)))
  (measure_theory.measure.ae Œº)) : measurable g :=
  iff.mp ae_measurable_iff_measurable
    (ae_measurable_of_tendsto_metric_ae (fun (i : ‚Ñï) => measurable.ae_measurable (hf i)) h_ae_tendsto)

theorem measurable_limit_of_tendsto_metric_ae {Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [measurable_space Œ≤] [metric_space Œ≤] [borel_space Œ≤] {Œº : measure_theory.measure Œ±} {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} (hf : ‚àÄ (n : ‚Ñï), ae_measurable (f n)) (h_ae_tendsto : filter.eventually (fun (x : Œ±) => ‚àÉ (l : Œ≤), filter.tendsto (fun (n : ‚Ñï) => f n x) filter.at_top (nhds l))
  (measure_theory.measure.ae Œº)) : ‚àÉ (f_lim : Œ± ‚Üí Œ≤),
  ‚àÉ (hf_lim_meas : measurable f_lim),
    filter.eventually (fun (x : Œ±) => filter.tendsto (fun (n : ‚Ñï) => f n x) filter.at_top (nhds (f_lim x)))
      (measure_theory.measure.ae Œº) := sorry

namespace continuous_linear_map


protected theorem measurable {ùïú : Type u_6} [normed_field ùïú] {E : Type u_7} [normed_group E] [normed_space ùïú E] [measurable_space E] [opens_measurable_space E] {F : Type u_8} [normed_group F] [normed_space ùïú F] [measurable_space F] [borel_space F] (L : continuous_linear_map ùïú E F) : measurable ‚áëL :=
  continuous.measurable (continuous_linear_map.continuous L)

theorem measurable_comp {Œ± : Type u_1} [measurable_space Œ±] {ùïú : Type u_6} [normed_field ùïú] {E : Type u_7} [normed_group E] [normed_space ùïú E] [measurable_space E] [opens_measurable_space E] {F : Type u_8} [normed_group F] [normed_space ùïú F] [measurable_space F] [borel_space F] (L : continuous_linear_map ùïú E F) {œÜ : Œ± ‚Üí E} (œÜ_meas : measurable œÜ) : measurable fun (a : Œ±) => coe_fn L (œÜ a) :=
  measurable.comp (continuous_linear_map.measurable L) œÜ_meas

end continuous_linear_map


theorem measurable_smul_const {Œ± : Type u_1} [measurable_space Œ±] {ùïú : Type u_6} [nondiscrete_normed_field ùïú] [complete_space ùïú] [measurable_space ùïú] [borel_space ùïú] {E : Type u_7} [normed_group E] [normed_space ùïú E] [measurable_space E] [borel_space E] {f : Œ± ‚Üí ùïú} {c : E} (hc : c ‚â† 0) : (measurable fun (x : Œ±) => f x ‚Ä¢ c) ‚Üî measurable f :=
  measurable_comp_iff_of_closed_embedding (fun (y : ùïú) => y ‚Ä¢ c) (closed_embedding_smul_left hc)

theorem ae_measurable_smul_const {Œ± : Type u_1} [measurable_space Œ±] {ùïú : Type u_6} [nondiscrete_normed_field ùïú] [complete_space ùïú] [measurable_space ùïú] [borel_space ùïú] {E : Type u_7} [normed_group E] [normed_space ùïú E] [measurable_space E] [borel_space E] {f : Œ± ‚Üí ùïú} {Œº : measure_theory.measure Œ±} {c : E} (hc : c ‚â† 0) : (ae_measurable fun (x : Œ±) => f x ‚Ä¢ c) ‚Üî ae_measurable f :=
  ae_measurable_comp_iff_of_closed_embedding (fun (y : ùïú) => y ‚Ä¢ c) (closed_embedding_smul_left hc)

namespace measure_theory


namespace measure


/-- A measure `Œº` is regular if
  - it is finite on all compact sets;
  - it is outer regular: `Œº(A) = inf { Œº(U) | A ‚äÜ U open }` for `A` measurable;
  - it is inner regular: `Œº(U) = sup { Œº(K) | K ‚äÜ U compact }` for `U` open. -/
structure regular {Œ± : Type u_1} [measurable_space Œ±] [topological_space Œ±] (Œº : measure Œ±) 
where
  lt_top_of_is_compact : ‚àÄ {K : set Œ±}, is_compact K ‚Üí coe_fn Œº K < ‚ä§
  outer_regular : ‚àÄ {A : set Œ±},
  is_measurable A ‚Üí
    (infi fun (U : set Œ±) => infi fun (h : is_open U) => infi fun (h2 : A ‚äÜ U) => coe_fn Œº U) ‚â§ coe_fn Œº A
  inner_regular : ‚àÄ {U : set Œ±},
  is_open U ‚Üí coe_fn Œº U ‚â§ supr fun (K : set Œ±) => supr fun (h : is_compact K) => supr fun (h2 : K ‚äÜ U) => coe_fn Œº K

namespace regular


theorem outer_regular_eq {Œ± : Type u_1} [measurable_space Œ±] [topological_space Œ±] {Œº : measure Œ±} (hŒº : regular Œº) {A : set Œ±} (hA : is_measurable A) : (infi fun (U : set Œ±) => infi fun (h : is_open U) => infi fun (h2 : A ‚äÜ U) => coe_fn Œº U) = coe_fn Œº A := sorry

theorem inner_regular_eq {Œ± : Type u_1} [measurable_space Œ±] [topological_space Œ±] {Œº : measure Œ±} (hŒº : regular Œº) {U : set Œ±} (hU : is_open U) : (supr fun (K : set Œ±) => supr fun (h : is_compact K) => supr fun (h2 : K ‚äÜ U) => coe_fn Œº K) = coe_fn Œº U := sorry

theorem exists_compact_not_null {Œ± : Type u_1} [measurable_space Œ±] [topological_space Œ±] {Œº : measure Œ±} (hŒº : regular Œº) : (‚àÉ (K : set Œ±), is_compact K ‚àß coe_fn Œº K ‚â† 0) ‚Üî Œº ‚â† 0 := sorry

protected theorem map {Œ± : Type u_1} {Œ≤ : Type u_2} [measurable_space Œ±] [topological_space Œ±] {Œº : measure Œ±} [opens_measurable_space Œ±] [measurable_space Œ≤] [topological_space Œ≤] [t2_space Œ≤] [borel_space Œ≤] (hŒº : regular Œº) (f : Œ± ‚âÉ‚Çú Œ≤) : regular (coe_fn (map ‚áëf) Œº) := sorry

protected theorem smul {Œ± : Type u_1} [measurable_space Œ±] [topological_space Œ±] {Œº : measure Œ±} (hŒº : regular Œº) {x : ennreal} (hx : x < ‚ä§) : regular (x ‚Ä¢ Œº) := sorry

/-- A regular measure in a œÉ-compact space is œÉ-finite. -/
protected theorem sigma_finite {Œ± : Type u_1} [measurable_space Œ±] [topological_space Œ±] {Œº : measure Œ±} [opens_measurable_space Œ±] [t2_space Œ±] [sigma_compact_space Œ±] (hŒº : regular Œº) : sigma_finite Œº := sorry

end regular


end measure


end measure_theory


theorem is_compact.measure_lt_top_of_nhds_within {Œ± : Type u_1} [measurable_space Œ±] [topological_space Œ±] {s : set Œ±} {Œº : measure_theory.measure Œ±} (h : is_compact s) (hŒº : ‚àÄ (x : Œ±), x ‚àà s ‚Üí measure_theory.measure.finite_at_filter Œº (nhds_within x s)) : coe_fn Œº s < ‚ä§ := sorry

theorem is_compact.measure_lt_top {Œ± : Type u_1} [measurable_space Œ±] [topological_space Œ±] {s : set Œ±} {Œº : measure_theory.measure Œ±} [measure_theory.locally_finite_measure Œº] (h : is_compact s) : coe_fn Œº s < ‚ä§ :=
  is_compact.measure_lt_top_of_nhds_within h
    fun (x : Œ±) (hx : x ‚àà s) => measure_theory.measure.finite_at_nhds_within Œº x s

