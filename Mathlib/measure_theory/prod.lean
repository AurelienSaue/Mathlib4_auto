/-
Copyright (c) 2020 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.measure_theory.giry_monad
import Mathlib.measure_theory.set_integral
import Mathlib.PostPort

universes u_1 u_3 u_2 u_6 u_5 u_7 

namespace Mathlib

/-!
# The product measure

In this file we define and prove properties about the binary product measure. If `α` and `β` have
σ-finite measures `μ` resp. `ν` then `α × β` can be equipped with a σ-finite measure `μ.prod ν` that
satisfies `(μ.prod ν) s = ∫⁻ x, ν {y | (x, y) ∈ s} ∂μ`.
We also have `(μ.prod ν) (s.prod t) = μ s * ν t`, i.e. the measure of a rectangle is the product of
the measures of the sides.

We also prove Tonelli's theorem and Fubini's theorem.

## Main definition

* `measure_theory.measure.prod`: The product of two measures.

## Main results

* `measure_theory.measure.prod_apply` states `μ.prod ν s = ∫⁻ x, ν {y | (x, y) ∈ s} ∂μ`
  for measurable `s`. `measure_theory.measure.prod_apply_symm` is the reversed version.
* `measure_theory.measure.prod_prod` states `μ.prod ν (s.prod t) = μ s * ν t` for measurable sets
  `s` and `t`.
* `measure_theory.lintegral_prod`: Tonelli's theorem. It states that for a measurable function
  `α × β → ennreal` we have `∫⁻ z, f z ∂(μ.prod ν) = ∫⁻ x, ∫⁻ y, f (x, y) ∂ν ∂μ`. The version
  for functions `α → β → ennreal` is reversed, and called `lintegral_lintegral`. Both versions have
  a variant with `_symm` appended, where the order of integration is reversed.
  The lemma `measurable.lintegral_prod_right'` states that the inner integral of the right-hand side
  is measurable.
* `measure_theory.integrable_prod_iff` states that a binary function is integrable iff both
  * `y ↦ f (x, y)` is integrable for almost every `x`, and
  * the function `x ↦ ∫ ∥f (x, y)∥ dy` is integrable.
* `measure_theory.integral_prod`: Fubini's theorem. It states that for a integrable function
  `α × β → E` (where `E` is a second countable Banach space) we have
  `∫ z, f z ∂(μ.prod ν) = ∫ x, ∫ y, f (x, y) ∂ν ∂μ`. This theorem has the same variants as
  Tonelli's theorem. The lemma `measure_theory.integrable.integral_prod_right` states that the
  inner integral of the right-hand side is integrable.

## Implementation Notes

Many results are proven twice, once for functions in curried form (`α → β → γ`) and one for
functions in uncurried form (`α × β → γ`). The former often has an assumption
`measurable (uncurry f)`, which could be inconvenient to discharge, but for the latter it is more
common that the function has to be given explicitly, since Lean cannot synthesize the function by
itself. We name the lemmas about the uncurried form with a prime.
Tonelli's theorem and Fubini's theorem have a different naming scheme, since the version for the
uncurried version is reversed.

## Tags

product measure, Fubini's theorem, Tonelli's theorem, Fubini-Tonelli theorem
-/

/-- Rectangles formed by π-systems form a π-system. -/
theorem is_pi_system.prod {α : Type u_1} {β : Type u_3} {C : set (set α)} {D : set (set β)} (hC : is_pi_system C) (hD : is_pi_system D) : is_pi_system (set.image2 set.prod C D) := sorry

/-- Rectangles of countably spanning sets are countably spanning. -/
theorem is_countably_spanning.prod {α : Type u_1} {β : Type u_3} {C : set (set α)} {D : set (set β)} (hC : is_countably_spanning C) (hD : is_countably_spanning D) : is_countably_spanning (set.image2 set.prod C D) := sorry

/-! ### Measurability

Before we define the product measure, we can talk about the measurability of operations on binary
functions. We show that if `f` is a binary measurable function, then the function that integrates
along one of the variables (using either the Lebesgue or Bochner integral) is measurable.
-/

/-- The product of generated σ-algebras is the one generated by rectangles, if both generating sets
  are countably spanning. -/
theorem generate_from_prod_eq {α : Type u_1} {β : Type u_2} {C : set (set α)} {D : set (set β)} (hC : is_countably_spanning C) (hD : is_countably_spanning D) : prod.measurable_space = measurable_space.generate_from (set.image2 set.prod C D) := sorry

/-- If `C` and `D` generate the σ-algebras on `α` resp. `β`, then rectangles formed by `C` and `D`
  generate the σ-algebra on `α × β`. -/
theorem generate_from_eq_prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {C : set (set α)} {D : set (set β)} (hC : measurable_space.generate_from C = _inst_1) (hD : measurable_space.generate_from D = _inst_3) (h2C : is_countably_spanning C) (h2D : is_countably_spanning D) : measurable_space.generate_from (set.image2 set.prod C D) = prod.measurable_space := sorry

/-- The product σ-algebra is generated from boxes, i.e. `s.prod t` for sets `s : set α` and
  `t : set β`. -/
theorem generate_from_prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] : measurable_space.generate_from
    (set.image2 set.prod (set_of fun (s : set α) => is_measurable s) (set_of fun (t : set β) => is_measurable t)) =
  prod.measurable_space :=
  generate_from_eq_prod measurable_space.generate_from_is_measurable measurable_space.generate_from_is_measurable
    is_countably_spanning_is_measurable is_countably_spanning_is_measurable

/-- Rectangles form a π-system. -/
theorem is_pi_system_prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] : is_pi_system
  (set.image2 set.prod (set_of fun (s : set α) => is_measurable s) (set_of fun (t : set β) => is_measurable t)) :=
  is_pi_system.prod measurable_space.is_pi_system_is_measurable measurable_space.is_pi_system_is_measurable

/-- If `ν` is a finite measure, and `s ⊆ α × β` is measurable, then `x ↦ ν { y | (x, y) ∈ s }` is
  a measurable function. `measurable_measure_prod_mk_left` is strictly more general. -/
theorem measurable_measure_prod_mk_left_finite {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [measure_theory.finite_measure ν] {s : set (α × β)} (hs : is_measurable s) : measurable fun (x : α) => coe_fn ν (Prod.mk x ⁻¹' s) := sorry

/-- If `ν` is a σ-finite measure, and `s ⊆ α × β` is measurable, then `x ↦ ν { y | (x, y) ∈ s }` is
  a measurable function. -/
theorem measurable_measure_prod_mk_left {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {s : set (α × β)} (hs : is_measurable s) : measurable fun (x : α) => coe_fn ν (Prod.mk x ⁻¹' s) := sorry

/-- If `μ` is a σ-finite measure, and `s ⊆ α × β` is measurable, then `y ↦ μ { x | (x, y) ∈ s }` is
  a measurable function. -/
theorem measurable_measure_prod_mk_right {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} [measure_theory.sigma_finite μ] {s : set (α × β)} (hs : is_measurable s) : measurable fun (y : β) => coe_fn μ ((fun (x : α) => (x, y)) ⁻¹' s) :=
  measurable_measure_prod_mk_left (iff.mpr is_measurable_swap_iff hs)

theorem measurable.map_prod_mk_left {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] : measurable fun (x : α) => coe_fn (measure_theory.measure.map (Prod.mk x)) ν := sorry

theorem measurable.map_prod_mk_right {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} [measure_theory.sigma_finite μ] : measurable fun (y : β) => coe_fn (measure_theory.measure.map fun (x : α) => (x, y)) μ := sorry

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  Tonelli's theorem is measurable. -/
theorem measurable.lintegral_prod_right' {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {f : α × β → ennreal} (hf : measurable f) : measurable fun (x : α) => measure_theory.lintegral ν fun (y : β) => f (x, y) := sorry

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  Tonelli's theorem is measurable.
  This version has the argument `f` in curried form. -/
theorem measurable.lintegral_prod_right {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {f : α → β → ennreal} (hf : measurable (function.uncurry f)) : measurable fun (x : α) => measure_theory.lintegral ν fun (y : β) => f x y :=
  measurable.lintegral_prod_right' hf

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Tonelli's theorem is measurable. -/
theorem measurable.lintegral_prod_left' {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} [measure_theory.sigma_finite μ] {f : α × β → ennreal} (hf : measurable f) : measurable fun (y : β) => measure_theory.lintegral μ fun (x : α) => f (x, y) :=
  measurable.lintegral_prod_right' (iff.mpr measurable_swap_iff hf)

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Tonelli's theorem is measurable.
  This version has the argument `f` in curried form. -/
theorem measurable.lintegral_prod_left {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} [measure_theory.sigma_finite μ] {f : α → β → ennreal} (hf : measurable (function.uncurry f)) : measurable fun (y : β) => measure_theory.lintegral μ fun (x : α) => f x y :=
  measurable.lintegral_prod_left' hf

theorem is_measurable_integrable {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [normed_group E] [measurable_space E] [measure_theory.sigma_finite ν] [opens_measurable_space E] {f : α → β → E} (hf : measurable (function.uncurry f)) : is_measurable (set_of fun (x : α) => measure_theory.integrable (f x)) := sorry

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  Fubini's theorem is measurable.
  This version has `f` in curried form. -/
theorem measurable.integral_prod_right {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [normed_group E] [measurable_space E] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [measure_theory.sigma_finite ν] {f : α → β → E} (hf : measurable (function.uncurry f)) : measurable fun (x : α) => measure_theory.integral ν fun (y : β) => f x y := sorry

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  Fubini's theorem is measurable. -/
theorem measurable.integral_prod_right' {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {ν : measure_theory.measure β} [normed_group E] [measurable_space E] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [measure_theory.sigma_finite ν] {f : α × β → E} (hf : measurable f) : measurable fun (x : α) => measure_theory.integral ν fun (y : β) => f (x, y) :=
  measurable.integral_prod_right (eq.mp (Eq._oldrec (Eq.refl (measurable f)) (Eq.symm (function.uncurry_curry f))) hf)

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Fubini's theorem is measurable.
  This version has `f` in curried form. -/
theorem measurable.integral_prod_left {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} [normed_group E] [measurable_space E] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [measure_theory.sigma_finite μ] {f : α → β → E} (hf : measurable (function.uncurry f)) : measurable fun (y : β) => measure_theory.integral μ fun (x : α) => f x y :=
  measurable.integral_prod_right' (measurable.comp hf measurable_swap)

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Fubini's theorem is measurable. -/
theorem measurable.integral_prod_left' {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} [normed_group E] [measurable_space E] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [measure_theory.sigma_finite μ] {f : α × β → E} (hf : measurable f) : measurable fun (y : β) => measure_theory.integral μ fun (x : α) => f (x, y) :=
  measurable.integral_prod_right' (measurable.comp hf measurable_swap)

/-! ### The product measure -/

namespace measure_theory


namespace measure


/-- The binary product of measures. They are defined for arbitrary measures, but we basically
  prove all properties under the assumption that at least one of them is σ-finite. -/
protected def prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] (μ : measure α) (ν : measure β) : measure (α × β) :=
  bind μ fun (x : α) => coe_fn (map (Prod.mk x)) ν

protected instance prod.measure_space {α : Type u_1} {β : Type u_2} [measure_space α] [measure_space β] : measure_space (α × β) :=
  measure_space.mk (measure.prod volume volume)

theorem prod_apply {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] {s : set (α × β)} (hs : is_measurable s) : coe_fn (measure.prod μ ν) s = lintegral μ fun (x : α) => coe_fn ν (Prod.mk x ⁻¹' s) := sorry

@[simp] theorem prod_prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] {s : set α} {t : set β} (hs : is_measurable s) (ht : is_measurable t) : coe_fn (measure.prod μ ν) (set.prod s t) = coe_fn μ s * coe_fn ν t := sorry

/-- If we don't assume measurability of `s` and `t`, we can bound the measure of their product. -/
theorem prod_prod_le {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] (s : set α) (t : set β) : coe_fn (measure.prod μ ν) (set.prod s t) ≤ coe_fn μ s * coe_fn ν t := sorry

theorem ae_measure_lt_top {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] {s : set (α × β)} (hs : is_measurable s) (h2s : coe_fn (measure.prod μ ν) s < ⊤) : filter.eventually (fun (x : α) => coe_fn ν (Prod.mk x ⁻¹' s) < ⊤) (ae μ) := sorry

theorem integrable_measure_prod_mk_left {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] {s : set (α × β)} (hs : is_measurable s) (h2s : coe_fn (measure.prod μ ν) s < ⊤) : integrable fun (x : α) => ennreal.to_real (coe_fn ν (Prod.mk x ⁻¹' s)) := sorry

/-- Note: the assumption `hs` cannot be dropped. For a counterexample, see
  Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
theorem measure_prod_null {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] {s : set (α × β)} (hs : is_measurable s) : coe_fn (measure.prod μ ν) s = 0 ↔ filter.eventually_eq (ae μ) (fun (x : α) => coe_fn ν (Prod.mk x ⁻¹' s)) 0 := sorry

/-- Note: the converse is not true without assuming that `s` is measurable. For a counterexample,
  see Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
theorem measure_ae_null_of_prod_null {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] {s : set (α × β)} (h : coe_fn (measure.prod μ ν) s = 0) : filter.eventually_eq (ae μ) (fun (x : α) => coe_fn ν (Prod.mk x ⁻¹' s)) 0 := sorry

/-- Note: the converse is not true. For a counterexample, see
  Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
theorem ae_ae_of_ae_prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] {p : α × β → Prop} (h : filter.eventually (fun (z : α × β) => p z) (ae (measure.prod μ ν))) : filter.eventually (fun (x : α) => filter.eventually (fun (y : β) => p (x, y)) (ae ν)) (ae μ) :=
  measure_ae_null_of_prod_null h

/-- `μ.prod ν` has finite spanning sets in rectangles of finite spanning sets. -/
def finite_spanning_sets_in.prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} {C : set (set α)} {D : set (set β)} (hμ : finite_spanning_sets_in μ C) (hν : finite_spanning_sets_in ν D) (hC : ∀ (s : set α), s ∈ C → is_measurable s) (hD : ∀ (t : set β), t ∈ D → is_measurable t) : finite_spanning_sets_in (measure.prod μ ν) (set.image2 set.prod C D) :=
  finite_spanning_sets_in.mk
    (fun (n : ℕ) =>
      set.prod (finite_spanning_sets_in.set hμ (prod.fst (nat.unpair n)))
        (finite_spanning_sets_in.set hν (prod.snd (nat.unpair n))))
    sorry sorry sorry

protected instance prod.sigma_finite {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] [sigma_finite μ] : sigma_finite (measure.prod μ ν) := sorry

/-- Measures on a product space are equal the product measure if they are equal on rectangles
  with as sides sets that generate the corresponding σ-algebras. -/
theorem prod_eq_generate_from {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} {C : set (set α)} {D : set (set β)} (hC : measurable_space.generate_from C = _inst_1) (hD : measurable_space.generate_from D = _inst_3) (h2C : is_pi_system C) (h2D : is_pi_system D) (h3C : finite_spanning_sets_in μ C) (h3D : finite_spanning_sets_in ν D) {μν : measure (α × β)} (h₁ : ∀ (s : set α), s ∈ C → ∀ (t : set β), t ∈ D → coe_fn μν (set.prod s t) = coe_fn μ s * coe_fn ν t) : measure.prod μ ν = μν := sorry

/-- Measures on a product space are equal to the product measure if they are equal on rectangles. -/
theorem prod_eq {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] [sigma_finite μ] {μν : measure (α × β)} (h : ∀ (s : set α) (t : set β), is_measurable s → is_measurable t → coe_fn μν (set.prod s t) = coe_fn μ s * coe_fn ν t) : measure.prod μ ν = μν := sorry

theorem prod_swap {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] [sigma_finite μ] : coe_fn (map prod.swap) (measure.prod μ ν) = measure.prod ν μ := sorry

theorem prod_apply_symm {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] [sigma_finite μ] {s : set (α × β)} (hs : is_measurable s) : coe_fn (measure.prod μ ν) s = lintegral ν fun (y : β) => coe_fn μ ((fun (x : α) => (x, y)) ⁻¹' s) := sorry

theorem prod_assoc_prod {α : Type u_1} {β : Type u_3} {γ : Type u_5} [measurable_space α] [measurable_space β] [measurable_space γ] {μ : measure α} {ν : measure β} {τ : measure γ} [sigma_finite ν] [sigma_finite μ] [sigma_finite τ] : coe_fn (map ⇑measurable_equiv.prod_assoc) (measure.prod (measure.prod μ ν) τ) = measure.prod μ (measure.prod ν τ) := sorry

/-! ### The product of specific measures -/

theorem prod_restrict {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] [sigma_finite μ] {s : set α} {t : set β} (hs : is_measurable s) (ht : is_measurable t) : measure.prod (restrict μ s) (restrict ν t) = restrict (measure.prod μ ν) (set.prod s t) := sorry

theorem prod_dirac {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} [sigma_finite μ] (y : β) : measure.prod μ (dirac y) = coe_fn (map fun (x : α) => (x, y)) μ := sorry

theorem dirac_prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure β} [sigma_finite ν] (x : α) : measure.prod (dirac x) ν = coe_fn (map (Prod.mk x)) ν := sorry

theorem dirac_prod_dirac {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {x : α} {y : β} : measure.prod (dirac x) (dirac y) = dirac (x, y) := sorry

theorem prod_sum {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} [sigma_finite μ] {ι : Type u_2} [fintype ι] (ν : ι → measure β) [∀ (i : ι), sigma_finite (ν i)] : measure.prod μ (sum ν) = sum fun (i : ι) => measure.prod μ (ν i) := sorry

theorem sum_prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure β} [sigma_finite ν] {ι : Type u_2} [fintype ι] (μ : ι → measure α) [∀ (i : ι), sigma_finite (μ i)] : measure.prod (sum μ) ν = sum fun (i : ι) => measure.prod (μ i) ν := sorry

theorem prod_add {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] [sigma_finite μ] (ν' : measure β) [sigma_finite ν'] : measure.prod μ (ν + ν') = measure.prod μ ν + measure.prod μ ν' := sorry

theorem add_prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] [sigma_finite μ] (μ' : measure α) [sigma_finite μ'] : measure.prod (μ + μ') ν = measure.prod μ ν + measure.prod μ' ν := sorry

end measure


end measure_theory


theorem ae_measurable.prod_swap {α : Type u_1} {β : Type u_3} {γ : Type u_5} [measurable_space α] [measurable_space β] [measurable_space γ] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] [measure_theory.sigma_finite μ] {f : α × β → γ} (hf : ae_measurable f) : ae_measurable fun (z : β × α) => f (prod.swap z) :=
  ae_measurable.comp_measurable
    (eq.mp (Eq._oldrec (Eq.refl (ae_measurable f)) (Eq.symm measure_theory.measure.prod_swap)) hf) measurable_swap

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  Fubini's theorem is measurable. -/
theorem ae_measurable.integral_prod_right' {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [normed_group E] [measurable_space E] [measure_theory.sigma_finite ν] [topological_space.second_countable_topology E] [normed_space ℝ E] [borel_space E] [complete_space E] {f : α × β → E} (hf : ae_measurable f) : ae_measurable fun (x : α) => measure_theory.integral ν fun (y : β) => f (x, y) := sorry

theorem ae_measurable.prod_mk_left {α : Type u_1} {β : Type u_3} {γ : Type u_5} [measurable_space α] [measurable_space β] [measurable_space γ] {μ : measure_theory.measure α} {ν : measure_theory.measure β} [measure_theory.sigma_finite ν] {f : α × β → γ} (hf : ae_measurable f) : filter.eventually (fun (x : α) => ae_measurable fun (y : β) => f (x, y)) (measure_theory.measure.ae μ) := sorry

namespace measure_theory


/-! ### The Lebesgue integral on a product -/

theorem lintegral_prod_swap {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] [sigma_finite μ] (f : α × β → ennreal) (hf : ae_measurable f) : (lintegral (measure.prod ν μ) fun (z : β × α) => f (prod.swap z)) = lintegral (measure.prod μ ν) fun (z : α × β) => f z := sorry

/-- Tonelli's Theorem: For `ennreal`-valued measurable functions on `α × β`,
  the integral of `f` is equal to the iterated integral. -/
theorem lintegral_prod {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] (f : α × β → ennreal) (hf : measurable f) : (lintegral (measure.prod μ ν) fun (z : α × β) => f z) = lintegral μ fun (x : α) => lintegral ν fun (y : β) => f (x, y) := sorry

/-- Tonelli's Theorem: For `ennreal`-valued almost everywhere measurable functions on `α × β`,
  the integral of `f` is equal to the iterated integral. -/
theorem lintegral_prod' {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] (f : α × β → ennreal) (hf : ae_measurable f) : (lintegral (measure.prod μ ν) fun (z : α × β) => f z) = lintegral μ fun (x : α) => lintegral ν fun (y : β) => f (x, y) := sorry

/-- The symmetric verion of Tonelli's Theorem: For `ennreal`-valued almost everywhere measurable
functions on `α × β`,  the integral of `f` is equal to the iterated integral, in reverse order. -/
theorem lintegral_prod_symm' {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] [sigma_finite μ] (f : α × β → ennreal) (hf : ae_measurable f) : (lintegral (measure.prod μ ν) fun (z : α × β) => f z) = lintegral ν fun (y : β) => lintegral μ fun (x : α) => f (x, y) := sorry

/-- The symmetric verion of Tonelli's Theorem: For `ennreal`-valued measurable
functions on `α × β`,  the integral of `f` is equal to the iterated integral, in reverse order. -/
theorem lintegral_prod_symm {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] [sigma_finite μ] (f : α × β → ennreal) (hf : measurable f) : (lintegral (measure.prod μ ν) fun (z : α × β) => f z) = lintegral ν fun (y : β) => lintegral μ fun (x : α) => f (x, y) :=
  lintegral_prod_symm' f (measurable.ae_measurable hf)

/-- The reversed version of Tonelli's Theorem. In this version `f` is in curried form, which makes
  it easier for the elaborator to figure out `f` automatically. -/
theorem lintegral_lintegral {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] {f : α → β → ennreal} (hf : measurable (function.uncurry f)) : (lintegral μ fun (x : α) => lintegral ν fun (y : β) => f x y) =
  lintegral (measure.prod μ ν) fun (z : α × β) => f (prod.fst z) (prod.snd z) :=
  Eq.symm (lintegral_prod (function.uncurry f) hf)

/-- The reversed version of Tonelli's Theorem (symmetric version). In this version `f` is in curried
  form, which makes it easier for the elaborator to figure out `f` automatically. -/
theorem lintegral_lintegral_symm {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] [sigma_finite μ] {f : α → β → ennreal} (hf : measurable (function.uncurry f)) : (lintegral μ fun (x : α) => lintegral ν fun (y : β) => f x y) =
  lintegral (measure.prod ν μ) fun (z : β × α) => f (prod.snd z) (prod.fst z) :=
  Eq.symm (lintegral_prod_symm (function.uncurry f ∘ prod.swap) (measurable.comp hf measurable_swap))

/-- Change the order of Lebesgue integration. -/
theorem lintegral_lintegral_swap {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] [sigma_finite μ] {f : α → β → ennreal} (hf : measurable (function.uncurry f)) : (lintegral μ fun (x : α) => lintegral ν fun (y : β) => f x y) =
  lintegral ν fun (y : β) => lintegral μ fun (x : α) => f x y :=
  Eq.trans (lintegral_lintegral hf) (lintegral_prod_symm (fun (z : α × β) => f (prod.fst z) (prod.snd z)) hf)

theorem lintegral_prod_mul {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [sigma_finite ν] {f : α → ennreal} {g : β → ennreal} (hf : measurable f) (hg : measurable g) : (lintegral (measure.prod μ ν) fun (z : α × β) => f (prod.fst z) * g (prod.snd z)) =
  (lintegral μ fun (x : α) => f x) * lintegral ν fun (y : β) => g y := sorry

/-! ### Integrability on a product -/

theorem integrable.swap {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [opens_measurable_space E] [sigma_finite μ] {f : α × β → E} (hf : integrable f) : integrable (f ∘ prod.swap) := sorry

theorem integrable_swap_iff {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [opens_measurable_space E] [sigma_finite μ] {f : α × β → E} : integrable (f ∘ prod.swap) ↔ integrable f := sorry

theorem has_finite_integral_prod_iff {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [opens_measurable_space E] {f : α × β → E} (h1f : measurable f) : has_finite_integral f ↔
  filter.eventually (fun (x : α) => has_finite_integral fun (y : β) => f (x, y)) (measure.ae μ) ∧
    has_finite_integral fun (x : α) => integral ν fun (y : β) => norm (f (x, y)) := sorry

theorem has_finite_integral_prod_iff' {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [opens_measurable_space E] {f : α × β → E} (h1f : ae_measurable f) : has_finite_integral f ↔
  filter.eventually (fun (x : α) => has_finite_integral fun (y : β) => f (x, y)) (measure.ae μ) ∧
    has_finite_integral fun (x : α) => integral ν fun (y : β) => norm (f (x, y)) := sorry

/-- A binary function is integrable if the function `y ↦ f (x, y)` is integrable for almost every
  `x` and the function `x ↦ ∫ ∥f (x, y)∥ dy` is integrable. -/
theorem integrable_prod_iff {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [opens_measurable_space E] {f : α × β → E} (h1f : ae_measurable f) : integrable f ↔
  filter.eventually (fun (x : α) => integrable fun (y : β) => f (x, y)) (measure.ae μ) ∧
    integrable fun (x : α) => integral ν fun (y : β) => norm (f (x, y)) := sorry

/-- A binary function is integrable if the function `x ↦ f (x, y)` is integrable for almost every
  `y` and the function `y ↦ ∫ ∥f (x, y)∥ dx` is integrable. -/
theorem integrable_prod_iff' {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [opens_measurable_space E] [sigma_finite μ] {f : α × β → E} (h1f : ae_measurable f) : integrable f ↔
  filter.eventually (fun (y : β) => integrable fun (x : α) => f (x, y)) (measure.ae ν) ∧
    integrable fun (y : β) => integral μ fun (x : α) => norm (f (x, y)) := sorry

theorem integrable.prod_left_ae {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [opens_measurable_space E] [sigma_finite μ] {f : α × β → E} (hf : integrable f) : filter.eventually (fun (y : β) => integrable fun (x : α) => f (x, y)) (measure.ae ν) :=
  and.left (iff.mp (integrable_prod_iff' (integrable.ae_measurable hf)) hf)

theorem integrable.prod_right_ae {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [opens_measurable_space E] [sigma_finite μ] {f : α × β → E} (hf : integrable f) : filter.eventually (fun (x : α) => integrable fun (y : β) => f (x, y)) (measure.ae μ) :=
  integrable.prod_left_ae (integrable.swap hf)

theorem integrable.integral_norm_prod_left {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [opens_measurable_space E] {f : α × β → E} (hf : integrable f) : integrable fun (x : α) => integral ν fun (y : β) => norm (f (x, y)) :=
  and.right (iff.mp (integrable_prod_iff (integrable.ae_measurable hf)) hf)

theorem integrable.integral_norm_prod_right {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [opens_measurable_space E] [sigma_finite μ] {f : α × β → E} (hf : integrable f) : integrable fun (y : β) => integral μ fun (x : α) => norm (f (x, y)) :=
  integrable.integral_norm_prod_left (integrable.swap hf)

theorem integrable.integral_prod_left {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] {f : α × β → E} (hf : integrable f) : integrable fun (x : α) => integral ν fun (y : β) => f (x, y) := sorry

theorem integrable.integral_prod_right {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [sigma_finite μ] {f : α × β → E} (hf : integrable f) : integrable fun (y : β) => integral μ fun (x : α) => f (x, y) :=
  integrable.integral_prod_left (integrable.swap hf)

/-! ### The Bochner integral on a product -/

theorem integral_prod_swap {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [sigma_finite μ] (f : α × β → E) (hf : ae_measurable f) : (integral (measure.prod ν μ) fun (z : β × α) => f (prod.swap z)) = integral (measure.prod μ ν) fun (z : α × β) => f z := sorry

/-! Some rules about the sum/difference of double integrals. They follow from `integral_add`, but
  we separate them out as separate lemmas, because they involve quite some steps. -/

/-- Integrals commute with addition inside another integral. `F` can be any function. -/
theorem integral_fn_integral_add {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [sigma_finite μ] {E' : Type u_7} [measurable_space E'] [normed_group E'] [borel_space E'] [complete_space E'] [normed_space ℝ E'] [topological_space.second_countable_topology E'] {f : α × β → E} {g : α × β → E} (F : E → E') (hf : integrable f) (hg : integrable g) : (integral μ fun (x : α) => F (integral ν fun (y : β) => f (x, y) + g (x, y))) =
  integral μ fun (x : α) => F ((integral ν fun (y : β) => f (x, y)) + integral ν fun (y : β) => g (x, y)) := sorry

/-- Integrals commute with subtraction inside another integral.
  `F` can be any measurable function. -/
theorem integral_fn_integral_sub {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [sigma_finite μ] {E' : Type u_7} [measurable_space E'] [normed_group E'] [borel_space E'] [complete_space E'] [normed_space ℝ E'] [topological_space.second_countable_topology E'] {f : α × β → E} {g : α × β → E} (F : E → E') (hf : integrable f) (hg : integrable g) : (integral μ fun (x : α) => F (integral ν fun (y : β) => f (x, y) - g (x, y))) =
  integral μ fun (x : α) => F ((integral ν fun (y : β) => f (x, y)) - integral ν fun (y : β) => g (x, y)) := sorry

/-- Integrals commute with subtraction inside a lower Lebesgue integral.
  `F` can be any function. -/
theorem lintegral_fn_integral_sub {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [sigma_finite μ] {f : α × β → E} {g : α × β → E} (F : E → ennreal) (hf : integrable f) (hg : integrable g) : (lintegral μ fun (x : α) => F (integral ν fun (y : β) => f (x, y) - g (x, y))) =
  lintegral μ fun (x : α) => F ((integral ν fun (y : β) => f (x, y)) - integral ν fun (y : β) => g (x, y)) := sorry

/-- Double integrals commute with addition. -/
theorem integral_integral_add {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [sigma_finite μ] {f : α × β → E} {g : α × β → E} (hf : integrable f) (hg : integrable g) : (integral μ fun (x : α) => integral ν fun (y : β) => f (x, y) + g (x, y)) =
  (integral μ fun (x : α) => integral ν fun (y : β) => f (x, y)) +
    integral μ fun (x : α) => integral ν fun (y : β) => g (x, y) :=
  Eq.trans (integral_fn_integral_add id hf hg)
    (integral_add (integrable.integral_prod_left hf) (integrable.integral_prod_left hg))

/-- Double integrals commute with addition. This is the version with `(f + g) (x, y)`
  (instead of `f (x, y) + g (x, y)`) in the LHS. -/
theorem integral_integral_add' {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [sigma_finite μ] {f : α × β → E} {g : α × β → E} (hf : integrable f) (hg : integrable g) : (integral μ fun (x : α) => integral ν fun (y : β) => Add.add f g (x, y)) =
  (integral μ fun (x : α) => integral ν fun (y : β) => f (x, y)) +
    integral μ fun (x : α) => integral ν fun (y : β) => g (x, y) :=
  integral_integral_add hf hg

/-- Double integrals commute with subtraction. -/
theorem integral_integral_sub {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [sigma_finite μ] {f : α × β → E} {g : α × β → E} (hf : integrable f) (hg : integrable g) : (integral μ fun (x : α) => integral ν fun (y : β) => f (x, y) - g (x, y)) =
  (integral μ fun (x : α) => integral ν fun (y : β) => f (x, y)) -
    integral μ fun (x : α) => integral ν fun (y : β) => g (x, y) :=
  Eq.trans (integral_fn_integral_sub id hf hg)
    (integral_sub (integrable.integral_prod_left hf) (integrable.integral_prod_left hg))

/-- Double integrals commute with subtraction. This is the version with `(f - g) (x, y)`
  (instead of `f (x, y) - g (x, y)`) in the LHS. -/
theorem integral_integral_sub' {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [sigma_finite μ] {f : α × β → E} {g : α × β → E} (hf : integrable f) (hg : integrable g) : (integral μ fun (x : α) => integral ν fun (y : β) => Sub.sub f g (x, y)) =
  (integral μ fun (x : α) => integral ν fun (y : β) => f (x, y)) -
    integral μ fun (x : α) => integral ν fun (y : β) => g (x, y) :=
  integral_integral_sub hf hg

/-- The map that sends an L¹-function `f : α × β → E` to `∫∫f` is continuous. -/
theorem continuous_integral_integral {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [sigma_finite μ] : continuous
  fun (f : l1 (α × β) E (measure.prod μ ν)) => integral μ fun (x : α) => integral ν fun (y : β) => coe_fn f (x, y) := sorry

/-- Fubini's Theorem: For integrable functions on `α × β`,
  the Bochner integral of `f` is equal to the iterated Bochner integral.
  `integrable_prod_iff` can be useful to show that the function in question in integrable.
  `measure_theory.integrable.integral_prod_right` is useful to show that the inner integral
  of the right-hand side is integrable. -/
theorem integral_prod {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [sigma_finite μ] (f : α × β → E) (hf : integrable f) : (integral (measure.prod μ ν) fun (z : α × β) => f z) = integral μ fun (x : α) => integral ν fun (y : β) => f (x, y) := sorry

/-- Symmetric version of Fubini's Theorem: For integrable functions on `α × β`,
  the Bochner integral of `f` is equal to the iterated Bochner integral.
  This version has the integrals on the right-hand side in the other order. -/
theorem integral_prod_symm {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [sigma_finite μ] (f : α × β → E) (hf : integrable f) : (integral (measure.prod μ ν) fun (z : α × β) => f z) = integral ν fun (y : β) => integral μ fun (x : α) => f (x, y) := sorry

/-- Reversed version of Fubini's Theorem. -/
theorem integral_integral {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [sigma_finite μ] {f : α → β → E} (hf : integrable (function.uncurry f)) : (integral μ fun (x : α) => integral ν fun (y : β) => f x y) =
  integral (measure.prod μ ν) fun (z : α × β) => f (prod.fst z) (prod.snd z) :=
  Eq.symm (integral_prod (function.uncurry f) hf)

/-- Reversed version of Fubini's Theorem (symmetric version). -/
theorem integral_integral_symm {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [sigma_finite μ] {f : α → β → E} (hf : integrable (function.uncurry f)) : (integral μ fun (x : α) => integral ν fun (y : β) => f x y) =
  integral (measure.prod ν μ) fun (z : β × α) => f (prod.snd z) (prod.fst z) :=
  Eq.symm (integral_prod_symm (function.uncurry f ∘ prod.swap) (integrable.swap hf))

/-- Change the order of Bochner integration. -/
theorem integral_integral_swap {α : Type u_1} {β : Type u_3} {E : Type u_6} [measurable_space α] [measurable_space β] {μ : measure α} {ν : measure β} [normed_group E] [measurable_space E] [sigma_finite ν] [topological_space.second_countable_topology E] [normed_space ℝ E] [complete_space E] [borel_space E] [sigma_finite μ] {f : α → β → E} (hf : integrable (function.uncurry f)) : (integral μ fun (x : α) => integral ν fun (y : β) => f x y) = integral ν fun (y : β) => integral μ fun (x : α) => f x y :=
  Eq.trans (integral_integral hf) (integral_prod_symm (fun (z : α × β) => f (prod.fst z) (prod.snd z)) hf)

