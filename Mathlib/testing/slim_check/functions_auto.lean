/-
Copyright (c) 2020 Simon Hudon. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: Simon Hudon
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.data.list.sigma
import Mathlib.testing.slim_check.sampleable
import Mathlib.testing.slim_check.testable
import Mathlib.tactic.pretty_cases
import Mathlib.PostPort

universes u v l u_1 u_2 w 

namespace Mathlib

/-!
## `slim_check`: generators for functions

This file defines `sampleable` instances for `α → β` functions and
`ℤ → ℤ` injective functions.

Functions are generated by creating a list of pairs and one more value
using the list as a lookup table and resorting to the additional value
when a value is not found in the table.

Injective functions are generated by creating a list of numbers and
a permutation of that list. The permutation insures that every input
is mapped to a unique output. When an input is not found in the list
the input itself is used as an output.

Injective functions `f : α → α` could be generated easily instead of
`ℤ → ℤ` by generating a `list α`, removing duplicates and creating a
permutations. One has to be careful when generating the domain to make
if vast enough that, when generating arguments to apply `f` to,
they argument should be likely to lie in the domain of `f`. This is
the reason that injective functions `f : ℤ → ℤ` are generated by
fixing the domain to the range `[-2*size .. -2*size]`, with `size`
the size parameter of the `gen` monad.

Much of the machinery provided in this file is applicable to generate
injective functions of type `α → α` and new instances should be easy
to define.

Other classes of functions such as monotone functions can generated using
similar techniques. For monotone functions, generating two lists, sorting them
and matching them should suffice, with appropriate default values.
Some care must be taken for shrinking such functions to make sure
their defining property is invariant through shrinking. Injective
functions are an example of how complicated it can get.
-/

namespace slim_check


/-- Data structure specifying a total function using a list of pairs
and a default value returned when the input is not in the domain of
the partial function.

`with_default f y` encodes `x ↦ f x` when `x ∈ f` and `x ↦ y`
otherwise.

We use `Σ` to encode mappings instead of `×` because we
rely on the association list API defined in `data.list.sigma`.
 -/
inductive total_function (α : Type u) (β : Type v) where
| with_default : List (sigma fun (_x : α) => β) → β → total_function α β

protected instance total_function.inhabited {α : Type u_1} {β : Type u_2} [Inhabited β] :
    Inhabited (total_function α β) :=
  { default := total_function.with_default ∅ Inhabited.default }

namespace total_function


/-- Apply a total function to an argument. -/
def apply {α : Type u_1} {β : Type u_2} [DecidableEq α] : total_function α β → α → β := sorry

/--
Implementation of `has_repr (total_function α β)`.

Creates a string for a given `finmap` and output, `x₀ ↦ y₀, .. xₙ ↦ yₙ`
for each of the entries. The brackets are provided by the calling function.
-/
def repr_aux {α : Type u} [has_repr α] {β : Type v} [has_repr β]
    (m : List (sigma fun (_x : α) => β)) : string :=
  string.join
    (list.qsort (fun (x y : string) => to_bool (x < y))
      (list.map
        (fun (x : sigma fun (_x : α) => β) =>
          string.empty ++ to_string (repr (sigma.fst x)) ++
            (string.str
                  (string.str
                    (string.str string.empty (char.of_nat (bit0 (bit0 (bit0 (bit0 (bit0 1)))))))
                    (char.of_nat
                      (bit0
                        (bit1
                          (bit1
                            (bit0
                              (bit0 (bit1 (bit0 (bit1 (bit1 (bit0 (bit0 (bit0 (bit0 1)))))))))))))))
                  (char.of_nat (bit0 (bit0 (bit0 (bit0 (bit0 1)))))) ++
                to_string (repr (sigma.snd x)) ++
              string.str
                (string.str string.empty (char.of_nat (bit0 (bit0 (bit1 (bit1 (bit0 1)))))))
                (char.of_nat (bit0 (bit0 (bit0 (bit0 (bit0 1))))))))
        m))

/--
Produce a string for a given `total_function`.
The output is of the form `[x₀ ↦ f x₀, .. xₙ ↦ f xₙ, _ ↦ y]`.
-/
protected def repr {α : Type u} [has_repr α] {β : Type v} [has_repr β] :
    total_function α β → string :=
  sorry

protected instance has_repr (α : Type u) (β : Type v) [has_repr α] [has_repr β] :
    has_repr (total_function α β) :=
  has_repr.mk total_function.repr

/-- Create a `finmap` from a list of pairs. -/
def list.to_finmap' {α : Type u_1} {β : Type u_2} (xs : List (α × β)) :
    List (sigma fun (_x : α) => β) :=
  list.map prod.to_sigma xs

/-- Redefine `sizeof` to follow the structure of `sampleable` instances. -/
def total.sizeof {α : Type u} {β : Type v} [sampleable α] [sampleable β] : total_function α β → ℕ :=
  sorry

protected instance has_sizeof {α : Type u} {β : Type v} [sampleable α] [sampleable β] :
    SizeOf (total_function α β) :=
  { sizeOf := total.sizeof }

/-- Shrink a total function by shrinking the lists that represent it. -/
protected def shrink {α : Type u} {β : Type v} [sampleable α] [sampleable β] [DecidableEq α] :
    shrink_fn (total_function α β) :=
  sorry

protected instance pi.sampleable_ext {α : Type u} {β : Type v} [sampleable α] [sampleable β]
    [DecidableEq α] [has_repr α] [has_repr β] : sampleable_ext (α → β) :=
  sampleable_ext.mk (total_function α β)
    (do 
      sample (List (α × β))
      uliftable.up (sample β)
      sorry)
    total_function.shrink

protected instance pi_pred.sampleable_ext {α : Type u} [sampleable_ext (α → Bool)] :
    sampleable_ext (α → Prop) :=
  sampleable_ext.mk (sampleable_ext.proxy_repr (α → Bool)) (sampleable_ext.sample (α → Bool))
    sampleable_ext.shrink

protected instance pi_uncurry.sampleable_ext {α : Type u} {β : Type v} {γ : Sort w}
    [sampleable_ext (α × β → γ)] : sampleable_ext (α → β → γ) :=
  sampleable_ext.mk (sampleable_ext.proxy_repr (α × β → γ)) (sampleable_ext.sample (α × β → γ))
    sampleable_ext.shrink

end total_function


/--
Data structure specifying a total function using a list of pairs
and a default value returned when the input is not in the domain of
the partial function.

`map_to_self f` encodes `x ↦ f x` when `x ∈ f` and `x ↦ x`,
i.e. `x` to itself, otherwise.

We use `Σ` to encode mappings instead of `×` because we
rely on the association list API defined in `data.list.sigma`.
-/
inductive injective_function (α : Type u) where
| map_to_self :
    (xs : List (sigma fun (_x : α) => α)) →
      list.map sigma.fst xs ~ list.map sigma.snd xs →
        list.nodup (list.map sigma.snd xs) → injective_function α

protected instance injective_function.inhabited {α : Type u_1} : Inhabited (injective_function α) :=
  { default := injective_function.map_to_self [] list.perm.nil list.nodup_nil }

namespace injective_function


/-- Apply a total function to an argument. -/
def apply {α : Type u} [DecidableEq α] : injective_function α → α → α := sorry

/--
Produce a string for a given `total_function`.
The output is of the form `[x₀ ↦ f x₀, .. xₙ ↦ f xₙ, x ↦ x]`.
Unlike for `total_function`, the default value is not a constant
but the identity function.
-/
protected def repr {α : Type u} [has_repr α] : injective_function α → string := sorry

protected instance has_repr (α : Type u) [has_repr α] : has_repr (injective_function α) :=
  has_repr.mk injective_function.repr

/-- Interpret a list of pairs as a total function, defaulting to
the identity function when no entries are found for a given function -/
def list.apply_id {α : Type u} [DecidableEq α] (xs : List (α × α)) (x : α) : α :=
  option.get_or_else (list.lookup x (list.map prod.to_sigma xs)) x

@[simp] theorem list.apply_id_cons {α : Type u} [DecidableEq α] (xs : List (α × α)) (x : α) (y : α)
    (z : α) : list.apply_id ((y, z) :: xs) x = ite (y = x) z (list.apply_id xs x) :=
  sorry

theorem list.apply_id_zip_eq {α : Type u} [DecidableEq α] {xs : List α} {ys : List α}
    (h₀ : list.nodup xs) (h₁ : list.length xs = list.length ys) (x : α) (y : α) (i : ℕ)
    (h₂ : list.nth xs i = some x) : list.apply_id (list.zip xs ys) x = y ↔ list.nth ys i = some y :=
  sorry

theorem apply_id_mem_iff {α : Type u} [DecidableEq α] {xs : List α} {ys : List α}
    (h₀ : list.nodup xs) (h₁ : xs ~ ys) (x : α) : list.apply_id (list.zip xs ys) x ∈ ys ↔ x ∈ xs :=
  sorry

theorem list.apply_id_eq_self {α : Type u} [DecidableEq α] {xs : List α} {ys : List α} (x : α) :
    ¬x ∈ xs → list.apply_id (list.zip xs ys) x = x :=
  sorry

theorem apply_id_injective {α : Type u} [DecidableEq α] {xs : List α} {ys : List α}
    (h₀ : list.nodup xs) (h₁ : xs ~ ys) : function.injective (list.apply_id (list.zip xs ys)) :=
  sorry

/--
Remove a slice of length `m` at index `n` in a list and a permutation, maintaining the property
that it is a permutation.
-/
def perm.slice {α : Type u_1} [DecidableEq α] (n : ℕ) (m : ℕ) :
    (psigma fun (xs : List α) => psigma fun (ys : List α) => xs ~ ys ∧ list.nodup ys) →
        psigma fun (xs : List α) => psigma fun (ys : List α) => xs ~ ys ∧ list.nodup ys :=
  sorry

/--
A lazy list, in decreasing order, of sizes that should be
sliced off a list of length `n`
-/
def slice_sizes : ℕ → lazy_list ℕ+ := sorry

/--
Shrink a permutation of a list, slicing a segment in the middle.

The sizes of the slice being removed start at `n` (with `n` the length
of the list) and then `n / 2`, then `n / 4`, etc down to 1. The slices
will be taken at index `0`, `n / k`, `2n / k`, `3n / k`, etc.
-/
protected def shrink_perm {α : Type} [DecidableEq α] [SizeOf α] :
    shrink_fn (psigma fun (xs : List α) => psigma fun (ys : List α) => xs ~ ys ∧ list.nodup ys) :=
  sorry

protected instance has_sizeof {α : Type u_1} [SizeOf α] : SizeOf (injective_function α) :=
  { sizeOf := fun (_x : injective_function α) => sorry }

/--
Shrink an injective function slicing a segment in the middle of the domain and removing
the corresponding elements in the codomain, hence maintaining the property that
one is a permutation of the other.
-/
protected def shrink {α : Type} [SizeOf α] [DecidableEq α] : shrink_fn (injective_function α) :=
  sorry

/-- Create an injective function from one list and a permutation of that list. -/
protected def mk {α : Type (max u_1 u_2)} (xs : List α) (ys : List α) (h : xs ~ ys)
    (h' : list.nodup ys) : injective_function α :=
  (fun (h₀ : list.length xs ≤ list.length ys) =>
      (fun (h₁ : list.length ys ≤ list.length xs) =>
          map_to_self (total_function.list.to_finmap' (list.zip xs ys)) sorry sorry)
        sorry)
    sorry

protected theorem injective {α : Type u} [DecidableEq α] (f : injective_function α) :
    function.injective (apply f) :=
  sorry

protected instance pi_injective.sampleable_ext :
    sampleable_ext (Subtype fun (f : ℤ → ℤ) => function.injective f) :=
  sampleable_ext.mk (injective_function ℤ)
    (gen.sized
      fun (sz : ℕ) =>
        let xs' : List ℤ := int.range (-(bit0 1 * ↑sz + bit0 1)) (bit0 1 * ↑sz + bit0 1);
        do 
          let ys ← gen.permutation_of xs'
          (fun (Hinj : function.injective fun (r : ℕ) => -(bit0 1 * ↑sz + bit0 1) + ↑r) =>
                let r : injective_function ℤ :=
                  injective_function.mk xs' (subtype.val ys) sorry sorry;
                pure r)
              sorry)
    injective_function.shrink

end injective_function


protected instance injective.testable {α : Sort u_1} {β : Sort u_2} (f : α → β)
    [I :
      testable
        (named_binder
          (string.str string.empty (char.of_nat (bit0 (bit0 (bit0 (bit1 (bit1 (bit1 1))))))))
          (∀ (x : α),
            named_binder
              (string.str string.empty (char.of_nat (bit1 (bit0 (bit0 (bit1 (bit1 (bit1 1))))))))
              (∀ (y : α),
                named_binder
                  (string.str string.empty
                    (char.of_nat (bit0 (bit0 (bit0 (bit1 (bit0 (bit0 1))))))))
                  (f x = f y → x = y))))] :
    testable (function.injective f) :=
  I

protected instance monotone.testable {α : Type u_1} {β : Type u_2} [preorder α] [preorder β]
    (f : α → β)
    [I :
      testable
        (named_binder
          (string.str string.empty (char.of_nat (bit0 (bit0 (bit0 (bit1 (bit1 (bit1 1))))))))
          (∀ (x : α),
            named_binder
              (string.str string.empty (char.of_nat (bit1 (bit0 (bit0 (bit1 (bit1 (bit1 1))))))))
              (∀ (y : α),
                named_binder
                  (string.str string.empty
                    (char.of_nat (bit0 (bit0 (bit0 (bit1 (bit0 (bit0 1))))))))
                  (x ≤ y → f x ≤ f y))))] :
    testable (monotone f) :=
  I

end Mathlib