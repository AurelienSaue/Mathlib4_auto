/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta
-/
import PrePort
import Lean3Lib.init.default
import Mathlib.category_theory.sites.pretopology
import Mathlib.category_theory.limits.shapes.types
import Mathlib.category_theory.full_subcategory
import PostPort

universes v u 

namespace Mathlib

/-!
# Sheaves of types on a Grothendieck topology

Defines the notion of a sheaf of types (usually called a sheaf of sets by mathematicians)
on a category equipped with a Grothendieck topology, as well as a range of equivalent
conditions useful in different situations.

First define what it means for a presheaf `P : Cáµ’áµ– â¥¤ Type v` to be a sheaf *for* a particular
presieve `R` on `X`:
* A *family of elements* `x` for `P` at `R` is an element `x_f` of `P Y` for every `f : Y âŸ¶ X` in
  `R`. See `family_of_elements`.
* The family `x` is *compatible* if, for any `fâ‚ : Yâ‚ âŸ¶ X` and `fâ‚‚ : Yâ‚‚ âŸ¶ X` both in `R`,
  and any `gâ‚ : Z âŸ¶ Yâ‚` and `gâ‚‚ : Z âŸ¶ Yâ‚‚` such that `gâ‚ â‰« fâ‚ = gâ‚‚ â‰« fâ‚‚`, the restriction of
  `x_fâ‚` along `gâ‚` agrees with the restriction of `x_fâ‚‚` along `gâ‚‚`.
  See `family_of_elements.compatible`.
* An *amalgamation* `t` for the family is an element of `P X` such that for every `f : Y âŸ¶ X` in
  `R`, the restriction of `t` on `f` is `x_f`.
  See `family_of_elements.is_amalgamation`.
We then say `P` is *separated* for `R` if every compatible family has at most one amalgamation,
and it is a *sheaf* for `R` if every compatible family has a unique amalgamation.
See `is_separated_for` and `is_sheaf_for`.

In the special case where `R` is a sieve, the compatibility condition can be simplified:
* The family `x` is *compatible* if, for any `f : Y âŸ¶ X` in `R` and `g : Z âŸ¶ Y`, the restriction of
  `x_f` along `g` agrees with `x_(g â‰« f)` (which is well defined since `g â‰« f` is in `R`).
See `family_of_elements.sieve_compatible` and `compatible_iff_sieve_compatible`.

In the special case where `C` has pullbacks, the compatibility condition can be simplified:
* The family `x` is *compatible* if, for any `f : Y âŸ¶ X` and `g : Z âŸ¶ X` both in `R`,
  the restriction of `x_f` along `Ï€â‚ : pullback f g âŸ¶ Y` agrees with the restriction of `x_g`
  along `Ï€â‚‚ : pullback f g âŸ¶ Z`.
See `family_of_elements.pullback_compatible` and `pullback_compatible_iff`.

Now given a Grothendieck topology `J`, `P` is a sheaf if it is a sheaf for every sieve in the
topology. See `is_sheaf`.

In the case where the topology is generated by a basis, it suffices to check `P` is a sheaf for
every sieve in the pretopology. See `is_sheaf_pretopology`.

We also provide equivalent conditions to satisfy alternate definitions given in the literature.

* Stacks: In `equalizer.presieve.sheaf_condition`, the sheaf condition at a presieve is shown to be
  equivalent to that of https://stacks.math.columbia.edu/tag/00VM (and combined with
  `is_sheaf_pretopology`, this shows the notions of `is_sheaf` are exactly equivalent.)

  The condition of https://stacks.math.columbia.edu/tag/00Z8 is virtually identical to the
  statement of `yoneda_condition_iff_sheaf_condition` (since the bijection described there carries
  the same information as the unique existence.)

* Maclane-Moerdijk [MM92]: Using `compatible_iff_sieve_compatible`, the definitions of `is_sheaf`
  are equivalent. There are also alternate definitions given:
  - Yoneda condition: Defined in `yoneda_sheaf_condition` and equivalence in
    `yoneda_condition_iff_sheaf_condition`.
  - Equalizer condition (Equation 3): Defined in the `equalizer.sieve` namespace, and equivalence
    in `equalizer.sieve.sheaf_condition`.
  - Matching family for presieves with pullback: `pullback_compatible_iff`.
  - Sheaf for a pretopology (Prop 1): `is_sheaf_pretopology` combined with the previous.
  - Sheaf for a pretopology as equalizer (Prop 1, bis): `equalizer.presieve.sheaf_condition`
    combined with the previous.

## Implementation

The sheaf condition is given as a proposition, rather than a subsingleton in `Type (max u v)`.
This doesn't seem to make a big difference, other than making a couple of definitions noncomputable,
but it means that equivalent conditions can be given as `â†”` statements rather than `â‰ƒ` statements,
which can be convenient.

## References

* [MM92]: *Sheaves in geometry and logic*, Saunders MacLane, and Ieke Moerdijk:
  Chapter III, Section 4.
* [Elephant]: *Sketches of an Elephant*, P. T. Johnstone: C2.1.
* https://stacks.math.columbia.edu/tag/00VL (sheaves on a pretopology or site)
* https://stacks.math.columbia.edu/tag/00ZB (sheaves on a topology)

-/

namespace category_theory


namespace presieve


/--
A family of elements for a presheaf `P` given a collection of arrows `R` with fixed codomain `X`
consists of an element of `P Y` for every `f : Y âŸ¶ X` in `R`.
A presheaf is a sheaf (resp, separated) if every *compatible* family of elements has exactly one
(resp, at most one) amalgamation.

This data is referred to as a `family` in [MM92], Chapter III, Section 4. It is also a concrete
version of the elements of the middle object in https://stacks.math.columbia.edu/tag/00VM which is
more useful for direct calculations. It is also used implicitly in Definition C2.1.2 in [Elephant].
-/
def family_of_elements {C : Type u} [category C] {X : C} (P : Cáµ’áµ– â¥¤ Type v) (R : presieve X)  :=
  {Y : C} â†’ (f : Y âŸ¶ X) â†’ R f â†’ functor.obj P (opposite.op Y)

protected instance family_of_elements.inhabited {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} : Inhabited (family_of_elements P âŠ¥) :=
  { default := fun (Y : C) (f : Y âŸ¶ X) => false.elim }

/--
A family of elements for a presheaf on the presieve `Râ‚‚` can be restricted to a smaller presieve
`Râ‚`.
-/
def family_of_elements.restrict {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {Râ‚ : presieve X} {Râ‚‚ : presieve X} (h : Râ‚ â‰¤ Râ‚‚) : family_of_elements P Râ‚‚ â†’ family_of_elements P Râ‚ :=
  fun (x : family_of_elements P Râ‚‚) (Y : C) (f : Y âŸ¶ X) (hf : Râ‚ f) => x f (h Y hf)

/--
A family of elements for the arrow set `R` is *compatible* if for any `fâ‚ : Yâ‚ âŸ¶ X` and
`fâ‚‚ : Yâ‚‚ âŸ¶ X` in `R`, and any `gâ‚ : Z âŸ¶ Yâ‚` and `gâ‚‚ : Z âŸ¶ Yâ‚‚`, if the square `gâ‚ â‰« fâ‚ = gâ‚‚ â‰« fâ‚‚`
commutes then the elements of `P Z` obtained by restricting the element of `P Yâ‚` along `gâ‚` and
restricting the element of `P Yâ‚‚` along `gâ‚‚` are the same.

In special cases, this condition can be simplified, see `pullback_compatible_iff` and
`compatible_iff_sieve_compatible`.

This is referred to as a "compatible family" in Definition C2.1.2 of [Elephant], and on nlab:
https://ncatlab.org/nlab/show/sheaf#GeneralDefinitionInComponents
-/
def family_of_elements.compatible {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} (x : family_of_elements P R)  :=
  âˆ€ {Yâ‚ Yâ‚‚ Z : C} (gâ‚ : Z âŸ¶ Yâ‚) (gâ‚‚ : Z âŸ¶ Yâ‚‚) {fâ‚ : Yâ‚ âŸ¶ X} {fâ‚‚ : Yâ‚‚ âŸ¶ X} (hâ‚ : R fâ‚) (hâ‚‚ : R fâ‚‚),
    gâ‚ â‰« fâ‚ = gâ‚‚ â‰« fâ‚‚ â†’ functor.map P (has_hom.hom.op gâ‚) (x fâ‚ hâ‚) = functor.map P (has_hom.hom.op gâ‚‚) (x fâ‚‚ hâ‚‚)

/--
If the category `C` has pullbacks, this is an alternative condition for a family of elements to be
compatible: For any `f : Y âŸ¶ X` and `g : Z âŸ¶ X` in the presieve `R`, the restriction of the
given elements for `f` and `g` to the pullback agree.
This is equivalent to being compatible (provided `C` has pullbacks), shown in
`pullback_compatible_iff`.

This is the definition for a "matching" family given in [MM92], Chapter III, Section 4,
Equation (5). Viewing the type `family_of_elements` as the middle object of the fork in
https://stacks.math.columbia.edu/tag/00VM, this condition expresses that `prâ‚€* (x) = prâ‚* (x)`,
using the notation defined there.
-/
def family_of_elements.pullback_compatible {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} (x : family_of_elements P R) [limits.has_pullbacks C]  :=
  âˆ€ {Yâ‚ Yâ‚‚ : C} {fâ‚ : Yâ‚ âŸ¶ X} {fâ‚‚ : Yâ‚‚ âŸ¶ X} (hâ‚ : R fâ‚) (hâ‚‚ : R fâ‚‚),
    functor.map P (has_hom.hom.op limits.pullback.fst) (x fâ‚ hâ‚) =
      functor.map P (has_hom.hom.op limits.pullback.snd) (x fâ‚‚ hâ‚‚)

theorem pullback_compatible_iff {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} (x : family_of_elements P R) [limits.has_pullbacks C] : family_of_elements.compatible x â†” family_of_elements.pullback_compatible x := sorry

/-- The restriction of a compatible family is compatible. -/
theorem family_of_elements.compatible.restrict {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {Râ‚ : presieve X} {Râ‚‚ : presieve X} (h : Râ‚ â‰¤ Râ‚‚) {x : family_of_elements P Râ‚‚} : family_of_elements.compatible x â†’ family_of_elements.compatible (family_of_elements.restrict h x) :=
  fun (q : family_of_elements.compatible x) (Yâ‚ Yâ‚‚ Z : C) (gâ‚ : Z âŸ¶ Yâ‚) (gâ‚‚ : Z âŸ¶ Yâ‚‚) (fâ‚ : Yâ‚ âŸ¶ X) (fâ‚‚ : Yâ‚‚ âŸ¶ X)
    (hâ‚ : Râ‚ fâ‚) (hâ‚‚ : Râ‚ fâ‚‚) (comm : gâ‚ â‰« fâ‚ = gâ‚‚ â‰« fâ‚‚) => q gâ‚ gâ‚‚ (h Yâ‚ hâ‚) (h Yâ‚‚ hâ‚‚) comm

/--
Extend a family of elements to the sieve generated by an arrow set.
This is the construction described as "easy" in Lemma C2.1.3 of [Elephant].
-/
def family_of_elements.sieve_extend {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} (x : family_of_elements P R) : family_of_elements P â‡‘(sieve.generate R) :=
  fun (Z : C) (f : Z âŸ¶ X) (hf : coe_fn (sieve.generate R) Z f) =>
    functor.map P (has_hom.hom.op (classical.some sorry)) (x (classical.some sorry) sorry)

/-- The extension of a compatible family to the generated sieve is compatible. -/
theorem family_of_elements.compatible.sieve_extend {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} (x : family_of_elements P R) (hx : family_of_elements.compatible x) : family_of_elements.compatible (family_of_elements.sieve_extend x) := sorry

/-- The extension of a family agrees with the original family. -/
theorem extend_agrees {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {Y : C} {R : presieve X} {x : family_of_elements P R} (t : family_of_elements.compatible x) {f : Y âŸ¶ X} (hf : R f) : family_of_elements.sieve_extend x f
    (Exists.intro Y (Exists.intro ðŸ™ (Exists.intro f { left := hf, right := category.id_comp f }))) =
  x f hf := sorry

/-- The restriction of an extension is the original. -/
@[simp] theorem restrict_extend {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} {x : family_of_elements P R} (t : family_of_elements.compatible x) : family_of_elements.restrict (sieve.le_generate R) (family_of_elements.sieve_extend x) = x :=
  funext fun (Y : C) => funext fun (f : Y âŸ¶ X) => funext fun (hf : R f) => extend_agrees t hf

/--
If the arrow set for a family of elements is actually a sieve (i.e. it is downward closed) then the
consistency condition can be simplified.
This is an equivalent condition, see `compatible_iff_sieve_compatible`.

This is the notion of "matching" given for families on sieves given in [MM92], Chapter III,
Section 4, Equation 1, and nlab: https://ncatlab.org/nlab/show/matching+family.
See also the discussion before Lemma C2.1.4 of [Elephant].
-/
def family_of_elements.sieve_compatible {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {S : sieve X} (x : family_of_elements P â‡‘S)  :=
  âˆ€ {Y Z : C} (f : Y âŸ¶ X) (g : Z âŸ¶ Y) (hf : coe_fn S Y f),
    x (g â‰« f) (sieve.downward_closed S hf g) = functor.map P (has_hom.hom.op g) (x f hf)

theorem compatible_iff_sieve_compatible {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {S : sieve X} (x : family_of_elements P â‡‘S) : family_of_elements.compatible x â†” family_of_elements.sieve_compatible x := sorry

theorem family_of_elements.compatible.to_sieve_compatible {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {S : sieve X} {x : family_of_elements P â‡‘S} (t : family_of_elements.compatible x) : family_of_elements.sieve_compatible x :=
  iff.mp (compatible_iff_sieve_compatible x) t

/--
Two compatible families on the sieve generated by a presieve `R` are equal if and only if they are
equal when restricted to `R`.
-/
theorem restrict_inj {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} {xâ‚ : family_of_elements P â‡‘(sieve.generate R)} {xâ‚‚ : family_of_elements P â‡‘(sieve.generate R)} (tâ‚ : family_of_elements.compatible xâ‚) (tâ‚‚ : family_of_elements.compatible xâ‚‚) : family_of_elements.restrict (sieve.le_generate R) xâ‚ = family_of_elements.restrict (sieve.le_generate R) xâ‚‚ â†’ xâ‚ = xâ‚‚ := sorry

/--
Given a family of elements `x` for the sieve `S` generated by a presieve `R`, if `x` is restricted
to `R` and then extended back up to `S`, the resulting extension equals `x`.
-/
@[simp] theorem extend_restrict {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} {x : family_of_elements P â‡‘(sieve.generate R)} (t : family_of_elements.compatible x) : family_of_elements.sieve_extend (family_of_elements.restrict (sieve.le_generate R) x) = x := sorry

/--
The given element `t` of `P.obj (op X)` is an *amalgamation* for the family of elements `x` if every
restriction `P.map f.op t = x_f` for every arrow `f` in the presieve `R`.

This is the definition given in  https://ncatlab.org/nlab/show/sheaf#GeneralDefinitionInComponents,
and https://ncatlab.org/nlab/show/matching+family, as well as [MM92], Chapter III, Section 4,
equation (2).
-/
def family_of_elements.is_amalgamation {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} (x : family_of_elements P R) (t : functor.obj P (opposite.op X))  :=
  âˆ€ {Y : C} (f : Y âŸ¶ X) (h : R f), functor.map P (has_hom.hom.op f) t = x f h

theorem is_compatible_of_exists_amalgamation {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} (x : family_of_elements P R) (h : âˆƒ (t : functor.obj P (opposite.op X)), family_of_elements.is_amalgamation x t) : family_of_elements.compatible x := sorry

theorem is_amalgamation_restrict {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {Râ‚ : presieve X} {Râ‚‚ : presieve X} (h : Râ‚ â‰¤ Râ‚‚) (x : family_of_elements P Râ‚‚) (t : functor.obj P (opposite.op X)) (ht : family_of_elements.is_amalgamation x t) : family_of_elements.is_amalgamation (family_of_elements.restrict h x) t :=
  fun (Y : C) (f : Y âŸ¶ X) (hf : Râ‚ f) => ht f (h Y hf)

theorem is_amalgamation_sieve_extend {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} (x : family_of_elements P R) (t : functor.obj P (opposite.op X)) (ht : family_of_elements.is_amalgamation x t) : family_of_elements.is_amalgamation (family_of_elements.sieve_extend x) t := sorry

/-- A presheaf is separated for a presieve if there is at most one amalgamation. -/
def is_separated_for {C : Type u} [category C] {X : C} (P : Cáµ’áµ– â¥¤ Type v) (R : presieve X)  :=
  âˆ€ (x : family_of_elements P R) (tâ‚ tâ‚‚ : functor.obj P (opposite.op X)),
    family_of_elements.is_amalgamation x tâ‚ â†’ family_of_elements.is_amalgamation x tâ‚‚ â†’ tâ‚ = tâ‚‚

theorem is_separated_for.ext {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} (hR : is_separated_for P R) {tâ‚ : functor.obj P (opposite.op X)} {tâ‚‚ : functor.obj P (opposite.op X)} (h : âˆ€ {Y : C} {f : Y âŸ¶ X}, R f â†’ functor.map P (has_hom.hom.op f) tâ‚ = functor.map P (has_hom.hom.op f) tâ‚‚) : tâ‚ = tâ‚‚ :=
  hR (fun (Y : C) (f : Y âŸ¶ X) (hf : R f) => functor.map P (has_hom.hom.op f) tâ‚‚) tâ‚ tâ‚‚
    (fun (Y : C) (f : Y âŸ¶ X) (hf : R f) => h hf) fun (Y : C) (f : Y âŸ¶ X) (hf : R f) => rfl

theorem is_separated_for_iff_generate {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} : is_separated_for P R â†” is_separated_for P â‡‘(sieve.generate R) := sorry

theorem is_separated_for_top {C : Type u} [category C] {X : C} (P : Cáµ’áµ– â¥¤ Type v) : is_separated_for P âŠ¤ := sorry

/--
We define `P` to be a sheaf for the presieve `R` if every compatible family has a unique
amalgamation.

This is the definition of a sheaf for the given presieve given in C2.1.2 of [Elephant], and
https://ncatlab.org/nlab/show/sheaf#GeneralDefinitionInComponents. Using `compatible_iff_sieve_compatible`,
this is equivalent to the definition of a sheaf in [MM92], Chapter III, Section 4.
-/
def is_sheaf_for {C : Type u} [category C] {X : C} (P : Cáµ’áµ– â¥¤ Type v) (R : presieve X)  :=
  âˆ€ (x : family_of_elements P R),
    family_of_elements.compatible x â†’
      exists_unique fun (t : functor.obj P (opposite.op X)) => family_of_elements.is_amalgamation x t

/--
This is an equivalent condition to be a sheaf, which is useful for the abstraction to local
operators on elementary toposes. However this definition is defined only for sieves, not presieves.
The equivalence between this and `is_sheaf_for` is given in `yoneda_condition_iff_sheaf_condition`.
This version is also useful to establish that being a sheaf is preserved under isomorphism of
presheaves.

See the discussion before Equation (3) of [MM92], Chapter III, Section 4. See also C2.1.4 of
[Elephant]. This is also a direct reformulation of https://stacks.math.columbia.edu/tag/00Z8.
-/
def yoneda_sheaf_condition {C : Type u} [category C] {X : C} (P : Cáµ’áµ– â¥¤ Type v) (S : sieve X)  :=
  âˆ€ (f : sieve.functor S âŸ¶ P), exists_unique fun (g : functor.obj yoneda X âŸ¶ P) => sieve.functor_inclusion S â‰« g = f

/--
(Implementation). This is a (primarily internal) equivalence between natural transformations
and compatible families.

Cf the discussion after Lemma 7.47.10 in https://stacks.math.columbia.edu/tag/00YW. See also
the proof of C2.1.4 of [Elephant], and the discussion in [MM92], Chapter III, Section 4.
-/
def nat_trans_equiv_compatible_family {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {S : sieve X} : (sieve.functor S âŸ¶ P) â‰ƒ Subtype fun (x : family_of_elements P â‡‘S) => family_of_elements.compatible x :=
  equiv.mk
    (fun (Î± : sieve.functor S âŸ¶ P) =>
      { val :=
          fun (Y : C) (f : Y âŸ¶ X) (hf : coe_fn S Y f) => nat_trans.app Î± (opposite.op Y) { val := f, property := hf },
        property := sorry })
    (fun (t : Subtype fun (x : family_of_elements P â‡‘S) => family_of_elements.compatible x) =>
      nat_trans.mk
        fun (Y : Cáµ’áµ–) (f : functor.obj (sieve.functor S) Y) => subtype.val t (opposite.unop Y) (subtype.val f) sorry)
    sorry sorry

/-- (Implementation). A lemma useful to prove `yoneda_condition_iff_sheaf_condition`. -/
theorem extension_iff_amalgamation {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {S : sieve X} (x : sieve.functor S âŸ¶ P) (g : functor.obj yoneda X âŸ¶ P) : sieve.functor_inclusion S â‰« g = x â†”
  family_of_elements.is_amalgamation (subtype.val (coe_fn nat_trans_equiv_compatible_family x)) (coe_fn yoneda_equiv g) := sorry

/--
The yoneda version of the sheaf condition is equivalent to the sheaf condition.

C2.1.4 of [Elephant].
-/
theorem is_sheaf_for_iff_yoneda_sheaf_condition {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {S : sieve X} : is_sheaf_for P â‡‘S â†” yoneda_sheaf_condition P S := sorry

/--
If `P` is a sheaf for the sieve `S` on `X`, a natural transformation from `S` (viewed as a functor)
to `P` can be (uniquely) extended to all of `yoneda.obj X`.

      f
   S  â†’  P
   â†“  â†—
   yX

-/
def is_sheaf_for.extend {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {S : sieve X} (h : is_sheaf_for P â‡‘S) (f : sieve.functor S âŸ¶ P) : functor.obj yoneda X âŸ¶ P :=
  classical.some sorry

/--
Show that the extension of `f : S.functor âŸ¶ P` to all of `yoneda.obj X` is in fact an extension, ie
that the triangle below commutes, provided `P` is a sheaf for `S`

      f
   S  â†’  P
   â†“  â†—
   yX

-/
@[simp] theorem is_sheaf_for.functor_inclusion_comp_extend {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {S : sieve X} (h : is_sheaf_for P â‡‘S) (f : sieve.functor S âŸ¶ P) : sieve.functor_inclusion S â‰« is_sheaf_for.extend h f = f :=
  classical.some_spec (exists_unique.exists (iff.mp is_sheaf_for_iff_yoneda_sheaf_condition h f))

/-- The extension of `f` to `yoneda.obj X` is unique. -/
theorem is_sheaf_for.unique_extend {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {S : sieve X} (h : is_sheaf_for P â‡‘S) {f : sieve.functor S âŸ¶ P} (t : functor.obj yoneda X âŸ¶ P) (ht : sieve.functor_inclusion S â‰« t = f) : t = is_sheaf_for.extend h f :=
  exists_unique.unique (iff.mp is_sheaf_for_iff_yoneda_sheaf_condition h f) ht
    (is_sheaf_for.functor_inclusion_comp_extend h f)

/--
If `P` is a sheaf for the sieve `S` on `X`, then if two natural transformations from `yoneda.obj X`
to `P` agree when restricted to the subfunctor given by `S`, they are equal.
-/
theorem is_sheaf_for.hom_ext {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {S : sieve X} (h : is_sheaf_for P â‡‘S) (tâ‚ : functor.obj yoneda X âŸ¶ P) (tâ‚‚ : functor.obj yoneda X âŸ¶ P) (ht : sieve.functor_inclusion S â‰« tâ‚ = sieve.functor_inclusion S â‰« tâ‚‚) : tâ‚ = tâ‚‚ :=
  Eq.trans (is_sheaf_for.unique_extend h tâ‚ ht) (Eq.symm (is_sheaf_for.unique_extend h tâ‚‚ rfl))

/-- `P` is a sheaf for `R` iff it is separated for `R` and there exists an amalgamation. -/
theorem is_separated_for_and_exists_is_amalgamation_iff_sheaf_for {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} : (is_separated_for P R âˆ§
    âˆ€ (x : family_of_elements P R),
      family_of_elements.compatible x â†’ âˆƒ (t : functor.obj P (opposite.op X)), family_of_elements.is_amalgamation x t) â†”
  is_sheaf_for P R := sorry

/--
If `P` is separated for `R` and every family has an amalgamation, then `P` is a sheaf for `R`.
-/
theorem is_separated_for.is_sheaf_for {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} (t : is_separated_for P R) : (âˆ€ (x : family_of_elements P R),
    family_of_elements.compatible x â†’ âˆƒ (t : functor.obj P (opposite.op X)), family_of_elements.is_amalgamation x t) â†’
  is_sheaf_for P R := sorry

/-- If `P` is a sheaf for `R`, it is separated for `R`. -/
theorem is_sheaf_for.is_separated_for {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} : is_sheaf_for P R â†’ is_separated_for P R :=
  fun (q : is_sheaf_for P R) => and.left (iff.mpr is_separated_for_and_exists_is_amalgamation_iff_sheaf_for q)

/-- Get the amalgamation of the given compatible family, provided we have a sheaf. -/
def is_sheaf_for.amalgamate {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} (t : is_sheaf_for P R) (x : family_of_elements P R) (hx : family_of_elements.compatible x) : functor.obj P (opposite.op X) :=
  classical.some sorry

theorem is_sheaf_for.is_amalgamation {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} (t : is_sheaf_for P R) {x : family_of_elements P R} (hx : family_of_elements.compatible x) : family_of_elements.is_amalgamation x (is_sheaf_for.amalgamate t x hx) :=
  classical.some_spec (exists_unique.exists (t x hx))

@[simp] theorem is_sheaf_for.valid_glue {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {Y : C} {R : presieve X} (t : is_sheaf_for P R) {x : family_of_elements P R} (hx : family_of_elements.compatible x) (f : Y âŸ¶ X) (Hf : R f) : functor.map P (has_hom.hom.op f) (is_sheaf_for.amalgamate t x hx) = x f Hf :=
  is_sheaf_for.is_amalgamation t hx f Hf

/-- C2.1.3 in [Elephant] -/
theorem is_sheaf_for_iff_generate {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} (R : presieve X) : is_sheaf_for P R â†” is_sheaf_for P â‡‘(sieve.generate R) := sorry

/--
Every presheaf is a sheaf for the family {ðŸ™ X}.

[Elephant] C2.1.5(i)
-/
theorem is_sheaf_for_singleton_iso {C : Type u} [category C] {X : C} (P : Cáµ’áµ– â¥¤ Type v) : is_sheaf_for P (singleton ðŸ™) := sorry

/--
Every presheaf is a sheaf for the maximal sieve.

[Elephant] C2.1.5(ii)
-/
theorem is_sheaf_for_top_sieve {C : Type u} [category C] {X : C} (P : Cáµ’áµ– â¥¤ Type v) : is_sheaf_for P â‡‘âŠ¤ := sorry

/--
If `P` is a sheaf for `S`, and it is iso to `P'`, then `P'` is a sheaf for `S`. This shows that
"being a sheaf for a presieve" is a mathematical or hygenic property.
-/
theorem is_sheaf_for_iso {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} {X : C} {R : presieve X} {P' : Cáµ’áµ– â¥¤ Type v} (i : P â‰… P') : is_sheaf_for P R â†’ is_sheaf_for P' R := sorry

/--
If a presieve `R` on `X` has a subsieve `S` such that:

* `P` is a sheaf for `S`.
* For every `f` in `R`, `P` is separated for the pullback of `S` along `f`,

then `P` is a sheaf for `R`.

This is closely related to [Elephant] C2.1.6(i).
-/
theorem is_sheaf_for_subsieve_aux {C : Type u} [category C] {X : C} (P : Cáµ’áµ– â¥¤ Type v) {S : sieve X} {R : presieve X} (h : â‡‘S â‰¤ R) (hS : is_sheaf_for P â‡‘S) (trans : âˆ€ {Y : C} {f : Y âŸ¶ X}, R f â†’ is_separated_for P â‡‘(sieve.pullback f S)) : is_sheaf_for P R := sorry

/--
If `P` is a sheaf for every pullback of the sieve `S`, then `P` is a sheaf for any presieve which
contains `S`.
This is closely related to [Elephant] C2.1.6.
-/
theorem is_sheaf_for_subsieve {C : Type u} [category C] {X : C} (P : Cáµ’áµ– â¥¤ Type v) {S : sieve X} {R : presieve X} (h : â‡‘S â‰¤ R) (trans : âˆ€ {Y : C} (f : Y âŸ¶ X), is_sheaf_for P â‡‘(sieve.pullback f S)) : is_sheaf_for P R := sorry

/-- A presheaf is separated for a topology if it is separated for every sieve in the topology. -/
def is_separated {C : Type u} [category C] (J : grothendieck_topology C) (P : Cáµ’áµ– â¥¤ Type v)  :=
  âˆ€ {X : C} (S : sieve X), S âˆˆ coe_fn J X â†’ is_separated_for P â‡‘S

/--
A presheaf is a sheaf for a topology if it is a sheaf for every sieve in the topology.

If the given topology is given by a pretopology, `is_sheaf_for_pretopology` shows it suffices to
check the sheaf condition at presieves in the pretopology.
-/
def is_sheaf {C : Type u} [category C] (J : grothendieck_topology C) (P : Cáµ’áµ– â¥¤ Type v)  :=
  âˆ€ {X : C} (S : sieve X), S âˆˆ coe_fn J X â†’ is_sheaf_for P â‡‘S

theorem is_sheaf.is_sheaf_for {C : Type u} [category C] {X : C} (J : grothendieck_topology C) {P : Cáµ’áµ– â¥¤ Type v} (hp : is_sheaf J P) (R : presieve X) (hr : sieve.generate R âˆˆ coe_fn J X) : is_sheaf_for P R :=
  iff.mpr (is_sheaf_for_iff_generate R) (hp (sieve.generate R) hr)

theorem is_sheaf_of_le {C : Type u} [category C] (P : Cáµ’áµ– â¥¤ Type v) {Jâ‚ : grothendieck_topology C} {Jâ‚‚ : grothendieck_topology C} : Jâ‚ â‰¤ Jâ‚‚ â†’ is_sheaf Jâ‚‚ P â†’ is_sheaf Jâ‚ P :=
  fun (h : Jâ‚ â‰¤ Jâ‚‚) (t : is_sheaf Jâ‚‚ P) (X : C) (S : sieve X) (hS : S âˆˆ coe_fn Jâ‚ X) => t S (h X hS)

theorem is_separated_of_is_sheaf {C : Type u} [category C] (J : grothendieck_topology C) (P : Cáµ’áµ– â¥¤ Type v) (h : is_sheaf J P) : is_separated J P :=
  fun (X : C) (S : sieve X) (hS : S âˆˆ coe_fn J X) => is_sheaf_for.is_separated_for (h S hS)

/-- The property of being a sheaf is preserved by isomorphism. -/
theorem is_sheaf_iso {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} (J : grothendieck_topology C) {P' : Cáµ’áµ– â¥¤ Type v} (i : P â‰… P') (h : is_sheaf J P) : is_sheaf J P' :=
  fun (X : C) (S : sieve X) (hS : S âˆˆ coe_fn J X) => is_sheaf_for_iso i (h S hS)

theorem is_sheaf_of_yoneda {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} (J : grothendieck_topology C) (h : âˆ€ {X : C} (S : sieve X), S âˆˆ coe_fn J X â†’ yoneda_sheaf_condition P S) : is_sheaf J P :=
  fun (X : C) (S : sieve X) (hS : S âˆˆ coe_fn J X) => iff.mpr is_sheaf_for_iff_yoneda_sheaf_condition (h S hS)

/--
For a topology generated by a basis, it suffices to check the sheaf condition on the basis
presieves only.
-/
theorem is_sheaf_pretopology {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} [limits.has_pullbacks C] (K : pretopology C) : is_sheaf (pretopology.to_grothendieck C K) P â†” âˆ€ {X : C} (R : presieve X), R âˆˆ coe_fn K X â†’ is_sheaf_for P R := sorry

/-- Any presheaf is a sheaf for the bottom (trivial) grothendieck topology. -/
theorem is_sheaf_bot {C : Type u} [category C] {P : Cáµ’áµ– â¥¤ Type v} : is_sheaf âŠ¥ P := sorry

end presieve


namespace equalizer


/--
The middle object of the fork diagram given in Equation (3) of [MM92], as well as the fork diagram
of https://stacks.math.columbia.edu/tag/00VM.
-/
def first_obj {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} (R : presieve X)  :=
  âˆ fun (f : sigma fun (Y : C) => Subtype fun (f : Y âŸ¶ X) => R f) => functor.obj P (opposite.op (sigma.fst f))

/-- Show that `first_obj` is isomorphic to `family_of_elements`. -/
def first_obj_eq_family {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} (R : presieve X) : first_obj P R â‰… presieve.family_of_elements P R :=
  iso.mk
    (fun (t : first_obj P R) (Y : C) (f : Y âŸ¶ X) (hf : R f) =>
      limits.pi.Ï€
        (fun (f : sigma fun (Y : C) => Subtype fun (f : Y âŸ¶ X) => R f) => functor.obj P (opposite.op (sigma.fst f)))
        (sigma.mk Y { val := f, property := hf }) t)
    (limits.pi.lift
      fun (f : sigma fun (Y : C) => Subtype fun (f : Y âŸ¶ X) => R f) (x : presieve.family_of_elements P R) =>
        x (subtype.val (sigma.snd f)) sorry)

protected instance first_obj.inhabited {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} : Inhabited (first_obj P âŠ¥) :=
  equiv.inhabited (iso.to_equiv (first_obj_eq_family P âŠ¥))

/--
The left morphism of the fork diagram given in Equation (3) of [MM92], as well as the fork diagram
of https://stacks.math.columbia.edu/tag/00VM.
-/
def fork_map {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} (R : presieve X) : functor.obj P (opposite.op X) âŸ¶ first_obj P R :=
  limits.pi.lift
    fun (f : sigma fun (Y : C) => Subtype fun (f : Y âŸ¶ X) => R f) =>
      functor.map P (has_hom.hom.op (subtype.val (sigma.snd f)))

/-!
This section establishes the equivalence between the sheaf condition of Equation (3) [MM92] and
the definition of `is_sheaf_for`.
-/

namespace sieve


/--
The rightmost object of the fork diagram of Equation (3) [MM92], which contains the data used
to check a family is compatible.
-/
def second_obj {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} (S : sieve X)  :=
  âˆ
    fun
      (f :
      sigma fun (Y : C) => sigma fun (Z : C) => sigma fun (g : Z âŸ¶ Y) => Subtype fun (f' : Y âŸ¶ X) => coe_fn S Y f') =>
      functor.obj P (opposite.op (sigma.fst (sigma.snd f)))

/-- The map `p` of Equations (3,4) [MM92]. -/
def first_map {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} (S : sieve X) : first_obj P â‡‘S âŸ¶ second_obj P S :=
  limits.pi.lift
    fun
      (fg :
      sigma fun (Y : C) => sigma fun (Z : C) => sigma fun (g : Z âŸ¶ Y) => Subtype fun (f' : Y âŸ¶ X) => coe_fn S Y f') =>
      limits.pi.Ï€
        (fun (f : sigma fun (Y : C) => Subtype fun (f : Y âŸ¶ X) => coe_fn S Y f) =>
          functor.obj P (opposite.op (sigma.fst f)))
        (sigma.mk (sigma.fst (sigma.snd fg))
          { val := sigma.fst (sigma.snd (sigma.snd fg)) â‰« subtype.val (sigma.snd (sigma.snd (sigma.snd fg))),
            property := sorry })

protected instance second_obj.inhabited {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} : Inhabited (second_obj P âŠ¥) :=
  { default := first_map P âŠ¥ Inhabited.default }

/-- The map `a` of Equations (3,4) [MM92]. -/
def second_map {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} (S : sieve X) : first_obj P â‡‘S âŸ¶ second_obj P S :=
  limits.pi.lift
    fun
      (fg :
      sigma fun (Y : C) => sigma fun (Z : C) => sigma fun (g : Z âŸ¶ Y) => Subtype fun (f' : Y âŸ¶ X) => coe_fn S Y f') =>
      limits.pi.Ï€
          (fun (f : sigma fun (Y : C) => Subtype fun (f : Y âŸ¶ X) => coe_fn S Y f) =>
            functor.obj P (opposite.op (sigma.fst f)))
          (sigma.mk (sigma.fst fg) (sigma.snd (sigma.snd (sigma.snd fg)))) â‰«
        functor.map P (has_hom.hom.op (sigma.fst (sigma.snd (sigma.snd fg))))

theorem w {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} (S : sieve X) : fork_map P â‡‘S â‰« first_map P S = fork_map P â‡‘S â‰« second_map P S := sorry

/--
The family of elements given by `x : first_obj P S` is compatible iff `first_map` and `second_map`
map it to the same point.
-/
theorem compatible_iff {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} (S : sieve X) (x : first_obj P â‡‘S) : presieve.family_of_elements.compatible (iso.hom (first_obj_eq_family P â‡‘S) x) â†” first_map P S x = second_map P S x := sorry

/-- `P` is a sheaf for `S`, iff the fork given by `w` is an equalizer. -/
theorem equalizer_sheaf_condition {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} (S : sieve X) : presieve.is_sheaf_for P â‡‘S â†” Nonempty (limits.is_limit (limits.fork.of_Î¹ (fork_map P â‡‘S) (w P S))) := sorry

end sieve


/-!
This section establishes the equivalence between the sheaf condition of
https://stacks.math.columbia.edu/tag/00VM and the definition of `is_sheaf_for`.
-/

namespace presieve


/--
The rightmost object of the fork diagram of https://stacks.math.columbia.edu/tag/00VM, which
contains the data used to check a family of elements for a presieve is compatible.
-/
def second_obj {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} (R : presieve X) [limits.has_pullbacks C]  :=
  âˆ
    fun
      (fg :
      (sigma fun (Y : C) => Subtype fun (f : Y âŸ¶ X) => R f) Ã— sigma fun (Y : C) => Subtype fun (f : Y âŸ¶ X) => R f) =>
      functor.obj P
        (opposite.op (limits.pullback (subtype.val (sigma.snd (prod.fst fg))) (subtype.val (sigma.snd (prod.snd fg)))))

/-- The map `prâ‚€*` of https://stacks.math.columbia.edu/tag/00VL. -/
def first_map {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} (R : presieve X) [limits.has_pullbacks C] : first_obj P R âŸ¶ second_obj P R :=
  limits.pi.lift
    fun
      (fg :
      (sigma fun (Y : C) => Subtype fun (f : Y âŸ¶ X) => R f) Ã— sigma fun (Y : C) => Subtype fun (f : Y âŸ¶ X) => R f) =>
      limits.pi.Ï€
          (fun (f : sigma fun (Y : C) => Subtype fun (f : Y âŸ¶ X) => R f) => functor.obj P (opposite.op (sigma.fst f)))
          (prod.fst fg) â‰«
        functor.map P (has_hom.hom.op limits.pullback.fst)

protected instance second_obj.inhabited {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} [limits.has_pullbacks C] : Inhabited (second_obj P âŠ¥) :=
  { default := first_map P âŠ¥ Inhabited.default }

/-- The map `prâ‚*` of https://stacks.math.columbia.edu/tag/00VL. -/
def second_map {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} (R : presieve X) [limits.has_pullbacks C] : first_obj P R âŸ¶ second_obj P R :=
  limits.pi.lift
    fun
      (fg :
      (sigma fun (Y : C) => Subtype fun (f : Y âŸ¶ X) => R f) Ã— sigma fun (Y : C) => Subtype fun (f : Y âŸ¶ X) => R f) =>
      limits.pi.Ï€
          (fun (f : sigma fun (Y : C) => Subtype fun (f : Y âŸ¶ X) => R f) => functor.obj P (opposite.op (sigma.fst f)))
          (prod.snd fg) â‰«
        functor.map P (has_hom.hom.op limits.pullback.snd)

theorem w {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} (R : presieve X) [limits.has_pullbacks C] : fork_map P R â‰« first_map P R = fork_map P R â‰« second_map P R := sorry

/--
The family of elements given by `x : first_obj P S` is compatible iff `first_map` and `second_map`
map it to the same point.
-/
theorem compatible_iff {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} (R : presieve X) [limits.has_pullbacks C] (x : first_obj P R) : presieve.family_of_elements.compatible (iso.hom (first_obj_eq_family P R) x) â†” first_map P R x = second_map P R x := sorry

/--
`P` is a sheaf for `R`, iff the fork given by `w` is an equalizer.
See https://stacks.math.columbia.edu/tag/00VM.
-/
theorem sheaf_condition {C : Type v} [small_category C] (P : Cáµ’áµ– â¥¤ Type v) {X : C} (R : presieve X) [limits.has_pullbacks C] : presieve.is_sheaf_for P R â†” Nonempty (limits.is_limit (limits.fork.of_Î¹ (fork_map P R) (w P R))) := sorry

end presieve


end equalizer


/-- The category of sheaves on a grothendieck topology. -/
def SheafOfTypes {C : Type u} [category C] (J : grothendieck_topology C)  :=
  Subtype fun (P : Cáµ’áµ– â¥¤ Type v) => presieve.is_sheaf J P

/-- The inclusion functor from sheaves to presheaves. -/
@[simp] theorem SheafOfTypes_to_presheaf_obj {C : Type u} [category C] (J : grothendieck_topology C) (c : Subtype fun (X : Cáµ’áµ– â¥¤ Type v) => presieve.is_sheaf J X) : functor.obj (SheafOfTypes_to_presheaf J) c = â†‘c :=
  Eq.refl â†‘c

/--
The category of sheaves on the bottom (trivial) grothendieck topology is equivalent to the category
of presheaves.
-/
@[simp] theorem SheafOfTypes_bot_equiv_functor {C : Type u} [category C] : equivalence.functor SheafOfTypes_bot_equiv = SheafOfTypes_to_presheaf âŠ¥ :=
  Eq.refl (equivalence.functor SheafOfTypes_bot_equiv)

protected instance SheafOfTypes.inhabited {C : Type u} [category C] : Inhabited (SheafOfTypes âŠ¥) :=
  { default := functor.obj (equivalence.inverse SheafOfTypes_bot_equiv) (functor.obj (functor.const (Cáµ’áµ–)) PUnit) }

