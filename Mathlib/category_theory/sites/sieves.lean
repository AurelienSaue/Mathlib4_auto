/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta, E. W. Ayers
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.category_theory.over
import Mathlib.category_theory.limits.shapes.finite_limits
import Mathlib.category_theory.yoneda
import Mathlib.order.complete_lattice
import Mathlib.data.set.lattice
import Mathlib.PostPort

universes v u l 

namespace Mathlib

/-!
# Theory of sieves

- For an object `X` of a category `C`, a `sieve X` is a set of morphisms to `X`
  which is closed under left-composition.
- The complete lattice structure on sieves is given, as well as the Galois insertion
  given by downward-closing.
- A `sieve X` (functorially) induces a presheaf on `C` together with a monomorphism to
  the yoneda embedding of `X`.

## Tags

sieve, pullback
-/

namespace category_theory


/-- A set of arrows all with codomain `X`. -/
def presieve {C : Type u} [category C] (X : C) :=
  {Y : C} ‚Üí set (Y ‚ü∂ X)

namespace presieve


protected instance inhabited {C : Type u} [category C] {X : C} : Inhabited (presieve X) :=
  { default := ‚ä§ }

/--
Given a set of arrows `S` all with codomain `X`, and a set of arrows with codomain `Y` for each
`f : Y ‚ü∂ X` in `S`, produce a set of arrows with codomain `X`:
`{ g ‚â´ f | (f : Y ‚ü∂ X) ‚àà S, (g : Z ‚ü∂ Y) ‚àà R f }`.
-/
def bind {C : Type u} [category C] {X : C} (S : presieve X) (R : {Y : C} ‚Üí {f : Y ‚ü∂ X} ‚Üí S f ‚Üí presieve Y) : presieve X :=
  fun (Z : C) (h : Z ‚ü∂ X) => ‚àÉ (Y : C), ‚àÉ (g : Z ‚ü∂ Y), ‚àÉ (f : Y ‚ü∂ X), ‚àÉ (H : S f), R H g ‚àß g ‚â´ f = h

@[simp] theorem bind_comp {C : Type u} [category C] {X : C} {Y : C} {Z : C} (f : Y ‚ü∂ X) {S : presieve X} {R : {Y : C} ‚Üí {f : Y ‚ü∂ X} ‚Üí S f ‚Üí presieve Y} {g : Z ‚ü∂ Y} (h‚ÇÅ : S f) (h‚ÇÇ : R h‚ÇÅ g) : bind S R (g ‚â´ f) :=
  Exists.intro Y (Exists.intro g (Exists.intro f (Exists.intro h‚ÇÅ { left := h‚ÇÇ, right := rfl })))

/-- The singleton presieve.  -/
-- Note we can't make this into `has_singleton` because of the out-param.

structure singleton {C : Type u} [category C] {X : C} {Y : C} (f : Y ‚ü∂ X) : presieve X
where

@[simp] theorem singleton_eq_iff_domain {C : Type u} [category C] {X : C} {Y : C} (f : Y ‚ü∂ X) (g : Y ‚ü∂ X) : singleton f g ‚Üî f = g := sorry

theorem singleton_self {C : Type u} [category C] {X : C} {Y : C} (f : Y ‚ü∂ X) : singleton f f :=
  singleton.mk

end presieve


/--
For an object `X` of a category `C`, a `sieve X` is a set of morphisms to `X` which is closed under
left-composition.
-/
structure sieve {C : Type u} [category C] (X : C) 
where
  arrows : presieve X
  downward_closed' : ‚àÄ {Y Z : C} {f : Y ‚ü∂ X}, arrows f ‚Üí ‚àÄ (g : Z ‚ü∂ Y), arrows (g ‚â´ f)

namespace sieve


protected instance has_coe_to_fun {C : Type u} [category C] {X : C} : has_coe_to_fun (sieve X) :=
  has_coe_to_fun.mk (fun (x : sieve X) => presieve X) arrows

@[simp] theorem downward_closed {C : Type u} [category C] {X : C} {Y : C} {Z : C} (S : sieve X) {f : Y ‚ü∂ X} (hf : coe_fn S Y f) (g : Z ‚ü∂ Y) : coe_fn S Z (g ‚â´ f) :=
  downward_closed' S hf g

theorem arrows_ext {C : Type u} [category C] {X : C} {R : sieve X} {S : sieve X} : arrows R = arrows S ‚Üí R = S := sorry

protected theorem ext {C : Type u} [category C] {X : C} {R : sieve X} {S : sieve X} (h : ‚àÄ {Y : C} (f : Y ‚ü∂ X), coe_fn R Y f ‚Üî coe_fn S Y f) : R = S :=
  arrows_ext (funext fun (x : C) => funext fun (f : x ‚ü∂ X) => propext (h f))

protected theorem ext_iff {C : Type u} [category C] {X : C} {R : sieve X} {S : sieve X} : R = S ‚Üî ‚àÄ {Y : C} (f : Y ‚ü∂ X), coe_fn R Y f ‚Üî coe_fn S Y f :=
  { mp := fun (h : R = S) (Y : C) (f : Y ‚ü∂ X) => h ‚ñ∏ iff.rfl, mpr := sieve.ext }

/-- The supremum of a collection of sieves: the union of them all. -/
protected def Sup {C : Type u} [category C] {X : C} (ùíÆ : set (sieve X)) : sieve X :=
  mk (fun (Y : C) => set_of fun (f : Y ‚ü∂ X) => ‚àÉ (S : sieve X), ‚àÉ (H : S ‚àà ùíÆ), arrows S f) sorry

/-- The infimum of a collection of sieves: the intersection of them all. -/
protected def Inf {C : Type u} [category C] {X : C} (ùíÆ : set (sieve X)) : sieve X :=
  mk (fun (Y : C) => set_of fun (f : Y ‚ü∂ X) => ‚àÄ (S : sieve X), S ‚àà ùíÆ ‚Üí arrows S f) sorry

/-- The union of two sieves is a sieve. -/
protected def union {C : Type u} [category C] {X : C} (S : sieve X) (R : sieve X) : sieve X :=
  mk (fun (Y : C) (f : Y ‚ü∂ X) => coe_fn S Y f ‚à® coe_fn R Y f) sorry

/-- The intersection of two sieves is a sieve. -/
protected def inter {C : Type u} [category C] {X : C} (S : sieve X) (R : sieve X) : sieve X :=
  mk (fun (Y : C) (f : Y ‚ü∂ X) => coe_fn S Y f ‚àß coe_fn R Y f) sorry

/--
Sieves on an object `X` form a complete lattice.
We generate this directly rather than using the galois insertion for nicer definitional properties.
-/
protected instance complete_lattice {C : Type u} [category C] {X : C} : complete_lattice (sieve X) :=
  complete_lattice.mk sieve.union (fun (S R : sieve X) => ‚àÄ {Y : C} (f : Y ‚ü∂ X), coe_fn S Y f ‚Üí coe_fn R Y f)
    (bounded_lattice.lt._default fun (S R : sieve X) => ‚àÄ {Y : C} (f : Y ‚ü∂ X), coe_fn S Y f ‚Üí coe_fn R Y f) sorry sorry
    sorry sorry sorry sorry sieve.inter sorry sorry sorry (mk (fun (_x : C) => set.univ) sorry) sorry
    (mk (fun (_x : C) => ‚àÖ) sorry) sorry sieve.Sup sieve.Inf sorry sorry sorry sorry

/-- The maximal sieve always exists. -/
protected instance sieve_inhabited {C : Type u} [category C] {X : C} : Inhabited (sieve X) :=
  { default := ‚ä§ }

@[simp] theorem Inf_apply {C : Type u} [category C] {X : C} {Ss : set (sieve X)} {Y : C} (f : Y ‚ü∂ X) : coe_fn (Inf Ss) Y f ‚Üî ‚àÄ (S : sieve X), S ‚àà Ss ‚Üí coe_fn S Y f :=
  iff.rfl

@[simp] theorem Sup_apply {C : Type u} [category C] {X : C} {Ss : set (sieve X)} {Y : C} (f : Y ‚ü∂ X) : coe_fn (Sup Ss) Y f ‚Üî ‚àÉ (S : sieve X), ‚àÉ (H : S ‚àà Ss), coe_fn S Y f :=
  iff.rfl

@[simp] theorem inter_apply {C : Type u} [category C] {X : C} {R : sieve X} {S : sieve X} {Y : C} (f : Y ‚ü∂ X) : coe_fn (R ‚äì S) Y f ‚Üî coe_fn R Y f ‚àß coe_fn S Y f :=
  iff.rfl

@[simp] theorem union_apply {C : Type u} [category C] {X : C} {R : sieve X} {S : sieve X} {Y : C} (f : Y ‚ü∂ X) : coe_fn (R ‚äî S) Y f ‚Üî coe_fn R Y f ‚à® coe_fn S Y f :=
  iff.rfl

@[simp] theorem top_apply {C : Type u} [category C] {X : C} {Y : C} (f : Y ‚ü∂ X) : coe_fn ‚ä§ Y f :=
  trivial

/-- Generate the smallest sieve containing the given set of arrows. -/
@[simp] theorem generate_apply {C : Type u} [category C] {X : C} (R : presieve X) (Z : C) (f : Z ‚ü∂ X) : coe_fn (generate R) Z f = ‚àÉ (Y : C), ‚àÉ (h : Z ‚ü∂ Y), ‚àÉ (g : Y ‚ü∂ X), R g ‚àß h ‚â´ g = f :=
  Eq.refl (coe_fn (generate R) Z f)

/--
Given a presieve on `X`, and a sieve on each domain of an arrow in the presieve, we can bind to
produce a sieve on `X`.
-/
@[simp] theorem bind_apply {C : Type u} [category C] {X : C} (S : presieve X) (R : {Y : C} ‚Üí {f : Y ‚ü∂ X} ‚Üí S f ‚Üí sieve Y) : ‚áë(bind S R) = presieve.bind S fun (Y : C) (f : Y ‚ü∂ X) (h : S f) => ‚áë(R h) :=
  Eq.refl ‚áë(bind S R)

theorem sets_iff_generate {C : Type u} [category C] {X : C} (R : presieve X) (S : sieve X) : generate R ‚â§ S ‚Üî R ‚â§ ‚áëS := sorry

/-- Show that there is a galois insertion (generate, set_over). -/
def gi_generate {C : Type u} [category C] {X : C} : galois_insertion generate arrows :=
  galois_insertion.mk (fun (ùí¢ : presieve X) (_x : arrows (generate ùí¢) ‚â§ ùí¢) => generate ùí¢) sets_iff_generate sorry sorry

theorem le_generate {C : Type u} [category C] {X : C} (R : presieve X) : R ‚â§ ‚áë(generate R) :=
  galois_connection.le_u_l (galois_insertion.gc gi_generate) R

/-- If the identity arrow is in a sieve, the sieve is maximal. -/
theorem id_mem_iff_eq_top {C : Type u} [category C] {X : C} {S : sieve X} : coe_fn S X ùüô ‚Üî S = ‚ä§ := sorry

/-- If an arrow set contains a split epi, it generates the maximal sieve. -/
theorem generate_of_contains_split_epi {C : Type u} [category C] {X : C} {Y : C} {R : presieve X} (f : Y ‚ü∂ X) [split_epi f] (hf : R f) : generate R = ‚ä§ := sorry

@[simp] theorem generate_of_singleton_split_epi {C : Type u} [category C] {X : C} {Y : C} (f : Y ‚ü∂ X) [split_epi f] : generate (presieve.singleton f) = ‚ä§ :=
  generate_of_contains_split_epi f (presieve.singleton_self f)

@[simp] theorem generate_top {C : Type u} [category C] {X : C} : generate ‚ä§ = ‚ä§ :=
  generate_of_contains_split_epi ùüô True.intro

/-- Given a morphism `h : Y ‚ü∂ X`, send a sieve S on X to a sieve on Y
    as the inverse image of S with `_ ‚â´ h`.
    That is, `sieve.pullback S h := (‚â´ h) '‚Åª¬π S`. -/
def pullback {C : Type u} [category C] {X : C} {Y : C} (h : Y ‚ü∂ X) (S : sieve X) : sieve Y :=
  mk (fun (Y_1 : C) (sl : Y_1 ‚ü∂ Y) => coe_fn S Y_1 (sl ‚â´ h)) sorry

@[simp] theorem pullback_id {C : Type u} [category C] {X : C} {S : sieve X} : pullback ùüô S = S := sorry

@[simp] theorem pullback_top {C : Type u} [category C] {X : C} {Y : C} {f : Y ‚ü∂ X} : pullback f ‚ä§ = ‚ä§ :=
  top_unique fun (_x : C) (g : _x ‚ü∂ Y) => id

theorem pullback_comp {C : Type u} [category C] {X : C} {Y : C} {Z : C} {f : Y ‚ü∂ X} {g : Z ‚ü∂ Y} (S : sieve X) : pullback (g ‚â´ f) S = pullback g (pullback f S) := sorry

@[simp] theorem pullback_inter {C : Type u} [category C] {X : C} {Y : C} {f : Y ‚ü∂ X} (S : sieve X) (R : sieve X) : pullback f (S ‚äì R) = pullback f S ‚äì pullback f R := sorry

theorem pullback_eq_top_iff_mem {C : Type u} [category C] {X : C} {Y : C} {S : sieve X} (f : Y ‚ü∂ X) : coe_fn S Y f ‚Üî pullback f S = ‚ä§ := sorry

theorem pullback_eq_top_of_mem {C : Type u} [category C] {X : C} {Y : C} (S : sieve X) {f : Y ‚ü∂ X} : coe_fn S Y f ‚Üí pullback f S = ‚ä§ :=
  iff.mp (pullback_eq_top_iff_mem f)

/--
Push a sieve `R` on `Y` forward along an arrow `f : Y ‚ü∂ X`: `gf : Z ‚ü∂ X` is in the sieve if `gf`
factors through some `g : Z ‚ü∂ Y` which is in `R`.
-/
@[simp] theorem pushforward_apply {C : Type u} [category C] {X : C} {Y : C} (f : Y ‚ü∂ X) (R : sieve Y) (Z : C) (gf : Z ‚ü∂ X) : coe_fn (pushforward f R) Z gf = ‚àÉ (g : Z ‚ü∂ Y), g ‚â´ f = gf ‚àß coe_fn R Z g :=
  Eq.refl (coe_fn (pushforward f R) Z gf)

theorem pushforward_apply_comp {C : Type u} [category C] {X : C} {Y : C} {R : sieve Y} {Z : C} {g : Z ‚ü∂ Y} (hg : coe_fn R Z g) (f : Y ‚ü∂ X) : coe_fn (pushforward f R) Z (g ‚â´ f) :=
  Exists.intro g { left := rfl, right := hg }

theorem pushforward_comp {C : Type u} [category C] {X : C} {Y : C} {Z : C} {f : Y ‚ü∂ X} {g : Z ‚ü∂ Y} (R : sieve Z) : pushforward (g ‚â´ f) R = pushforward f (pushforward g R) := sorry

theorem galois_connection {C : Type u} [category C] {X : C} {Y : C} (f : Y ‚ü∂ X) : galois_connection (pushforward f) (pullback f) := sorry

theorem pullback_monotone {C : Type u} [category C] {X : C} {Y : C} (f : Y ‚ü∂ X) : monotone (pullback f) :=
  galois_connection.monotone_u (galois_connection f)

theorem pushforward_monotone {C : Type u} [category C] {X : C} {Y : C} (f : Y ‚ü∂ X) : monotone (pushforward f) :=
  galois_connection.monotone_l (galois_connection f)

theorem le_pushforward_pullback {C : Type u} [category C] {X : C} {Y : C} (f : Y ‚ü∂ X) (R : sieve Y) : R ‚â§ pullback f (pushforward f R) :=
  galois_connection.le_u_l (galois_connection f) R

theorem pullback_pushforward_le {C : Type u} [category C] {X : C} {Y : C} (f : Y ‚ü∂ X) (R : sieve X) : pushforward f (pullback f R) ‚â§ R :=
  galois_connection.l_u_le (galois_connection f) R

theorem pushforward_union {C : Type u} [category C] {X : C} {Y : C} {f : Y ‚ü∂ X} (S : sieve Y) (R : sieve Y) : pushforward f (S ‚äî R) = pushforward f S ‚äî pushforward f R :=
  galois_connection.l_sup (galois_connection f)

theorem pushforward_le_bind_of_mem {C : Type u} [category C] {X : C} {Y : C} (S : presieve X) (R : {Y : C} ‚Üí {f : Y ‚ü∂ X} ‚Üí S f ‚Üí sieve Y) (f : Y ‚ü∂ X) (h : S f) : pushforward f (R h) ‚â§ bind S R := sorry

theorem le_pullback_bind {C : Type u} [category C] {X : C} {Y : C} (S : presieve X) (R : {Y : C} ‚Üí {f : Y ‚ü∂ X} ‚Üí S f ‚Üí sieve Y) (f : Y ‚ü∂ X) (h : S f) : R h ‚â§ pullback f (bind S R) :=
  eq.mpr
    (id (Eq._oldrec (Eq.refl (R h ‚â§ pullback f (bind S R))) (Eq.symm (propext (galois_connection f (R h) (bind S R))))))
    (pushforward_le_bind_of_mem (fun {Y : C} (f : Y ‚ü∂ X) => S f) R f h)

/-- If `f` is a monomorphism, the pushforward-pullback adjunction on sieves is coreflective. -/
def galois_coinsertion_of_mono {C : Type u} [category C] {X : C} {Y : C} (f : Y ‚ü∂ X) [mono f] : galois_coinsertion (pushforward f) (pullback f) :=
  galois_connection.to_galois_coinsertion (galois_connection f) sorry

/-- If `f` is a split epi, the pushforward-pullback adjunction on sieves is reflective. -/
def galois_insertion_of_split_epi {C : Type u} [category C] {X : C} {Y : C} (f : Y ‚ü∂ X) [split_epi f] : galois_insertion (pushforward f) (pullback f) :=
  galois_connection.to_galois_insertion (galois_connection f) sorry

/-- A sieve induces a presheaf. -/
@[simp] theorem functor_obj {C : Type u} [category C] {X : C} (S : sieve X) (Y : C·µí·µñ) : functor.obj (functor S) Y = Subtype fun (g : opposite.unop Y ‚ü∂ X) => coe_fn S (opposite.unop Y) g :=
  Eq.refl (functor.obj (functor S) Y)

/--
If a sieve S is contained in a sieve T, then we have a morphism of presheaves on their induced
presheaves.
-/
def nat_trans_of_le {C : Type u} [category C] {X : C} {S : sieve X} {T : sieve X} (h : S ‚â§ T) : functor S ‚ü∂ functor T :=
  nat_trans.mk fun (Y : C·µí·µñ) (f : functor.obj (functor S) Y) => { val := subtype.val f, property := sorry }

/-- The natural inclusion from the functor induced by a sieve to the yoneda embedding. -/
@[simp] theorem functor_inclusion_app {C : Type u} [category C] {X : C} (S : sieve X) (Y : C·µí·µñ) (f : functor.obj (functor S) Y) : nat_trans.app (functor_inclusion S) Y f = subtype.val f :=
  Eq.refl (nat_trans.app (functor_inclusion S) Y f)

theorem nat_trans_of_le_comm {C : Type u} [category C] {X : C} {S : sieve X} {T : sieve X} (h : S ‚â§ T) : nat_trans_of_le h ‚â´ functor_inclusion T = functor_inclusion S :=
  rfl

/-- The presheaf induced by a sieve is a subobject of the yoneda embedding. -/
protected instance functor_inclusion_is_mono {C : Type u} [category C] {X : C} {S : sieve X} : mono (functor_inclusion S) :=
  mono.mk
    fun (Z : C·µí·µñ ‚•§ Type v) (f g : Z ‚ü∂ functor S) (h : f ‚â´ functor_inclusion S = g ‚â´ functor_inclusion S) =>
      nat_trans.ext f g
        (funext fun (Y : C·µí·µñ) => funext fun (y : functor.obj Z Y) => subtype.ext (congr_fun (nat_trans.congr_app h Y) y))

/--
A natural transformation to a representable functor induces a sieve. This is the left inverse of
`functor_inclusion`, shown in `sieve_of_functor_inclusion`.
-/
-- TODO: Show that when `f` is mono, this is right inverse to `functor_inclusion` up to isomorphism.

@[simp] theorem sieve_of_subfunctor_apply {C : Type u} [category C] {X : C} {R : C·µí·µñ ‚•§ Type v} (f : R ‚ü∂ functor.obj yoneda X) (Y : C) (g : Y ‚ü∂ X) : coe_fn (sieve_of_subfunctor f) Y g = ‚àÉ (t : functor.obj R (opposite.op Y)), nat_trans.app f (opposite.op Y) t = g :=
  Eq.refl (coe_fn (sieve_of_subfunctor f) Y g)

theorem sieve_of_subfunctor_functor_inclusion {C : Type u} [category C] {X : C} {S : sieve X} : sieve_of_subfunctor (functor_inclusion S) = S := sorry

protected instance functor_inclusion_top_is_iso {C : Type u} [category C] {X : C} : is_iso (functor_inclusion ‚ä§) :=
  is_iso.mk
    (nat_trans.mk fun (Y : C·µí·µñ) (a : functor.obj (functor.obj yoneda X) Y) => { val := a, property := True.intro })

