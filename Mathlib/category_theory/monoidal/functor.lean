/-
Copyright (c) 2018 Michael Jendrusch. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Michael Jendrusch, Scott Morrison
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.category_theory.monoidal.category
import Mathlib.PostPort

universes v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ l u‚ÇÉ v‚ÇÉ 

namespace Mathlib

/-!
# (Lax) monoidal functors

A lax monoidal functor `F` between monoidal categories `C` and `D`
is a functor between the underlying categories equipped with morphisms
* `Œµ : ùüô_ D ‚ü∂ F.obj (ùüô_ C)` (called the unit morphism)
* `Œº X Y : (F.obj X) ‚äó (F.obj Y) ‚ü∂ F.obj (X ‚äó Y)` (called the tensorator, or strength).
satisfying various axioms.

A monoidal functor is a lax monoidal functor for which `Œµ` and `Œº` are isomorphisms.

We show that the composition of (lax) monoidal functors gives a (lax) monoidal functor.

See also `category_theory.monoidal.functorial` for a typeclass decorating an object-level
function with the additional data of a monoidal functor.
This is useful when stating that a pre-existing functor is monoidal.

See `category_theory.monoidal.natural_transformation` for monoidal natural transformations.

We show in `category_theory.monoidal.Mon_` that lax monoidal functors take monoid objects
to monoid objects.

## Future work
* Oplax monoidal functors.

## References

See https://stacks.math.columbia.edu/tag/0FFL.
-/

namespace category_theory


/-- A lax monoidal functor is a functor `F : C ‚•§ D` between monoidal categories, equipped with morphisms
    `Œµ : ùüô _D ‚ü∂ F.obj (ùüô_ C)` and `Œº X Y : F.obj X ‚äó F.obj Y ‚ü∂ F.obj (X ‚äó Y)`, satisfying the
    the appropriate coherences. -/
-- unit morphism

structure lax_monoidal_functor (C : Type u‚ÇÅ) [category C] [monoidal_category C] (D : Type u‚ÇÇ) [category D] [monoidal_category D] 
extends C ‚•§ D
where
  Œµ : ùüô_ ‚ü∂ functor.obj _to_functor ùüô_
  Œº : (X Y : C) ‚Üí functor.obj _to_functor X ‚äó functor.obj _to_functor Y ‚ü∂ functor.obj _to_functor (X ‚äó Y)
  Œº_natural' : autoParam
  (‚àÄ {X Y X' Y' : C} (f : X ‚ü∂ Y) (g : X' ‚ü∂ Y'),
    (functor.map _to_functor f ‚äó functor.map _to_functor g) ‚â´ Œº Y Y' = Œº X X' ‚â´ functor.map _to_functor (f ‚äó g))
  (Lean.Syntax.ident Lean.SourceInfo.none (String.toSubstring "Mathlib.obviously")
    (Lean.Name.mkStr (Lean.Name.mkStr Lean.Name.anonymous "Mathlib") "obviously") [])
  associativity' : autoParam
  (‚àÄ (X Y Z : C),
    (Œº X Y ‚äó ùüô) ‚â´ Œº (X ‚äó Y) Z ‚â´ functor.map _to_functor (iso.hom Œ±_) = iso.hom Œ±_ ‚â´ (ùüô ‚äó Œº Y Z) ‚â´ Œº X (Y ‚äó Z))
  (Lean.Syntax.ident Lean.SourceInfo.none (String.toSubstring "Mathlib.obviously")
    (Lean.Name.mkStr (Lean.Name.mkStr Lean.Name.anonymous "Mathlib") "obviously") [])
  left_unitality' : autoParam (‚àÄ (X : C), iso.hom Œª_ = (Œµ ‚äó ùüô) ‚â´ Œº ùüô_ X ‚â´ functor.map _to_functor (iso.hom Œª_))
  (Lean.Syntax.ident Lean.SourceInfo.none (String.toSubstring "Mathlib.obviously")
    (Lean.Name.mkStr (Lean.Name.mkStr Lean.Name.anonymous "Mathlib") "obviously") [])
  right_unitality' : autoParam (‚àÄ (X : C), iso.hom œÅ_ = (ùüô ‚äó Œµ) ‚â´ Œº X ùüô_ ‚â´ functor.map _to_functor (iso.hom œÅ_))
  (Lean.Syntax.ident Lean.SourceInfo.none (String.toSubstring "Mathlib.obviously")
    (Lean.Name.mkStr (Lean.Name.mkStr Lean.Name.anonymous "Mathlib") "obviously") [])

-- tensorator

-- associativity of the tensorator

-- unitality

@[simp] theorem lax_monoidal_functor.Œº_natural {C : Type u‚ÇÅ} [category C] [monoidal_category C] {D : Type u‚ÇÇ} [category D] [monoidal_category D] (c : lax_monoidal_functor C D) {X : C} {Y : C} {X' : C} {Y' : C} (f : X ‚ü∂ Y) (g : X' ‚ü∂ Y') : (functor.map (lax_monoidal_functor.to_functor c) f ‚äó functor.map (lax_monoidal_functor.to_functor c) g) ‚â´
    lax_monoidal_functor.Œº c Y Y' =
  lax_monoidal_functor.Œº c X X' ‚â´ functor.map (lax_monoidal_functor.to_functor c) (f ‚äó g) := sorry

@[simp] theorem lax_monoidal_functor.Œº_natural_assoc {C : Type u‚ÇÅ} [category C] [monoidal_category C] {D : Type u‚ÇÇ} [category D] [monoidal_category D] (c : lax_monoidal_functor C D) {X : C} {Y : C} {X' : C} {Y' : C} (f : X ‚ü∂ Y) (g : X' ‚ü∂ Y') : ‚àÄ {X'_1 : D} (f' : functor.obj (lax_monoidal_functor.to_functor c) (Y ‚äó Y') ‚ü∂ X'_1),
  (functor.map (lax_monoidal_functor.to_functor c) f ‚äó functor.map (lax_monoidal_functor.to_functor c) g) ‚â´
      lax_monoidal_functor.Œº c Y Y' ‚â´ f' =
    lax_monoidal_functor.Œº c X X' ‚â´ functor.map (lax_monoidal_functor.to_functor c) (f ‚äó g) ‚â´ f' := sorry

@[simp] theorem lax_monoidal_functor.left_unitality {C : Type u‚ÇÅ} [category C] [monoidal_category C] {D : Type u‚ÇÇ} [category D] [monoidal_category D] (c : lax_monoidal_functor C D) (X : C) : iso.hom Œª_ =
  (lax_monoidal_functor.Œµ c ‚äó ùüô) ‚â´
    lax_monoidal_functor.Œº c ùüô_ X ‚â´ functor.map (lax_monoidal_functor.to_functor c) (iso.hom Œª_) := sorry

@[simp] theorem lax_monoidal_functor.right_unitality {C : Type u‚ÇÅ} [category C] [monoidal_category C] {D : Type u‚ÇÇ} [category D] [monoidal_category D] (c : lax_monoidal_functor C D) (X : C) : iso.hom œÅ_ =
  (ùüô ‚äó lax_monoidal_functor.Œµ c) ‚â´
    lax_monoidal_functor.Œº c X ùüô_ ‚â´ functor.map (lax_monoidal_functor.to_functor c) (iso.hom œÅ_) := sorry

@[simp] theorem lax_monoidal_functor.associativity {C : Type u‚ÇÅ} [category C] [monoidal_category C] {D : Type u‚ÇÇ} [category D] [monoidal_category D] (c : lax_monoidal_functor C D) (X : C) (Y : C) (Z : C) : (lax_monoidal_functor.Œº c X Y ‚äó ùüô) ‚â´
    lax_monoidal_functor.Œº c (X ‚äó Y) Z ‚â´ functor.map (lax_monoidal_functor.to_functor c) (iso.hom Œ±_) =
  iso.hom Œ±_ ‚â´ (ùüô ‚äó lax_monoidal_functor.Œº c Y Z) ‚â´ lax_monoidal_functor.Œº c X (Y ‚äó Z) := sorry

-- When `rewrite_search` lands, add @[search] attributes to

-- lax_monoidal_functor.Œº_natural lax_monoidal_functor.left_unitality

-- lax_monoidal_functor.right_unitality lax_monoidal_functor.associativity

/--
A monoidal functor is a lax monoidal functor for which the tensorator and unitor as isomorphisms.

See https://stacks.math.columbia.edu/tag/0FFL.
-/
structure monoidal_functor (C : Type u‚ÇÅ) [category C] [monoidal_category C] (D : Type u‚ÇÇ) [category D] [monoidal_category D] 
extends lax_monoidal_functor C D
where
  Œµ_is_iso : autoParam (is_iso (lax_monoidal_functor.Œµ _to_lax_monoidal_functor))
  (Lean.Syntax.ident Lean.SourceInfo.none (String.toSubstring "Mathlib.tactic.apply_instance")
    (Lean.Name.mkStr (Lean.Name.mkStr (Lean.Name.mkStr Lean.Name.anonymous "Mathlib") "tactic") "apply_instance") [])
  Œº_is_iso : autoParam ((X Y : C) ‚Üí is_iso (lax_monoidal_functor.Œº _to_lax_monoidal_functor X Y))
  (Lean.Syntax.ident Lean.SourceInfo.none (String.toSubstring "Mathlib.tactic.apply_instance")
    (Lean.Name.mkStr (Lean.Name.mkStr (Lean.Name.mkStr Lean.Name.anonymous "Mathlib") "tactic") "apply_instance") [])

/--
The unit morphism of a (strong) monoidal functor as an isomorphism.
-/
def monoidal_functor.Œµ_iso {C : Type u‚ÇÅ} [category C] [monoidal_category C] {D : Type u‚ÇÇ} [category D] [monoidal_category D] (F : monoidal_functor C D) : ùüô_ ‚âÖ functor.obj (lax_monoidal_functor.to_functor (monoidal_functor.to_lax_monoidal_functor F)) ùüô_ :=
  as_iso (lax_monoidal_functor.Œµ (monoidal_functor.to_lax_monoidal_functor F))

/--
The tensorator of a (strong) monoidal functor as an isomorphism.
-/
def monoidal_functor.Œº_iso {C : Type u‚ÇÅ} [category C] [monoidal_category C] {D : Type u‚ÇÇ} [category D] [monoidal_category D] (F : monoidal_functor C D) (X : C) (Y : C) : functor.obj (lax_monoidal_functor.to_functor (monoidal_functor.to_lax_monoidal_functor F)) X ‚äó
    functor.obj (lax_monoidal_functor.to_functor (monoidal_functor.to_lax_monoidal_functor F)) Y ‚âÖ
  functor.obj (lax_monoidal_functor.to_functor (monoidal_functor.to_lax_monoidal_functor F)) (X ‚äó Y) :=
  as_iso (lax_monoidal_functor.Œº (monoidal_functor.to_lax_monoidal_functor F) X Y)

namespace lax_monoidal_functor


/-- The identity lax monoidal functor. -/
@[simp] theorem id_Œµ (C : Type u‚ÇÅ) [category C] [monoidal_category C] : Œµ (id C) = ùüô :=
  Eq.refl (Œµ (id C))

protected instance inhabited (C : Type u‚ÇÅ) [category C] [monoidal_category C] : Inhabited (lax_monoidal_functor C C) :=
  { default := id C }

end lax_monoidal_functor


namespace monoidal_functor


theorem map_tensor {C : Type u‚ÇÅ} [category C] [monoidal_category C] {D : Type u‚ÇÇ} [category D] [monoidal_category D] (F : monoidal_functor C D) {X : C} {Y : C} {X' : C} {Y' : C} (f : X ‚ü∂ Y) (g : X' ‚ü∂ Y') : functor.map (lax_monoidal_functor.to_functor (to_lax_monoidal_functor F)) (f ‚äó g) =
  inv (lax_monoidal_functor.Œº (to_lax_monoidal_functor F) X X') ‚â´
    (functor.map (lax_monoidal_functor.to_functor (to_lax_monoidal_functor F)) f ‚äó
        functor.map (lax_monoidal_functor.to_functor (to_lax_monoidal_functor F)) g) ‚â´
      lax_monoidal_functor.Œº (to_lax_monoidal_functor F) Y Y' := sorry

theorem map_left_unitor {C : Type u‚ÇÅ} [category C] [monoidal_category C] {D : Type u‚ÇÇ} [category D] [monoidal_category D] (F : monoidal_functor C D) (X : C) : functor.map (lax_monoidal_functor.to_functor (to_lax_monoidal_functor F)) (iso.hom Œª_) =
  inv (lax_monoidal_functor.Œº (to_lax_monoidal_functor F) ùüô_ X) ‚â´
    (inv (lax_monoidal_functor.Œµ (to_lax_monoidal_functor F)) ‚äó ùüô) ‚â´ iso.hom Œª_ := sorry

theorem map_right_unitor {C : Type u‚ÇÅ} [category C] [monoidal_category C] {D : Type u‚ÇÇ} [category D] [monoidal_category D] (F : monoidal_functor C D) (X : C) : functor.map (lax_monoidal_functor.to_functor (to_lax_monoidal_functor F)) (iso.hom œÅ_) =
  inv (lax_monoidal_functor.Œº (to_lax_monoidal_functor F) X ùüô_) ‚â´
    (ùüô ‚äó inv (lax_monoidal_functor.Œµ (to_lax_monoidal_functor F))) ‚â´ iso.hom œÅ_ := sorry

/-- The tensorator as a natural isomorphism. -/
def Œº_nat_iso {C : Type u‚ÇÅ} [category C] [monoidal_category C] {D : Type u‚ÇÇ} [category D] [monoidal_category D] (F : monoidal_functor C D) : functor.prod (lax_monoidal_functor.to_functor (to_lax_monoidal_functor F))
      (lax_monoidal_functor.to_functor (to_lax_monoidal_functor F)) ‚ãô
    monoidal_category.tensor D ‚âÖ
  monoidal_category.tensor C ‚ãô lax_monoidal_functor.to_functor (to_lax_monoidal_functor F) :=
  nat_iso.of_components (fun (X : C √ó C) => Œº_iso F (prod.fst X) (prod.snd X)) sorry

/-- The identity monoidal functor. -/
def id (C : Type u‚ÇÅ) [category C] [monoidal_category C] : monoidal_functor C C :=
  mk (lax_monoidal_functor.mk (functor.mk (functor.obj ùü≠) (functor.map ùü≠)) ùüô fun (X Y : C) => ùüô)

protected instance inhabited (C : Type u‚ÇÅ) [category C] [monoidal_category C] : Inhabited (monoidal_functor C C) :=
  { default := id C }

end monoidal_functor


namespace lax_monoidal_functor


-- The proofs here are horrendous; rewrite_search helps a lot.

/-- The composition of two lax monoidal functors is again lax monoidal. -/
@[simp] theorem comp_Œµ {C : Type u‚ÇÅ} [category C] [monoidal_category C] {D : Type u‚ÇÇ} [category D] [monoidal_category D] {E : Type u‚ÇÉ} [category E] [monoidal_category E] (F : lax_monoidal_functor C D) (G : lax_monoidal_functor D E) : Œµ (comp F G) = Œµ G ‚â´ functor.map (to_functor G) (Œµ F) :=
  Eq.refl (Œµ (comp F G))

infixr:80 " ‚äó‚ãô " => Mathlib.category_theory.lax_monoidal_functor.comp

end lax_monoidal_functor


namespace monoidal_functor


/-- The composition of two monoidal functors is again monoidal. -/
def comp {C : Type u‚ÇÅ} [category C] [monoidal_category C] {D : Type u‚ÇÇ} [category D] [monoidal_category D] {E : Type u‚ÇÉ} [category E] [monoidal_category E] (F : monoidal_functor C D) (G : monoidal_functor D E) : monoidal_functor C E :=
  mk
    (lax_monoidal_functor.mk (lax_monoidal_functor.to_functor (to_lax_monoidal_functor F ‚äó‚ãô to_lax_monoidal_functor G))
      (lax_monoidal_functor.Œµ (to_lax_monoidal_functor F ‚äó‚ãô to_lax_monoidal_functor G))
      (lax_monoidal_functor.Œº (to_lax_monoidal_functor F ‚äó‚ãô to_lax_monoidal_functor G)))

infixr:80 " ‚äó‚ãô " => Mathlib.category_theory.monoidal_functor.comp

