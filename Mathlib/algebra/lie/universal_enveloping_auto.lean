/-
Copyright (c) 2020 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.algebra.lie.basic
import Mathlib.algebra.ring_quot
import Mathlib.linear_algebra.tensor_algebra
import Mathlib.PostPort

universes u₁ u₂ u₃ 

namespace Mathlib

/-!
# Universal enveloping algebra

Given a commutative ring `R` and a Lie algebra `L` over `R`, we construct the universal
enveloping algebra of `L`, together with its universal property.

## Main definitions

  * `universal_enveloping_algebra`: the universal enveloping algebra, endowed with an
    `R`-algebra structure.
  * `universal_enveloping_algebra.ι`: the Lie algebra morphism from `L` to its universal
    enveloping algebra.
  * `universal_enveloping_algebra.lift`: given an associative algebra `A`, together with a Lie
    algebra morphism `f : L →ₗ⁅R⁆ A`, `lift R L f : universal_enveloping_algebra R L →ₐ[R] A` is the
    unique morphism of algebras through which `f` factors.
  * `universal_enveloping_algebra.ι_comp_lift`: states that the lift of a morphism is indeed part
    of a factorisation.
  * `universal_enveloping_algebra.lift_unique`: states that lifts of morphisms are indeed unique.
  * `universal_enveloping_algebra.hom_ext`: a restatement of `lift_unique` as an extensionality
    lemma.

## Tags

lie algebra, universal enveloping algebra, tensor algebra
-/

namespace universal_enveloping_algebra


/-- The quotient by the ideal generated by this relation is the universal enveloping algebra.

Note that we have avoided using the more natural expression:
| lie_compat (x y : L) : rel (ιₜ ⁅x, y⁆) ⁅ιₜ x, ιₜ y⁆
so that our construction needs only the semiring structure of the tensor algebra. -/
inductive rel (R : Type u₁) (L : Type u₂) [comm_ring R] [lie_ring L] [lie_algebra R L] :
    tensor_algebra R L → tensor_algebra R L → Prop
    where
| lie_compat :
    ∀ (x y : L),
      rel R L
        (coe_fn (tensor_algebra.ι R) (has_bracket.bracket x y) +
          coe_fn (tensor_algebra.ι R) y * coe_fn (tensor_algebra.ι R) x)
        (coe_fn (tensor_algebra.ι R) x * coe_fn (tensor_algebra.ι R) y)

end universal_enveloping_algebra


/-- The universal enveloping algebra of a Lie algebra. -/
def universal_enveloping_algebra (R : Type u₁) (L : Type u₂) [comm_ring R] [lie_ring L]
    [lie_algebra R L] :=
  ring_quot sorry

namespace universal_enveloping_algebra


/-- The quotient map from the tensor algebra to the universal enveloping algebra as a morphism of
associative algebras. -/
def mk_alg_hom (R : Type u₁) (L : Type u₂) [comm_ring R] [lie_ring L] [lie_algebra R L] :
    alg_hom R (tensor_algebra R L) (universal_enveloping_algebra R L) :=
  ring_quot.mk_alg_hom R (rel R L)

/-- The natural Lie algebra morphism from a Lie algebra to its universal enveloping algebra. -/
def ι (R : Type u₁) {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L] :
    lie_algebra.morphism R L (universal_enveloping_algebra R L) :=
  lie_algebra.morphism.mk
    (linear_map.to_fun
      (linear_map.comp (alg_hom.to_linear_map (mk_alg_hom R L)) (tensor_algebra.ι R)))
    sorry sorry sorry

/-- The universal property of the universal enveloping algebra: Lie algebra morphisms into
associative algebras lift to associative algebra morphisms from the universal enveloping algebra. -/
def lift (R : Type u₁) {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L] {A : Type u₃}
    [ring A] [algebra R A] :
    lie_algebra.morphism R L A ≃ alg_hom R (universal_enveloping_algebra R L) A :=
  equiv.mk
    (fun (f : lie_algebra.morphism R L A) =>
      coe_fn (ring_quot.lift_alg_hom R)
        { val := coe_fn (tensor_algebra.lift R) ↑f, property := sorry })
    (fun (F : alg_hom R (universal_enveloping_algebra R L) A) =>
      lie_algebra.morphism.comp (lie_algebra.of_associative_algebra_hom F) (ι R))
    sorry sorry

@[simp] theorem lift_symm_apply (R : Type u₁) {L : Type u₂} [comm_ring R] [lie_ring L]
    [lie_algebra R L] {A : Type u₃} [ring A] [algebra R A]
    (F : alg_hom R (universal_enveloping_algebra R L) A) :
    coe_fn (equiv.symm (lift R)) F =
        lie_algebra.morphism.comp (lie_algebra.of_associative_algebra_hom F) (ι R) :=
  rfl

@[simp] theorem ι_comp_lift (R : Type u₁) {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L]
    {A : Type u₃} [ring A] [algebra R A] (f : lie_algebra.morphism R L A) :
    ⇑(coe_fn (lift R) f) ∘ ⇑(ι R) = ⇑f :=
  funext (iff.mp lie_algebra.morphism.ext_iff (equiv.symm_apply_apply (lift R) f))

@[simp] theorem lift_ι_apply (R : Type u₁) {L : Type u₂} [comm_ring R] [lie_ring L]
    [lie_algebra R L] {A : Type u₃} [ring A] [algebra R A] (f : lie_algebra.morphism R L A)
    (x : L) : coe_fn (coe_fn (lift R) f) (coe_fn (ι R) x) = coe_fn f x :=
  sorry

theorem lift_unique (R : Type u₁) {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L]
    {A : Type u₃} [ring A] [algebra R A] (f : lie_algebra.morphism R L A)
    (g : alg_hom R (universal_enveloping_algebra R L) A) :
    ⇑g ∘ ⇑(ι R) = ⇑f ↔ g = coe_fn (lift R) f :=
  sorry

/-- See note [partially-applied ext lemmas]. -/
theorem hom_ext (R : Type u₁) {L : Type u₂} [comm_ring R] [lie_ring L] [lie_algebra R L]
    {A : Type u₃} [ring A] [algebra R A] {g₁ : alg_hom R (universal_enveloping_algebra R L) A}
    {g₂ : alg_hom R (universal_enveloping_algebra R L) A} (h : ⇑g₁ ∘ ⇑(ι R) = ⇑g₂ ∘ ⇑(ι R)) :
    g₁ = g₂ :=
  sorry

end Mathlib