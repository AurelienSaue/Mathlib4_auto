/-
Copyright (c) 2017 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Yury G. Kudryashov, Scott Morrison
-/
import PrePort
import Lean3Lib.init.default
import Mathlib.algebra.algebra.basic
import Mathlib.linear_algebra.finsupp
import PostPort

universes u₁ u₂ u_1 u_2 u_3 u₃ ui 

namespace Mathlib

/-!
# Monoid algebras

When the domain of a `finsupp` has a multiplicative or additive structure, we can define
a convolution product. To mathematicians this structure is known as the "monoid algebra",
i.e. the finite formal linear combinations over a given semiring of elements of the monoid.
The "group ring" ℤ[G] or the "group algebra" k[G] are typical uses.

In this file we define `monoid_algebra k G := G →₀ k`, and `add_monoid_algebra k G`
in the same way, and then define the convolution product on these.

When the domain is additive, this is used to define polynomials:
```
polynomial α := add_monoid_algebra ℕ α
mv_polynomial σ α := add_monoid_algebra (σ →₀ ℕ) α
```

When the domain is multiplicative, e.g. a group, this will be used to define the group ring.

## Implementation note
Unfortunately because additive and multiplicative structures both appear in both cases,
it doesn't appear to be possible to make much use of `to_additive`, and we just settle for
saying everything twice.

Similarly, I attempted to just define
`add_monoid_algebra k G := monoid_algebra k (multiplicative G)`, but the definitional equality
`multiplicative G = G` leaks through everywhere, and seems impossible to use.
-/

/-! ### Multiplicative monoids -/

/--
The monoid algebra over a semiring `k` generated by the monoid `G`.
It is the type of finite formal `k`-linear combinations of terms of `G`,
endowed with the convolution product.
-/
def monoid_algebra (k : Type u₁) (G : Type u₂) [semiring k]  :=
  G →₀ k

namespace monoid_algebra


/-! #### Semiring structure -/

/-- The product of `f g : monoid_algebra k G` is the finitely supported function
  whose value at `a` is the sum of `f x * g y` over all pairs `x, y`
  such that `x * y = a`. (Think of the group ring of a group.) -/
protected instance has_mul {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] : Mul (monoid_algebra k G) :=
  { mul :=
      fun (f g : monoid_algebra k G) =>
        finsupp.sum f fun (a₁ : G) (b₁ : k) => finsupp.sum g fun (a₂ : G) (b₂ : k) => finsupp.single (a₁ * a₂) (b₁ * b₂) }

theorem mul_def {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] {f : monoid_algebra k G} {g : monoid_algebra k G} : f * g = finsupp.sum f fun (a₁ : G) (b₁ : k) => finsupp.sum g fun (a₂ : G) (b₂ : k) => finsupp.single (a₁ * a₂) (b₁ * b₂) :=
  rfl

/-- The unit of the multiplication is `single 1 1`, i.e. the function
  that is `1` at `1` and zero elsewhere. -/
protected instance has_one {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] : HasOne (monoid_algebra k G) :=
  { one := finsupp.single 1 1 }

theorem one_def {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] : 1 = finsupp.single 1 1 :=
  rfl

protected instance semiring {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] : semiring (monoid_algebra k G) :=
  semiring.mk Add.add sorry 0 sorry sorry sorry Mul.mul sorry 1 sorry sorry sorry sorry sorry sorry

/-- A non-commutative version of `monoid_algebra.lift`: given a additive homomorphism `f : k →+ R`
and a multiplicative monoid homomorphism `g : G →* R`, returns the additive homomorphism from
`monoid_algebra k G` such that `lift_nc f g (single a b) = f b * g a`. If `f` is a ring homomorphism
and the range of either `f` or `g` is in center of `R`, then the result is a ring homomorphism.  If
`R` is a `k`-algebra and `f = algebra_map k R`, then the result is an algebra homomorphism called
`monoid_algebra.lift`. -/
def lift_nc {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] {R : Type u_1} [semiring R] (f : k →+ R) (g : G →* R) : monoid_algebra k G →+ R :=
  coe_fn finsupp.lift_add_hom fun (x : G) => add_monoid_hom.comp (add_monoid_hom.mul_right (coe_fn g x)) f

@[simp] theorem lift_nc_single {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] {R : Type u_1} [semiring R] (f : k →+ R) (g : G →* R) (a : G) (b : k) : coe_fn (lift_nc f g) (finsupp.single a b) = coe_fn f b * coe_fn g a :=
  finsupp.lift_add_hom_apply_single (fun (x : G) => add_monoid_hom.comp (add_monoid_hom.mul_right (coe_fn g x)) f) a b

@[simp] theorem lift_nc_one {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] {R : Type u_1} [semiring R] (f : k →+* R) (g : G →* R) : coe_fn (lift_nc (↑f) g) 1 = 1 := sorry

theorem lift_nc_mul {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] {R : Type u_1} [semiring R] (f : k →+* R) (g : G →* R) (a : monoid_algebra k G) (b : monoid_algebra k G) (h_comm : ∀ {x y : G}, y ∈ finsupp.support a → commute (coe_fn f (coe_fn b x)) (coe_fn g y)) : coe_fn (lift_nc (↑f) g) (a * b) = coe_fn (lift_nc (↑f) g) a * coe_fn (lift_nc (↑f) g) b := sorry

/-- `lift_nc` as a `ring_hom`, for when `f x` and `g y` commute -/
def lift_nc_ring_hom {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] {R : Type u_1} [semiring R] (f : k →+* R) (g : G →* R) (h_comm : ∀ (x : k) (y : G), commute (coe_fn f x) (coe_fn g y)) : monoid_algebra k G →+* R :=
  ring_hom.mk (⇑(lift_nc (↑f) g)) (lift_nc_one f g) sorry sorry sorry

protected instance comm_semiring {k : Type u₁} {G : Type u₂} [comm_semiring k] [comm_monoid G] : comm_semiring (monoid_algebra k G) :=
  comm_semiring.mk semiring.add sorry semiring.zero sorry sorry sorry semiring.mul sorry semiring.one sorry sorry sorry
    sorry sorry sorry sorry

protected instance nontrivial {k : Type u₁} {G : Type u₂} [semiring k] [nontrivial k] [monoid G] : nontrivial (monoid_algebra k G) :=
  finsupp.nontrivial

/-! #### Derived instances -/

protected instance unique {k : Type u₁} {G : Type u₂} [semiring k] [subsingleton k] : unique (monoid_algebra k G) :=
  finsupp.unique_of_right

protected instance add_group {k : Type u₁} {G : Type u₂} [ring k] : add_group (monoid_algebra k G) :=
  finsupp.add_group

protected instance ring {k : Type u₁} {G : Type u₂} [ring k] [monoid G] : ring (monoid_algebra k G) :=
  ring.mk semiring.add sorry semiring.zero sorry sorry Neg.neg
    (add_comm_group.sub._default semiring.add sorry semiring.zero sorry sorry Neg.neg) sorry sorry semiring.mul sorry
    semiring.one sorry sorry sorry sorry

protected instance comm_ring {k : Type u₁} {G : Type u₂} [comm_ring k] [comm_monoid G] : comm_ring (monoid_algebra k G) :=
  comm_ring.mk ring.add sorry ring.zero sorry sorry ring.neg ring.sub sorry sorry ring.mul sorry ring.one sorry sorry
    sorry sorry sorry

protected instance has_scalar {k : Type u₁} {G : Type u₂} {R : Type u_1} [semiring R] [semiring k] [semimodule R k] : has_scalar R (monoid_algebra k G) :=
  finsupp.has_scalar

protected instance semimodule {k : Type u₁} {G : Type u₂} {R : Type u_1} [semiring R] [semiring k] [semimodule R k] : semimodule R (monoid_algebra k G) :=
  finsupp.semimodule G k

protected instance distrib_mul_action {k : Type u₁} {G : Type u₂} [group G] [semiring k] : distrib_mul_action G (monoid_algebra k G) :=
  finsupp.comap_distrib_mul_action_self

theorem mul_apply {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] (f : monoid_algebra k G) (g : monoid_algebra k G) (x : G) : coe_fn (f * g) x =
  finsupp.sum f fun (a₁ : G) (b₁ : k) => finsupp.sum g fun (a₂ : G) (b₂ : k) => ite (a₁ * a₂ = x) (b₁ * b₂) 0 := sorry

theorem mul_apply_antidiagonal {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] (f : monoid_algebra k G) (g : monoid_algebra k G) (x : G) (s : finset (G × G)) (hs : ∀ {p : G × G}, p ∈ s ↔ prod.fst p * prod.snd p = x) : coe_fn (f * g) x = finset.sum s fun (p : G × G) => coe_fn f (prod.fst p) * coe_fn g (prod.snd p) := sorry

theorem support_mul {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] (a : monoid_algebra k G) (b : monoid_algebra k G) : finsupp.support (a * b) ⊆
  finset.bUnion (finsupp.support a)
    fun (a₁ : G) => finset.bUnion (finsupp.support b) fun (a₂ : G) => singleton (a₁ * a₂) := sorry

@[simp] theorem single_mul_single {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] {a₁ : G} {a₂ : G} {b₁ : k} {b₂ : k} : finsupp.single a₁ b₁ * finsupp.single a₂ b₂ = finsupp.single (a₁ * a₂) (b₁ * b₂) := sorry

@[simp] theorem single_pow {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] {a : G} {b : k} (n : ℕ) : finsupp.single a b ^ n = finsupp.single (a ^ n) (b ^ n) := sorry

/-- Like `finsupp.map_domain_add`, but for the convolutive multiplication we define in this file -/
theorem map_domain_mul {α : Type u_1} {β : Type u_2} {α₂ : Type u_3} [semiring β] [monoid α] [monoid α₂] {x : monoid_algebra β α} {y : monoid_algebra β α} (f : mul_hom α α₂) : finsupp.map_domain (⇑f) (x * y) = finsupp.map_domain (⇑f) x * finsupp.map_domain (⇑f) y := sorry

/-- Embedding of a monoid into its monoid algebra. -/
def of (k : Type u₁) (G : Type u₂) [semiring k] [monoid G] : G →* monoid_algebra k G :=
  monoid_hom.mk (fun (a : G) => finsupp.single a 1) sorry sorry

@[simp] theorem of_apply {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] (a : G) : coe_fn (of k G) a = finsupp.single a 1 :=
  rfl

theorem of_injective {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] [nontrivial k] : function.injective ⇑(of k G) := sorry

theorem mul_single_apply_aux {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] (f : monoid_algebra k G) {r : k} {x : G} {y : G} {z : G} (H : ∀ (a : G), a * x = z ↔ a = y) : coe_fn (f * finsupp.single x r) z = coe_fn f y * r := sorry

theorem mul_single_one_apply {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] (f : monoid_algebra k G) (r : k) (x : G) : coe_fn (f * finsupp.single 1 r) x = coe_fn f x * r :=
  mul_single_apply_aux f
    fun (a : G) => eq.mpr (id (Eq._oldrec (Eq.refl (a * 1 = x ↔ a = x)) (mul_one a))) (iff.refl (a = x))

theorem single_mul_apply_aux {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] (f : monoid_algebra k G) {r : k} {x : G} {y : G} {z : G} (H : ∀ (a : G), x * a = y ↔ a = z) : coe_fn (finsupp.single x r * f) y = r * coe_fn f z := sorry

theorem single_one_mul_apply {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] (f : monoid_algebra k G) (r : k) (x : G) : coe_fn (finsupp.single 1 r * f) x = r * coe_fn f x :=
  single_mul_apply_aux f
    fun (a : G) => eq.mpr (id (Eq._oldrec (Eq.refl (1 * a = x ↔ a = x)) (one_mul a))) (iff.refl (a = x))

theorem lift_nc_smul {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] {R : Type u_1} [semiring R] (f : k →+* R) (g : G →* R) (c : k) (φ : monoid_algebra k G) : coe_fn (lift_nc (↑f) g) (c • φ) = coe_fn f c * coe_fn (lift_nc (↑f) g) φ := sorry

/-! #### Algebra structure -/

theorem single_one_comm {k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] (r : k) (f : monoid_algebra k G) : finsupp.single 1 r * f = f * finsupp.single 1 r := sorry

/-- `finsupp.single 1` as a `ring_hom` -/
def single_one_ring_hom {k : Type u₁} {G : Type u₂} [semiring k] [monoid G] : k →+* monoid_algebra k G :=
  ring_hom.mk (add_monoid_hom.to_fun (finsupp.single_add_hom 1)) sorry sorry sorry sorry

/-- If two ring homomorphisms from `monoid_algebra k G` are equal on all `single a 1`
and `single 1 b`, then they are equal. -/
theorem ring_hom_ext {k : Type u₁} {G : Type u₂} {R : Type u_1} [semiring k] [monoid G] [semiring R] {f : monoid_algebra k G →+* R} {g : monoid_algebra k G →+* R} (h₁ : ∀ (b : k), coe_fn f (finsupp.single 1 b) = coe_fn g (finsupp.single 1 b)) (h_of : ∀ (a : G), coe_fn f (finsupp.single a 1) = coe_fn g (finsupp.single a 1)) : f = g := sorry

/-- If two ring homomorphisms from `monoid_algebra k G` are equal on all `single a 1`
and `single 1 b`, then they are equal.

See note [partially-applied ext lemmas]. -/
theorem ring_hom_ext' {k : Type u₁} {G : Type u₂} {R : Type u_1} [semiring k] [monoid G] [semiring R] {f : monoid_algebra k G →+* R} {g : monoid_algebra k G →+* R} (h₁ : ring_hom.comp f single_one_ring_hom = ring_hom.comp g single_one_ring_hom) (h_of : monoid_hom.comp (↑f) (of k G) = monoid_hom.comp (↑g) (of k G)) : f = g :=
  ring_hom_ext (ring_hom.congr_fun h₁) (monoid_hom.congr_fun h_of)

/--
The instance `algebra k (monoid_algebra A G)` whenever we have `algebra k A`.

In particular this provides the instance `algebra k (monoid_algebra k G)`.
-/
protected instance algebra {k : Type u₁} {G : Type u₂} {A : Type u_1} [comm_semiring k] [semiring A] [algebra k A] [monoid G] : algebra k (monoid_algebra A G) :=
  algebra.mk (ring_hom.mk (ring_hom.to_fun (ring_hom.comp single_one_ring_hom (algebra_map k A))) sorry sorry sorry sorry)
    sorry sorry

/-- `finsupp.single 1` as a `alg_hom` -/
def single_one_alg_hom {k : Type u₁} {G : Type u₂} {A : Type u_1} [comm_semiring k] [semiring A] [algebra k A] [monoid G] : alg_hom k A (monoid_algebra A G) :=
  alg_hom.mk (ring_hom.to_fun single_one_ring_hom) sorry sorry sorry sorry sorry

@[simp] theorem coe_algebra_map {k : Type u₁} {G : Type u₂} {A : Type u_1} [comm_semiring k] [semiring A] [algebra k A] [monoid G] : ⇑(algebra_map k (monoid_algebra A G)) = finsupp.single 1 ∘ ⇑(algebra_map k A) :=
  rfl

theorem single_eq_algebra_map_mul_of {k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] (a : G) (b : k) : finsupp.single a b = coe_fn (algebra_map k (monoid_algebra k G)) b * coe_fn (of k G) a := sorry

theorem single_algebra_map_eq_algebra_map_mul_of {k : Type u₁} {G : Type u₂} {A : Type u_1} [comm_semiring k] [semiring A] [algebra k A] [monoid G] (a : G) (b : k) : finsupp.single a (coe_fn (algebra_map k A) b) = coe_fn (algebra_map k (monoid_algebra A G)) b * coe_fn (of A G) a := sorry

/-- `lift_nc_ring_hom` as a `alg_hom`, for when `f` is an `alg_hom` -/
def lift_nc_alg_hom {k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] {A : Type u₃} [semiring A] [algebra k A] {B : Type u_1} [semiring B] [algebra k B] (f : alg_hom k A B) (g : G →* B) (h_comm : ∀ (x : A) (y : G), commute (coe_fn f x) (coe_fn g y)) : alg_hom k (monoid_algebra A G) B :=
  alg_hom.mk ⇑(lift_nc_ring_hom (↑f) g h_comm) sorry sorry sorry sorry sorry

/-- A `k`-algebra homomorphism from `monoid_algebra k G` is uniquely defined by its
values on the functions `single a 1`. -/
theorem alg_hom_ext {k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] {A : Type u₃} [semiring A] [algebra k A] {φ₁ : alg_hom k (monoid_algebra k G) A} {φ₂ : alg_hom k (monoid_algebra k G) A} (h : ∀ (x : G), coe_fn φ₁ (finsupp.single x 1) = coe_fn φ₂ (finsupp.single x 1)) : φ₁ = φ₂ :=
  alg_hom.to_linear_map_inj (finsupp.lhom_ext' fun (a : G) => linear_map.ext_ring (h a))

/-- See note [partially-applied ext lemmas]. -/
theorem alg_hom_ext' {k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] {A : Type u₃} [semiring A] [algebra k A] {φ₁ : alg_hom k (monoid_algebra k G) A} {φ₂ : alg_hom k (monoid_algebra k G) A} (h : monoid_hom.comp (↑φ₁) (of k G) = monoid_hom.comp (↑φ₂) (of k G)) : φ₁ = φ₂ :=
  alg_hom_ext (monoid_hom.congr_fun h)

/-- Any monoid homomorphism `G →* A` can be lifted to an algebra homomorphism
`monoid_algebra k G →ₐ[k] A`. -/
def lift (k : Type u₁) (G : Type u₂) [comm_semiring k] [monoid G] (A : Type u₃) [semiring A] [algebra k A] : (G →* A) ≃ alg_hom k (monoid_algebra k G) A :=
  equiv.mk (fun (F : G →* A) => lift_nc_alg_hom (algebra.of_id k A) F sorry)
    (fun (f : alg_hom k (monoid_algebra k G) A) => monoid_hom.comp (↑f) (of k G)) sorry sorry

theorem lift_apply' {k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : G →* A) (f : monoid_algebra k G) : coe_fn (coe_fn (lift k G A) F) f = finsupp.sum f fun (a : G) (b : k) => coe_fn (algebra_map k A) b * coe_fn F a :=
  rfl

theorem lift_apply {k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : G →* A) (f : monoid_algebra k G) : coe_fn (coe_fn (lift k G A) F) f = finsupp.sum f fun (a : G) (b : k) => b • coe_fn F a := sorry

theorem lift_def {k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : G →* A) : ⇑(coe_fn (lift k G A) F) = ⇑(lift_nc (↑(algebra_map k A)) F) :=
  rfl

@[simp] theorem lift_symm_apply {k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : alg_hom k (monoid_algebra k G) A) (x : G) : coe_fn (coe_fn (equiv.symm (lift k G A)) F) x = coe_fn F (finsupp.single x 1) :=
  rfl

theorem lift_of {k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : G →* A) (x : G) : coe_fn (coe_fn (lift k G A) F) (coe_fn (of k G) x) = coe_fn F x := sorry

@[simp] theorem lift_single {k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : G →* A) (a : G) (b : k) : coe_fn (coe_fn (lift k G A) F) (finsupp.single a b) = b • coe_fn F a := sorry

theorem lift_unique' {k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : alg_hom k (monoid_algebra k G) A) : F = coe_fn (lift k G A) (monoid_hom.comp (↑F) (of k G)) :=
  Eq.symm (equiv.apply_symm_apply (lift k G A) F)

/-- Decomposition of a `k`-algebra homomorphism from `monoid_algebra k G` by
its values on `F (single a 1)`. -/
theorem lift_unique {k : Type u₁} {G : Type u₂} [comm_semiring k] [monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : alg_hom k (monoid_algebra k G) A) (f : monoid_algebra k G) : coe_fn F f = finsupp.sum f fun (a : G) (b : k) => b • coe_fn F (finsupp.single a 1) := sorry

/-- When `V` is a `k[G]`-module, multiplication by a group element `g` is a `k`-linear map. -/
def group_smul.linear_map (k : Type u₁) {G : Type u₂} [monoid G] [comm_semiring k] (V : Type u₃) [add_comm_monoid V] [semimodule k V] [semimodule (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] (g : G) : linear_map k V V :=
  linear_map.mk (fun (v : V) => finsupp.single g 1 • v) sorry sorry

@[simp] theorem group_smul.linear_map_apply (k : Type u₁) {G : Type u₂} [monoid G] [comm_semiring k] (V : Type u₃) [add_comm_monoid V] [semimodule k V] [semimodule (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] (g : G) (v : V) : coe_fn (group_smul.linear_map k V g) v = finsupp.single g 1 • v :=
  rfl

/-- Build a `k[G]`-linear map from a `k`-linear map and evidence that it is `G`-equivariant. -/
def equivariant_of_linear_of_comm {k : Type u₁} {G : Type u₂} [monoid G] [comm_semiring k] {V : Type u₃} {W : Type u₃} [add_comm_monoid V] [semimodule k V] [semimodule (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] [add_comm_monoid W] [semimodule k W] [semimodule (monoid_algebra k G) W] [is_scalar_tower k (monoid_algebra k G) W] (f : linear_map k V W) (h : ∀ (g : G) (v : V), coe_fn f (finsupp.single g 1 • v) = finsupp.single g 1 • coe_fn f v) : linear_map (monoid_algebra k G) V W :=
  linear_map.mk ⇑f sorry sorry

@[simp] theorem equivariant_of_linear_of_comm_apply {k : Type u₁} {G : Type u₂} [monoid G] [comm_semiring k] {V : Type u₃} {W : Type u₃} [add_comm_monoid V] [semimodule k V] [semimodule (monoid_algebra k G) V] [is_scalar_tower k (monoid_algebra k G) V] [add_comm_monoid W] [semimodule k W] [semimodule (monoid_algebra k G) W] [is_scalar_tower k (monoid_algebra k G) W] (f : linear_map k V W) (h : ∀ (g : G) (v : V), coe_fn f (finsupp.single g 1 • v) = finsupp.single g 1 • coe_fn f v) (v : V) : coe_fn (equivariant_of_linear_of_comm f h) v = coe_fn f v :=
  rfl

theorem prod_single {k : Type u₁} {G : Type u₂} {ι : Type ui} [comm_semiring k] [comm_monoid G] {s : finset ι} {a : ι → G} {b : ι → k} : (finset.prod s fun (i : ι) => finsupp.single (a i) (b i)) =
  finsupp.single (finset.prod s fun (i : ι) => a i) (finset.prod s fun (i : ι) => b i) := sorry

@[simp] theorem mul_single_apply {k : Type u₁} {G : Type u₂} [semiring k] [group G] (f : monoid_algebra k G) (r : k) (x : G) (y : G) : coe_fn (f * finsupp.single x r) y = coe_fn f (y * (x⁻¹)) * r :=
  mul_single_apply_aux f fun (a : G) => iff.symm eq_mul_inv_iff_mul_eq

@[simp] theorem single_mul_apply {k : Type u₁} {G : Type u₂} [semiring k] [group G] (r : k) (x : G) (f : monoid_algebra k G) (y : G) : coe_fn (finsupp.single x r * f) y = r * coe_fn f (x⁻¹ * y) :=
  single_mul_apply_aux f fun (z : G) => iff.symm eq_inv_mul_iff_mul_eq

theorem mul_apply_left {k : Type u₁} {G : Type u₂} [semiring k] [group G] (f : monoid_algebra k G) (g : monoid_algebra k G) (x : G) : coe_fn (f * g) x = finsupp.sum f fun (a : G) (b : k) => b * coe_fn g (a⁻¹ * x) := sorry

-- If we'd assumed `comm_semiring`, we could deduce this from `mul_apply_left`.

theorem mul_apply_right {k : Type u₁} {G : Type u₂} [semiring k] [group G] (f : monoid_algebra k G) (g : monoid_algebra k G) (x : G) : coe_fn (f * g) x = finsupp.sum g fun (a : G) (b : k) => coe_fn f (x * (a⁻¹)) * b := sorry

end monoid_algebra


/-! ### Additive monoids -/

/--
The monoid algebra over a semiring `k` generated by the additive monoid `G`.
It is the type of finite formal `k`-linear combinations of terms of `G`,
endowed with the convolution product.
-/
def add_monoid_algebra (k : Type u₁) (G : Type u₂) [semiring k]  :=
  G →₀ k

namespace add_monoid_algebra


/-! #### Semiring structure -/

/-- The product of `f g : add_monoid_algebra k G` is the finitely supported function
  whose value at `a` is the sum of `f x * g y` over all pairs `x, y`
  such that `x + y = a`. (Think of the product of multivariate
  polynomials where `α` is the additive monoid of monomial exponents.) -/
protected instance has_mul {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] : Mul (add_monoid_algebra k G) :=
  { mul :=
      fun (f g : add_monoid_algebra k G) =>
        finsupp.sum f fun (a₁ : G) (b₁ : k) => finsupp.sum g fun (a₂ : G) (b₂ : k) => finsupp.single (a₁ + a₂) (b₁ * b₂) }

theorem mul_def {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] {f : add_monoid_algebra k G} {g : add_monoid_algebra k G} : f * g = finsupp.sum f fun (a₁ : G) (b₁ : k) => finsupp.sum g fun (a₂ : G) (b₂ : k) => finsupp.single (a₁ + a₂) (b₁ * b₂) :=
  rfl

/-- The unit of the multiplication is `single 1 1`, i.e. the function
  that is `1` at `0` and zero elsewhere. -/
protected instance has_one {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] : HasOne (add_monoid_algebra k G) :=
  { one := finsupp.single 0 1 }

theorem one_def {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] : 1 = finsupp.single 0 1 :=
  rfl

protected instance semiring {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] : semiring (add_monoid_algebra k G) :=
  semiring.mk Add.add sorry 0 sorry sorry sorry Mul.mul sorry 1 sorry sorry sorry sorry sorry sorry

/-- A non-commutative version of `add_monoid_algebra.lift`: given a additive homomorphism `f : k →+
R` and a multiplicative monoid homomorphism `g : multiplicative G →* R`, returns the additive
homomorphism from `add_monoid_algebra k G` such that `lift_nc f g (single a b) = f b * g a`. If `f`
is a ring homomorphism and the range of either `f` or `g` is in center of `R`, then the result is a
ring homomorphism.  If `R` is a `k`-algebra and `f = algebra_map k R`, then the result is an algebra
homomorphism called `add_monoid_algebra.lift`. -/
def lift_nc {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] {R : Type u_1} [semiring R] (f : k →+ R) (g : multiplicative G →* R) : add_monoid_algebra k G →+ R :=
  coe_fn finsupp.lift_add_hom
    fun (x : G) => add_monoid_hom.comp (add_monoid_hom.mul_right (coe_fn g (coe_fn multiplicative.of_add x))) f

@[simp] theorem lift_nc_single {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] {R : Type u_1} [semiring R] (f : k →+ R) (g : multiplicative G →* R) (a : G) (b : k) : coe_fn (lift_nc f g) (finsupp.single a b) = coe_fn f b * coe_fn g (coe_fn multiplicative.of_add a) :=
  finsupp.lift_add_hom_apply_single
    (fun (x : G) => add_monoid_hom.comp (add_monoid_hom.mul_right (coe_fn g (coe_fn multiplicative.of_add x))) f) a b

@[simp] theorem lift_nc_one {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] {R : Type u_1} [semiring R] (f : k →+* R) (g : multiplicative G →* R) : coe_fn (lift_nc (↑f) g) 1 = 1 :=
  monoid_algebra.lift_nc_one f g

theorem lift_nc_mul {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] {R : Type u_1} [semiring R] (f : k →+* R) (g : multiplicative G →* R) (a : add_monoid_algebra k G) (b : add_monoid_algebra k G) (h_comm : ∀ {x y : G}, y ∈ finsupp.support a → commute (coe_fn f (coe_fn b x)) (coe_fn g (coe_fn multiplicative.of_add y))) : coe_fn (lift_nc (↑f) g) (a * b) = coe_fn (lift_nc (↑f) g) a * coe_fn (lift_nc (↑f) g) b :=
  monoid_algebra.lift_nc_mul f g a b h_comm

/-- `lift_nc` as a `ring_hom`, for when `f` and `g` commute -/
def lift_nc_ring_hom {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] {R : Type u_1} [semiring R] (f : k →+* R) (g : multiplicative G →* R) (h_comm : ∀ (x : k) (y : multiplicative G), commute (coe_fn f x) (coe_fn g y)) : add_monoid_algebra k G →+* R :=
  ring_hom.mk (⇑(lift_nc (↑f) g)) (lift_nc_one f g) sorry sorry sorry

protected instance comm_semiring {k : Type u₁} {G : Type u₂} [comm_semiring k] [add_comm_monoid G] : comm_semiring (add_monoid_algebra k G) :=
  comm_semiring.mk semiring.add sorry semiring.zero sorry sorry sorry semiring.mul sorry semiring.one sorry sorry sorry
    sorry sorry sorry sorry

protected instance nontrivial {k : Type u₁} {G : Type u₂} [semiring k] [nontrivial k] [add_monoid G] : nontrivial (add_monoid_algebra k G) :=
  finsupp.nontrivial

/-! #### Derived instances -/

protected instance unique {k : Type u₁} {G : Type u₂} [semiring k] [subsingleton k] : unique (add_monoid_algebra k G) :=
  finsupp.unique_of_right

protected instance add_group {k : Type u₁} {G : Type u₂} [ring k] : add_group (add_monoid_algebra k G) :=
  finsupp.add_group

protected instance ring {k : Type u₁} {G : Type u₂} [ring k] [add_monoid G] : ring (add_monoid_algebra k G) :=
  ring.mk semiring.add sorry semiring.zero sorry sorry Neg.neg Sub.sub sorry sorry semiring.mul sorry semiring.one sorry
    sorry sorry sorry

protected instance comm_ring {k : Type u₁} {G : Type u₂} [comm_ring k] [add_comm_monoid G] : comm_ring (add_monoid_algebra k G) :=
  comm_ring.mk ring.add sorry ring.zero sorry sorry ring.neg ring.sub sorry sorry ring.mul sorry ring.one sorry sorry
    sorry sorry sorry

protected instance has_scalar {k : Type u₁} {G : Type u₂} {R : Type u_1} [semiring R] [semiring k] [semimodule R k] : has_scalar R (add_monoid_algebra k G) :=
  finsupp.has_scalar

protected instance semimodule {k : Type u₁} {G : Type u₂} {R : Type u_1} [semiring R] [semiring k] [semimodule R k] : semimodule R (add_monoid_algebra k G) :=
  finsupp.semimodule G k

/-! It is hard to state the equivalent of `distrib_mul_action G (add_monoid_algebra k G)`
because we've never discussed actions of additive groups. -/

theorem mul_apply {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] (f : add_monoid_algebra k G) (g : add_monoid_algebra k G) (x : G) : coe_fn (f * g) x =
  finsupp.sum f fun (a₁ : G) (b₁ : k) => finsupp.sum g fun (a₂ : G) (b₂ : k) => ite (a₁ + a₂ = x) (b₁ * b₂) 0 :=
  monoid_algebra.mul_apply f g x

theorem mul_apply_antidiagonal {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] (f : add_monoid_algebra k G) (g : add_monoid_algebra k G) (x : G) (s : finset (G × G)) (hs : ∀ {p : G × G}, p ∈ s ↔ prod.fst p + prod.snd p = x) : coe_fn (f * g) x = finset.sum s fun (p : G × G) => coe_fn f (prod.fst p) * coe_fn g (prod.snd p) :=
  monoid_algebra.mul_apply_antidiagonal f g x s hs

theorem support_mul {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] (a : add_monoid_algebra k G) (b : add_monoid_algebra k G) : finsupp.support (a * b) ⊆
  finset.bUnion (finsupp.support a)
    fun (a₁ : G) => finset.bUnion (finsupp.support b) fun (a₂ : G) => singleton (a₁ + a₂) :=
  monoid_algebra.support_mul a b

theorem single_mul_single {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] {a₁ : G} {a₂ : G} {b₁ : k} {b₂ : k} : finsupp.single a₁ b₁ * finsupp.single a₂ b₂ = finsupp.single (a₁ + a₂) (b₁ * b₂) :=
  monoid_algebra.single_mul_single

/-- Like `finsupp.map_domain_add`, but for the convolutive multiplication we define in this file -/
theorem map_domain_mul {α : Type u_1} {β : Type u_2} {α₂ : Type u_3} [semiring β] [add_monoid α] [add_monoid α₂] {x : add_monoid_algebra β α} {y : add_monoid_algebra β α} (f : add_hom α α₂) : finsupp.map_domain (⇑f) (x * y) = finsupp.map_domain (⇑f) x * finsupp.map_domain (⇑f) y := sorry

/-- Embedding of a monoid into its monoid algebra. -/
def of (k : Type u₁) (G : Type u₂) [semiring k] [add_monoid G] : multiplicative G →* add_monoid_algebra k G :=
  monoid_hom.mk (fun (a : multiplicative G) => finsupp.single a 1) sorry sorry

@[simp] theorem of_apply {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] (a : multiplicative G) : coe_fn (of k G) a = finsupp.single (coe_fn multiplicative.to_add a) 1 :=
  rfl

theorem of_injective {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] [nontrivial k] : function.injective ⇑(of k G) := sorry

theorem mul_single_apply_aux {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] (f : add_monoid_algebra k G) (r : k) (x : G) (y : G) (z : G) (H : ∀ (a : G), a + x = z ↔ a = y) : coe_fn (f * finsupp.single x r) z = coe_fn f y * r :=
  monoid_algebra.mul_single_apply_aux f H

theorem mul_single_zero_apply {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] (f : add_monoid_algebra k G) (r : k) (x : G) : coe_fn (f * finsupp.single 0 r) x = coe_fn f x * r :=
  mul_single_apply_aux f r 0 x x
    fun (a : G) => eq.mpr (id (Eq._oldrec (Eq.refl (a + 0 = x ↔ a = x)) (add_zero a))) (iff.refl (a = x))

theorem single_mul_apply_aux {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] (f : add_monoid_algebra k G) (r : k) (x : G) (y : G) (z : G) (H : ∀ (a : G), x + a = y ↔ a = z) : coe_fn (finsupp.single x r * f) y = r * coe_fn f z :=
  monoid_algebra.single_mul_apply_aux f H

theorem single_zero_mul_apply {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] (f : add_monoid_algebra k G) (r : k) (x : G) : coe_fn (finsupp.single 0 r * f) x = r * coe_fn f x :=
  single_mul_apply_aux f r 0 x x
    fun (a : G) => eq.mpr (id (Eq._oldrec (Eq.refl (0 + a = x ↔ a = x)) (zero_add a))) (iff.refl (a = x))

theorem lift_nc_smul {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] {R : Type u_1} [semiring R] (f : k →+* R) (g : multiplicative G →* R) (c : k) (φ : monoid_algebra k G) : coe_fn (lift_nc (↑f) g) (c • φ) = coe_fn f c * coe_fn (lift_nc (↑f) g) φ :=
  monoid_algebra.lift_nc_smul f g c φ

end add_monoid_algebra


/-!
#### Conversions between `add_monoid_algebra` and `monoid_algebra`

While we were not able to define `add_monoid_algebra k G = monoid_algebra k (multiplicative G)` due
to definitional inconveniences, we can still show the types are isomorphic.
-/

/-- The equivalence between `add_monoid_algebra` and `monoid_algebra` in terms of
`multiplicative` -/
protected def add_monoid_algebra.to_multiplicative (k : Type u₁) (G : Type u₂) [semiring k] [add_monoid G] : add_monoid_algebra k G ≃+* monoid_algebra k (multiplicative G) :=
  ring_equiv.mk (add_equiv.to_fun (finsupp.dom_congr multiplicative.of_add))
    (add_equiv.inv_fun (finsupp.dom_congr multiplicative.of_add)) sorry sorry sorry sorry

/-- The equivalence between `monoid_algebra` and `add_monoid_algebra` in terms of `additive` -/
protected def monoid_algebra.to_additive (k : Type u₁) (G : Type u₂) [semiring k] [monoid G] : monoid_algebra k G ≃+* add_monoid_algebra k (additive G) :=
  ring_equiv.mk (add_equiv.to_fun (finsupp.dom_congr additive.of_mul))
    (add_equiv.inv_fun (finsupp.dom_congr additive.of_mul)) sorry sorry sorry sorry

namespace add_monoid_algebra


/-! #### Algebra structure -/

/-- `finsupp.single 0` as a `ring_hom` -/
@[simp] theorem single_zero_ring_hom_apply {k : Type u₁} {G : Type u₂} [semiring k] [add_monoid G] : ∀ (ᾰ : k), coe_fn single_zero_ring_hom ᾰ = add_monoid_hom.to_fun (finsupp.single_add_hom 0) ᾰ :=
  fun (ᾰ : k) => Eq.refl (coe_fn single_zero_ring_hom ᾰ)

/-- If two ring homomorphisms from `add_monoid_algebra k G` are equal on all `single a 1`
and `single 0 b`, then they are equal. -/
theorem ring_hom_ext {k : Type u₁} {G : Type u₂} {R : Type u_1} [semiring k] [add_monoid G] [semiring R] {f : add_monoid_algebra k G →+* R} {g : add_monoid_algebra k G →+* R} (h₀ : ∀ (b : k), coe_fn f (finsupp.single 0 b) = coe_fn g (finsupp.single 0 b)) (h_of : ∀ (a : G), coe_fn f (finsupp.single a 1) = coe_fn g (finsupp.single a 1)) : f = g :=
  monoid_algebra.ring_hom_ext h₀ h_of

/-- If two ring homomorphisms from `add_monoid_algebra k G` are equal on all `single a 1`
and `single 0 b`, then they are equal.

See note [partially-applied ext lemmas]. -/
theorem ring_hom_ext' {k : Type u₁} {G : Type u₂} {R : Type u_1} [semiring k] [add_monoid G] [semiring R] {f : add_monoid_algebra k G →+* R} {g : add_monoid_algebra k G →+* R} (h₁ : ring_hom.comp f single_zero_ring_hom = ring_hom.comp g single_zero_ring_hom) (h_of : monoid_hom.comp (↑f) (of k G) = monoid_hom.comp (↑g) (of k G)) : f = g :=
  ring_hom_ext (ring_hom.congr_fun h₁) (monoid_hom.congr_fun h_of)

/--
The instance `algebra R (add_monoid_algebra k G)` whenever we have `algebra R k`.

In particular this provides the instance `algebra k (add_monoid_algebra k G)`.
-/
protected instance algebra {k : Type u₁} {G : Type u₂} {R : Type u_1} [comm_semiring R] [semiring k] [algebra R k] [add_monoid G] : algebra R (add_monoid_algebra k G) :=
  algebra.mk
    (ring_hom.mk (ring_hom.to_fun (ring_hom.comp single_zero_ring_hom (algebra_map R k))) sorry sorry sorry sorry) sorry
    sorry

/-- `finsupp.single 0` as a `alg_hom` -/
def single_zero_alg_hom {k : Type u₁} {G : Type u₂} {R : Type u_1} [comm_semiring R] [semiring k] [algebra R k] [add_monoid G] : alg_hom R k (add_monoid_algebra k G) :=
  alg_hom.mk (ring_hom.to_fun single_zero_ring_hom) sorry sorry sorry sorry sorry

@[simp] theorem coe_algebra_map {k : Type u₁} {G : Type u₂} {R : Type u_1} [comm_semiring R] [semiring k] [algebra R k] [add_monoid G] : ⇑(algebra_map R (add_monoid_algebra k G)) = finsupp.single 0 ∘ ⇑(algebra_map R k) :=
  rfl

/-- `lift_nc_ring_hom` as a `alg_hom`, for when `f` is an `alg_hom` -/
def lift_nc_alg_hom {k : Type u₁} {G : Type u₂} [comm_semiring k] [add_monoid G] {A : Type u₃} [semiring A] [algebra k A] {B : Type u_1} [semiring B] [algebra k B] (f : alg_hom k A B) (g : multiplicative G →* B) (h_comm : ∀ (x : A) (y : multiplicative G), commute (coe_fn f x) (coe_fn g y)) : alg_hom k (add_monoid_algebra A G) B :=
  alg_hom.mk ⇑(lift_nc_ring_hom (↑f) g h_comm) sorry sorry sorry sorry sorry

/-- A `k`-algebra homomorphism from `monoid_algebra k G` is uniquely defined by its
values on the functions `single a 1`. -/
theorem alg_hom_ext {k : Type u₁} {G : Type u₂} [comm_semiring k] [add_monoid G] {A : Type u₃} [semiring A] [algebra k A] {φ₁ : alg_hom k (add_monoid_algebra k G) A} {φ₂ : alg_hom k (add_monoid_algebra k G) A} (h : ∀ (x : G), coe_fn φ₁ (finsupp.single x 1) = coe_fn φ₂ (finsupp.single x 1)) : φ₁ = φ₂ :=
  monoid_algebra.alg_hom_ext h

/-- See note [partially-applied ext lemmas]. -/
theorem alg_hom_ext' {k : Type u₁} {G : Type u₂} [comm_semiring k] [add_monoid G] {A : Type u₃} [semiring A] [algebra k A] {φ₁ : alg_hom k (add_monoid_algebra k G) A} {φ₂ : alg_hom k (add_monoid_algebra k G) A} (h : monoid_hom.comp (↑φ₁) (of k G) = monoid_hom.comp (↑φ₂) (of k G)) : φ₁ = φ₂ :=
  alg_hom_ext (monoid_hom.congr_fun h)

/-- Any monoid homomorphism `G →* A` can be lifted to an algebra homomorphism
`monoid_algebra k G →ₐ[k] A`. -/
def lift (k : Type u₁) (G : Type u₂) [comm_semiring k] [add_monoid G] (A : Type u₃) [semiring A] [algebra k A] : (multiplicative G →* A) ≃ alg_hom k (add_monoid_algebra k G) A :=
  equiv.mk
    (fun (F : multiplicative G →* A) =>
      alg_hom.mk ⇑(lift_nc_alg_hom (algebra.of_id k A) F sorry) sorry sorry sorry sorry sorry)
    (fun (f : alg_hom k (add_monoid_algebra k G) A) => monoid_hom.comp (↑f) (of k G)) sorry sorry

theorem lift_apply' {k : Type u₁} {G : Type u₂} [comm_semiring k] [add_monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : multiplicative G →* A) (f : monoid_algebra k G) : coe_fn (coe_fn (lift k G A) F) f =
  finsupp.sum f fun (a : G) (b : k) => coe_fn (algebra_map k A) b * coe_fn F (coe_fn multiplicative.of_add a) :=
  rfl

theorem lift_apply {k : Type u₁} {G : Type u₂} [comm_semiring k] [add_monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : multiplicative G →* A) (f : monoid_algebra k G) : coe_fn (coe_fn (lift k G A) F) f = finsupp.sum f fun (a : G) (b : k) => b • coe_fn F (coe_fn multiplicative.of_add a) := sorry

theorem lift_def {k : Type u₁} {G : Type u₂} [comm_semiring k] [add_monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : multiplicative G →* A) : ⇑(coe_fn (lift k G A) F) = ⇑(lift_nc (↑(algebra_map k A)) F) :=
  rfl

@[simp] theorem lift_symm_apply {k : Type u₁} {G : Type u₂} [comm_semiring k] [add_monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : alg_hom k (add_monoid_algebra k G) A) (x : multiplicative G) : coe_fn (coe_fn (equiv.symm (lift k G A)) F) x = coe_fn F (finsupp.single (coe_fn multiplicative.to_add x) 1) :=
  rfl

theorem lift_of {k : Type u₁} {G : Type u₂} [comm_semiring k] [add_monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : multiplicative G →* A) (x : multiplicative G) : coe_fn (coe_fn (lift k G A) F) (coe_fn (of k G) x) = coe_fn F x := sorry

@[simp] theorem lift_single {k : Type u₁} {G : Type u₂} [comm_semiring k] [add_monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : multiplicative G →* A) (a : G) (b : k) : coe_fn (coe_fn (lift k G A) F) (finsupp.single a b) = b • coe_fn F (coe_fn multiplicative.of_add a) := sorry

theorem lift_unique' {k : Type u₁} {G : Type u₂} [comm_semiring k] [add_monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : alg_hom k (add_monoid_algebra k G) A) : F = coe_fn (lift k G A) (monoid_hom.comp (↑F) (of k G)) :=
  Eq.symm (equiv.apply_symm_apply (lift k G A) F)

/-- Decomposition of a `k`-algebra homomorphism from `monoid_algebra k G` by
its values on `F (single a 1)`. -/
theorem lift_unique {k : Type u₁} {G : Type u₂} [comm_semiring k] [add_monoid G] {A : Type u₃} [semiring A] [algebra k A] (F : alg_hom k (add_monoid_algebra k G) A) (f : monoid_algebra k G) : coe_fn F f = finsupp.sum f fun (a : G) (b : k) => b • coe_fn F (finsupp.single a 1) := sorry

theorem alg_hom_ext_iff {k : Type u₁} {G : Type u₂} [comm_semiring k] [add_monoid G] {A : Type u₃} [semiring A] [algebra k A] {φ₁ : alg_hom k (add_monoid_algebra k G) A} {φ₂ : alg_hom k (add_monoid_algebra k G) A} : (∀ (x : G), coe_fn φ₁ (finsupp.single x 1) = coe_fn φ₂ (finsupp.single x 1)) ↔ φ₁ = φ₂ :=
  { mp := fun (h : ∀ (x : G), coe_fn φ₁ (finsupp.single x 1) = coe_fn φ₂ (finsupp.single x 1)) => alg_hom_ext h,
    mpr := fun (ᾰ : φ₁ = φ₂) (x : G) => Eq._oldrec (Eq.refl (coe_fn φ₁ (finsupp.single x 1))) ᾰ }

theorem prod_single {k : Type u₁} {G : Type u₂} {ι : Type ui} [comm_semiring k] [add_comm_monoid G] {s : finset ι} {a : ι → G} {b : ι → k} : (finset.prod s fun (i : ι) => finsupp.single (a i) (b i)) =
  finsupp.single (finset.sum s fun (i : ι) => a i) (finset.prod s fun (i : ι) => b i) := sorry

