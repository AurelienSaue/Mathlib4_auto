/-
Copyright (c) 2019 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Johan Commelin
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.group_theory.free_abelian_group
import Mathlib.ring_theory.subring
import Mathlib.PostPort

universes u v 

namespace Mathlib

/-!
# Free rings

The theory of the free ring over a type.

## Main definitions

* `free_ring α` : the free (not commutative in general) ring over a type.
* `lift (f : α → R)` : the ring hom `free_ring α →+* R` induced by `f`.
* `map (f : α → β)` : the ring hom `free_ring α →+* free_ring β` induced by `f`.

## Implementation details

`free_ring α` is implemented as the free abelian group over the free monoid on `α`.

## Tags

free ring

-/

/-- The free ring over a type `α`. -/
def free_ring (α : Type u) :=
  free_abelian_group (free_monoid α)

namespace free_ring


protected instance ring (α : Type u) : ring (free_ring α) :=
  free_abelian_group.ring (free_monoid α)

protected instance inhabited (α : Type u) : Inhabited (free_ring α) :=
  { default := 0 }

/-- The canonical map from α to `free_ring α`. -/
def of {α : Type u} (x : α) : free_ring α :=
  free_abelian_group.of [x]

theorem of_injective {α : Type u} : function.injective of :=
  function.injective.comp free_abelian_group.of_injective free_monoid.of_injective

protected theorem induction_on {α : Type u} {C : free_ring α → Prop} (z : free_ring α) (hn1 : C (-1)) (hb : ∀ (b : α), C (of b)) (ha : ∀ (x y : free_ring α), C x → C y → C (x + y)) (hm : ∀ (x y : free_ring α), C x → C y → C (x * y)) : C z := sorry

/-- The ring homomorphism `free_ring α →+* R` induced from a map `α → R`. -/
def lift {α : Type u} {R : Type v} [ring R] (f : α → R) : free_ring α →+* R :=
  ring_hom.mk (add_monoid_hom.to_fun (free_abelian_group.lift fun (L : List α) => list.prod (list.map f L))) sorry sorry
    sorry sorry

@[simp] theorem lift_of {α : Type u} {R : Type v} [ring R] (f : α → R) (x : α) : coe_fn (lift f) (of x) = f x :=
  Eq.trans (free_abelian_group.lift.of (fun (L : List α) => list.prod (list.map f L)) [x]) (one_mul (f x))

@[simp] theorem lift_comp_of {α : Type u} {R : Type v} [ring R] (f : free_ring α →+* R) : lift (⇑f ∘ of) = f := sorry

/-- The canonical ring homomorphism `free_ring α →+* free_ring β` generated by a map `α → β`. -/
def map {α : Type u} {β : Type v} (f : α → β) : free_ring α →+* free_ring β :=
  lift (of ∘ f)

@[simp] theorem map_of {α : Type u} {β : Type v} (f : α → β) (x : α) : coe_fn (map f) (of x) = of (f x) :=
  lift_of (of ∘ f) x

