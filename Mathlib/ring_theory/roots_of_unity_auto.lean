/-
Copyright (c) 2020 Johan Commelin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.data.nat.parity
import Mathlib.data.polynomial.ring_division
import Mathlib.group_theory.order_of_element
import Mathlib.ring_theory.integral_domain
import Mathlib.number_theory.divisors
import Mathlib.data.zmod.basic
import Mathlib.tactic.zify
import Mathlib.field_theory.separable
import Mathlib.field_theory.finite.basic
import Mathlib.PostPort

universes u_1 u_2 u_5 l u_3 u_4 u_7 

namespace Mathlib

/-!
# Roots of unity and primitive roots of unity

We define roots of unity in the context of an arbitrary commutative monoid,
as a subgroup of the group of units. We also define a predicate `is_primitive_root` on commutative
monoids, expressing that an element is a primitive root of unity.

## Main definitions

* `roots_of_unity n M`, for `n : ℕ+` is the subgroup of the units of a commutative monoid `M`
  consisting of elements `x` that satisfy `x ^ n = 1`.
* `is_primitive_root ζ k`: an element `ζ` is a primitive `k`-th root of unity if `ζ ^ k = 1`,
  and if `l` satisfies `ζ ^ l = 1` then `k ∣ l`.
* `primitive_roots k R`: the finset of primitive `k`-th roots of unity in an integral domain `R`.

## Main results

* `roots_of_unity.is_cyclic`: the roots of unity in an integral domain form a cyclic group.
* `is_primitive_root.zmod_equiv_gpowers`: `zmod k` is equivalent to
  the subgroup generated by a primitive `k`-th root of unity.
* `is_primitive_root.gpowers_eq`: in an integral domain, the subgroup generated by
  a primitive `k`-th root of unity is equal to the `k`-th roots of unity.
* `is_primitive_root.card_primitive_roots`: if an integral domain
   has a primitive `k`-th root of unity, then it has `φ k` of them.

## Implementation details

It is desirable that `roots_of_unity` is a subgroup,
and it will mainly be applied to rings (e.g. the ring of integers in a number field) and fields.
We therefore implement it as a subgroup of the units of a commutative monoid.

We have chosen to define `roots_of_unity n` for `n : ℕ+`, instead of `n : ℕ`,
because almost all lemmas need the positivity assumption,
and in particular the type class instances for `fintype` and `is_cyclic`.

On the other hand, for primitive roots of unity, it is desirable to have a predicate
not just on units, but directly on elements of the ring/field.
For example, we want to say that `exp (2 * pi * I / n)` is a primitive `n`-th root of unity
in the complex numbers, without having to turn that number into a unit first.

This creates a little bit of friction, but lemmas like `is_primitive_root.is_unit` and
`is_primitive_root.coe_units_iff` should provide the necessary glue.

-/

/-- `roots_of_unity k M` is the subgroup of elements `m : units M` that satisfy `m ^ k = 1` -/
def roots_of_unity (k : ℕ+) (M : Type u_1) [comm_monoid M] : subgroup (units M) :=
  subgroup.mk (set_of fun (ζ : units M) => ζ ^ ↑k = 1) sorry sorry sorry

@[simp] theorem mem_roots_of_unity {M : Type u_1} [comm_monoid M] (k : ℕ+) (ζ : units M) :
    ζ ∈ roots_of_unity k M ↔ ζ ^ ↑k = 1 :=
  iff.rfl

theorem roots_of_unity_le_of_dvd {M : Type u_1} [comm_monoid M] {k : ℕ+} {l : ℕ+} (h : k ∣ l) :
    roots_of_unity k M ≤ roots_of_unity l M :=
  sorry

theorem map_roots_of_unity {M : Type u_1} {N : Type u_2} [comm_monoid M] [comm_monoid N]
    (f : units M →* units N) (k : ℕ+) : subgroup.map f (roots_of_unity k M) ≤ roots_of_unity k N :=
  sorry

theorem mem_roots_of_unity_iff_mem_nth_roots {R : Type u_5} [integral_domain R] {k : ℕ+}
    {ζ : units R} : ζ ∈ roots_of_unity k R ↔ ↑ζ ∈ polynomial.nth_roots (↑k) 1 :=
  sorry

/-- Equivalence between the `k`-th roots of unity in `R` and the `k`-th roots of `1`.

This is implemented as equivalence of subtypes,
because `roots_of_unity` is a subgroup of the group of units,
whereas `nth_roots` is a multiset. -/
def roots_of_unity_equiv_nth_roots (R : Type u_5) [integral_domain R] (k : ℕ+) :
    ↥(roots_of_unity k R) ≃ Subtype fun (x : R) => x ∈ polynomial.nth_roots (↑k) 1 :=
  equiv.mk (fun (x : ↥(roots_of_unity k R)) => { val := ↑x, property := sorry })
    (fun (x : Subtype fun (x : R) => x ∈ polynomial.nth_roots (↑k) 1) =>
      { val := units.mk (↑x) (↑x ^ (↑k - 1)) sorry sorry, property := sorry })
    sorry sorry

@[simp] theorem roots_of_unity_equiv_nth_roots_apply {R : Type u_5} [integral_domain R] {k : ℕ+}
    (x : ↥(roots_of_unity k R)) : ↑(coe_fn (roots_of_unity_equiv_nth_roots R k) x) = ↑x :=
  rfl

@[simp] theorem roots_of_unity_equiv_nth_roots_symm_apply {R : Type u_5} [integral_domain R]
    {k : ℕ+} (x : Subtype fun (x : R) => x ∈ polynomial.nth_roots (↑k) 1) :
    ↑(coe_fn (equiv.symm (roots_of_unity_equiv_nth_roots R k)) x) = ↑x :=
  rfl

protected instance roots_of_unity.fintype (R : Type u_5) [integral_domain R] (k : ℕ+) :
    fintype ↥(roots_of_unity k R) :=
  fintype.of_equiv (Subtype fun (x : R) => x ∈ polynomial.nth_roots (↑k) 1)
    (equiv.symm (roots_of_unity_equiv_nth_roots R k))

protected instance roots_of_unity.is_cyclic (R : Type u_5) [integral_domain R] (k : ℕ+) :
    is_cyclic ↥(roots_of_unity k R) :=
  is_cyclic_of_subgroup_integral_domain
    (monoid_hom.comp (units.coe_hom R) (subgroup.subtype (roots_of_unity k R)))
    (function.injective.comp units.ext subtype.val_injective)

theorem card_roots_of_unity (R : Type u_5) [integral_domain R] (k : ℕ+) :
    fintype.card ↥(roots_of_unity k R) ≤ ↑k :=
  sorry

/-- An element `ζ` is a primitive `k`-th root of unity if `ζ ^ k = 1`,
and if `l` satisfies `ζ ^ l = 1` then `k ∣ l`. -/
structure is_primitive_root {M : Type u_1} [comm_monoid M] (ζ : M) (k : ℕ) where
  pow_eq_one : ζ ^ k = 1
  dvd_of_pow_eq_one : ∀ (l : ℕ), ζ ^ l = 1 → k ∣ l

/-- `primitive_roots k R` is the finset of primitive `k`-th roots of unity
in the integral domain `R`. -/
def primitive_roots (k : ℕ) (R : Type u_1) [integral_domain R] : finset R :=
  finset.filter (fun (ζ : R) => is_primitive_root ζ k)
    (multiset.to_finset (polynomial.nth_roots k 1))

@[simp] theorem mem_primitive_roots {R : Type u_5} [integral_domain R] {k : ℕ} {ζ : R}
    (h0 : 0 < k) : ζ ∈ primitive_roots k R ↔ is_primitive_root ζ k :=
  sorry

namespace is_primitive_root


theorem iff_def {M : Type u_1} [comm_monoid M] (ζ : M) (k : ℕ) :
    is_primitive_root ζ k ↔ ζ ^ k = 1 ∧ ∀ (l : ℕ), ζ ^ l = 1 → k ∣ l :=
  sorry

theorem mk_of_lt {M : Type u_1} [comm_monoid M] {k : ℕ} (ζ : M) (hk : 0 < k) (h1 : ζ ^ k = 1)
    (h : ∀ (l : ℕ), 0 < l → l < k → ζ ^ l ≠ 1) : is_primitive_root ζ k :=
  sorry

theorem pow_eq_one_iff_dvd {M : Type u_1} [comm_monoid M] {k : ℕ} {ζ : M}
    (h : is_primitive_root ζ k) (l : ℕ) : ζ ^ l = 1 ↔ k ∣ l :=
  sorry

theorem is_unit {M : Type u_1} [comm_monoid M] {k : ℕ} {ζ : M} (h : is_primitive_root ζ k)
    (h0 : 0 < k) : is_unit ζ :=
  sorry

theorem pow_ne_one_of_pos_of_lt {M : Type u_1} [comm_monoid M] {k : ℕ} {l : ℕ} {ζ : M}
    (h : is_primitive_root ζ k) (h0 : 0 < l) (hl : l < k) : ζ ^ l ≠ 1 :=
  mt (nat.le_of_dvd h0 ∘ dvd_of_pow_eq_one h l) (not_le_of_lt hl)

theorem pow_inj {M : Type u_1} [comm_monoid M] {k : ℕ} {ζ : M} (h : is_primitive_root ζ k) {i : ℕ}
    {j : ℕ} (hi : i < k) (hj : j < k) (H : ζ ^ i = ζ ^ j) : i = j :=
  sorry

theorem one {M : Type u_1} [comm_monoid M] : is_primitive_root 1 1 :=
  mk (pow_one 1) fun (l : ℕ) (hl : 1 ^ l = 1) => one_dvd l

@[simp] theorem one_right_iff {M : Type u_1} [comm_monoid M] {ζ : M} :
    is_primitive_root ζ 1 ↔ ζ = 1 :=
  sorry

@[simp] theorem coe_units_iff {M : Type u_1} [comm_monoid M] {k : ℕ} {ζ : units M} :
    is_primitive_root (↑ζ) k ↔ is_primitive_root ζ k :=
  sorry

theorem pow_of_coprime {M : Type u_1} [comm_monoid M] {k : ℕ} {ζ : M} (h : is_primitive_root ζ k)
    (i : ℕ) (hi : nat.coprime i k) : is_primitive_root (ζ ^ i) k :=
  sorry

theorem pow_of_prime {M : Type u_1} [comm_monoid M] {k : ℕ} {ζ : M} (h : is_primitive_root ζ k)
    {p : ℕ} (hprime : nat.prime p) (hdiv : ¬p ∣ k) : is_primitive_root (ζ ^ p) k :=
  pow_of_coprime h p (iff.mpr (nat.prime.coprime_iff_not_dvd hprime) hdiv)

theorem pow_iff_coprime {M : Type u_1} [comm_monoid M] {k : ℕ} {ζ : M} (h : is_primitive_root ζ k)
    (h0 : 0 < k) (i : ℕ) : is_primitive_root (ζ ^ i) k ↔ nat.coprime i k :=
  sorry

theorem gpow_eq_one {G : Type u_3} [comm_group G] {k : ℕ} {ζ : G} (h : is_primitive_root ζ k) :
    ζ ^ ↑k = 1 :=
  pow_eq_one h

theorem gpow_eq_one_iff_dvd {G : Type u_3} [comm_group G] {k : ℕ} {ζ : G}
    (h : is_primitive_root ζ k) (l : ℤ) : ζ ^ l = 1 ↔ ↑k ∣ l :=
  sorry

theorem inv {G : Type u_3} [comm_group G] {k : ℕ} {ζ : G} (h : is_primitive_root ζ k) :
    is_primitive_root (ζ⁻¹) k :=
  sorry

@[simp] theorem inv_iff {G : Type u_3} [comm_group G] {k : ℕ} {ζ : G} :
    is_primitive_root (ζ⁻¹) k ↔ is_primitive_root ζ k :=
  sorry

theorem gpow_of_gcd_eq_one {G : Type u_3} [comm_group G] {k : ℕ} {ζ : G} (h : is_primitive_root ζ k)
    (i : ℤ) (hi : int.gcd i ↑k = 1) : is_primitive_root (ζ ^ i) k :=
  sorry

@[simp] theorem coe_subgroup_iff {G : Type u_3} [comm_group G] {k : ℕ} (H : subgroup G) {ζ : ↥H} :
    is_primitive_root (↑ζ) k ↔ is_primitive_root ζ k :=
  sorry

theorem fpow_eq_one {G₀ : Type u_4} [comm_group_with_zero G₀] {k : ℕ} {ζ : G₀}
    (h : is_primitive_root ζ k) : ζ ^ ↑k = 1 :=
  pow_eq_one h

theorem fpow_eq_one_iff_dvd {G₀ : Type u_4} [comm_group_with_zero G₀] {k : ℕ} {ζ : G₀}
    (h : is_primitive_root ζ k) (l : ℤ) : ζ ^ l = 1 ↔ ↑k ∣ l :=
  sorry

theorem inv' {G₀ : Type u_4} [comm_group_with_zero G₀] {k : ℕ} {ζ : G₀}
    (h : is_primitive_root ζ k) : is_primitive_root (ζ⁻¹) k :=
  sorry

@[simp] theorem inv_iff' {G₀ : Type u_4} [comm_group_with_zero G₀] {k : ℕ} {ζ : G₀} :
    is_primitive_root (ζ⁻¹) k ↔ is_primitive_root ζ k :=
  sorry

theorem fpow_of_gcd_eq_one {G₀ : Type u_4} [comm_group_with_zero G₀] {k : ℕ} {ζ : G₀}
    (h : is_primitive_root ζ k) (i : ℤ) (hi : int.gcd i ↑k = 1) : is_primitive_root (ζ ^ i) k :=
  sorry

@[simp] theorem primitive_roots_zero {R : Type u_5} [integral_domain R] : primitive_roots 0 R = ∅ :=
  sorry

@[simp] theorem primitive_roots_one {R : Type u_5} [integral_domain R] :
    primitive_roots 1 R = singleton 1 :=
  sorry

theorem neg_one {R : Type u_5} [integral_domain R] (p : ℕ) [char_p R p] (hp : p ≠ bit0 1) :
    is_primitive_root (-1) (bit0 1) :=
  sorry

theorem eq_neg_one_of_two_right {R : Type u_5} [integral_domain R] {ζ : R}
    (h : is_primitive_root ζ (bit0 1)) : ζ = -1 :=
  sorry

protected theorem mem_roots_of_unity {R : Type u_5} [integral_domain R] {ζ : units R} {n : ℕ+}
    (h : is_primitive_root ζ ↑n) : ζ ∈ roots_of_unity n R :=
  pow_eq_one h

/-- The (additive) monoid equivalence between `zmod k`
and the powers of a primitive root of unity `ζ`. -/
def zmod_equiv_gpowers {R : Type u_5} [integral_domain R] {k : ℕ} {ζ : units R}
    (h : is_primitive_root ζ k) : zmod k ≃+ additive ↥(subgroup.gpowers ζ) :=
  add_equiv.of_bijective
    (add_monoid_hom.lift_of_surjective (int.cast_add_hom (zmod k)) zmod.int_cast_surjective
      (add_monoid_hom.mk (fun (i : ℤ) => coe_fn additive.of_mul { val := ζ ^ i, property := sorry })
        sorry sorry)
      sorry)
    sorry

@[simp] theorem zmod_equiv_gpowers_apply_coe_int {R : Type u_5} [integral_domain R] {k : ℕ}
    {ζ : units R} (h : is_primitive_root ζ k) (i : ℤ) :
    coe_fn (zmod_equiv_gpowers h) ↑i =
        coe_fn additive.of_mul { val := ζ ^ i, property := Exists.intro i rfl } :=
  sorry

@[simp] theorem zmod_equiv_gpowers_apply_coe_nat {R : Type u_5} [integral_domain R] {k : ℕ}
    {ζ : units R} (h : is_primitive_root ζ k) (i : ℕ) :
    coe_fn (zmod_equiv_gpowers h) ↑i =
        coe_fn additive.of_mul { val := ζ ^ i, property := Exists.intro (↑i) rfl } :=
  sorry

@[simp] theorem zmod_equiv_gpowers_symm_apply_gpow {R : Type u_5} [integral_domain R] {k : ℕ}
    {ζ : units R} (h : is_primitive_root ζ k) (i : ℤ) :
    coe_fn (add_equiv.symm (zmod_equiv_gpowers h))
          (coe_fn additive.of_mul { val := ζ ^ i, property := Exists.intro i rfl }) =
        ↑i :=
  sorry

@[simp] theorem zmod_equiv_gpowers_symm_apply_gpow' {R : Type u_5} [integral_domain R] {k : ℕ}
    {ζ : units R} (h : is_primitive_root ζ k) (i : ℤ) :
    coe_fn (add_equiv.symm (zmod_equiv_gpowers h))
          { val := ζ ^ i, property := Exists.intro i rfl } =
        ↑i :=
  zmod_equiv_gpowers_symm_apply_gpow h i

@[simp] theorem zmod_equiv_gpowers_symm_apply_pow {R : Type u_5} [integral_domain R] {k : ℕ}
    {ζ : units R} (h : is_primitive_root ζ k) (i : ℕ) :
    coe_fn (add_equiv.symm (zmod_equiv_gpowers h))
          (coe_fn additive.of_mul { val := ζ ^ i, property := Exists.intro (↑i) rfl }) =
        ↑i :=
  sorry

@[simp] theorem zmod_equiv_gpowers_symm_apply_pow' {R : Type u_5} [integral_domain R] {k : ℕ}
    {ζ : units R} (h : is_primitive_root ζ k) (i : ℕ) :
    coe_fn (add_equiv.symm (zmod_equiv_gpowers h))
          { val := ζ ^ i, property := Exists.intro (↑i) rfl } =
        ↑i :=
  zmod_equiv_gpowers_symm_apply_pow h i

theorem gpowers_eq {R : Type u_5} [integral_domain R] {k : ℕ+} {ζ : units R}
    (h : is_primitive_root ζ ↑k) : subgroup.gpowers ζ = roots_of_unity k R :=
  sorry

theorem eq_pow_of_mem_roots_of_unity {R : Type u_5} [integral_domain R] {k : ℕ+} {ζ : units R}
    {ξ : units R} (h : is_primitive_root ζ ↑k) (hξ : ξ ∈ roots_of_unity k R) :
    ∃ (i : ℕ), ∃ (hi : i < ↑k), ζ ^ i = ξ :=
  sorry

theorem eq_pow_of_pow_eq_one {R : Type u_5} [integral_domain R] {k : ℕ} {ζ : R} {ξ : R}
    (h : is_primitive_root ζ k) (hξ : ξ ^ k = 1) (h0 : 0 < k) :
    ∃ (i : ℕ), ∃ (H : i < k), ζ ^ i = ξ :=
  sorry

theorem is_primitive_root_iff' {R : Type u_5} [integral_domain R] {k : ℕ+} {ζ : units R}
    {ξ : units R} (h : is_primitive_root ζ ↑k) :
    is_primitive_root ξ ↑k ↔ ∃ (i : ℕ), ∃ (H : i < ↑k), ∃ (hi : nat.coprime i ↑k), ζ ^ i = ξ :=
  sorry

theorem is_primitive_root_iff {R : Type u_5} [integral_domain R] {k : ℕ} {ζ : R} {ξ : R}
    (h : is_primitive_root ζ k) (h0 : 0 < k) :
    is_primitive_root ξ k ↔ ∃ (i : ℕ), ∃ (H : i < k), ∃ (hi : nat.coprime i k), ζ ^ i = ξ :=
  sorry

theorem card_roots_of_unity' {R : Type u_5} [integral_domain R] {ζ : units R} {n : ℕ+}
    (h : is_primitive_root ζ ↑n) : fintype.card ↥(roots_of_unity n R) = ↑n :=
  sorry

theorem card_roots_of_unity {R : Type u_5} [integral_domain R] {ζ : R} {n : ℕ+}
    (h : is_primitive_root ζ ↑n) : fintype.card ↥(roots_of_unity n R) = ↑n :=
  sorry

/-- The cardinality of the multiset `nth_roots ↑n (1 : R)` is `n`
if there is a primitive root of unity in `R`. -/
theorem card_nth_roots {R : Type u_5} [integral_domain R] {ζ : R} {n : ℕ}
    (h : is_primitive_root ζ n) : coe_fn multiset.card (polynomial.nth_roots n 1) = n :=
  sorry

/-- The multiset `nth_roots ↑n (1 : R)` has no repeated elements
if there is a primitive root of unity in `R`. -/
theorem nth_roots_nodup {R : Type u_5} [integral_domain R] {ζ : R} {n : ℕ}
    (h : is_primitive_root ζ n) : multiset.nodup (polynomial.nth_roots n 1) :=
  sorry

@[simp] theorem card_nth_roots_finset {R : Type u_5} [integral_domain R] {ζ : R} {n : ℕ}
    (h : is_primitive_root ζ n) : finset.card (polynomial.nth_roots_finset n R) = n :=
  sorry

/-- If an integral domain has a primitive `k`-th root of unity, then it has `φ k` of them. -/
theorem card_primitive_roots {R : Type u_5} [integral_domain R] {ζ : R} {k : ℕ}
    (h : is_primitive_root ζ k) (h0 : 0 < k) : finset.card (primitive_roots k R) = nat.totient k :=
  sorry

/-- The sets `primitive_roots k R` are pairwise disjoint. -/
theorem disjoint {R : Type u_5} [integral_domain R] {k : ℕ} {l : ℕ} (hk : 0 < k) (hl : 0 < l)
    (h : k ≠ l) : disjoint (primitive_roots k R) (primitive_roots l R) :=
  sorry

/-- If there is a `n`-th primitive root of unity in `R` and `b` divides `n`,
then there is a `b`-th primitive root of unity in `R`. -/
theorem pow {R : Type u_5} [integral_domain R] {ζ : R} {n : ℕ} {a : ℕ} {b : ℕ} (hn : 0 < n)
    (h : is_primitive_root ζ n) (hprod : n = a * b) : is_primitive_root (ζ ^ a) b :=
  sorry

/-- `nth_roots n` as a `finset` is equal to the union of `primitive_roots i R` for `i ∣ n`
if there is a primitive root of unity in `R`. -/
theorem nth_roots_one_eq_bUnion_primitive_roots' {R : Type u_5} [integral_domain R] {ζ : R} {n : ℕ+}
    (h : is_primitive_root ζ ↑n) :
    polynomial.nth_roots_finset (↑n) R =
        finset.bUnion (nat.divisors ↑n) fun (i : ℕ) => primitive_roots i R :=
  sorry

/-- `nth_roots n` as a `finset` is equal to the union of `primitive_roots i R` for `i ∣ n`
if there is a primitive root of unity in `R`. -/
theorem nth_roots_one_eq_bUnion_primitive_roots {R : Type u_5} [integral_domain R] {ζ : R} {n : ℕ}
    (hpos : 0 < n) (h : is_primitive_root ζ n) :
    polynomial.nth_roots_finset n R =
        finset.bUnion (nat.divisors n) fun (i : ℕ) => primitive_roots i R :=
  nth_roots_one_eq_bUnion_primitive_roots' h

/--`μ` is integral over `ℤ`. -/
theorem is_integral {n : ℕ} {K : Type u_7} [field K] {μ : K} (h : is_primitive_root μ n)
    (hpos : 0 < n) : is_integral ℤ μ :=
  sorry

/--The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. -/
theorem minpoly_dvd_X_pow_sub_one {n : ℕ} {K : Type u_7} [field K] {μ : K}
    (h : is_primitive_root μ n) (hpos : 0 < n) [char_zero K] : minpoly ℤ μ ∣ polynomial.X ^ n - 1 :=
  sorry

/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is separable. -/
theorem separable_minpoly_mod {n : ℕ} {K : Type u_7} [field K] {μ : K} (h : is_primitive_root μ n)
    (hpos : 0 < n) [char_zero K] {p : ℕ} [fact (nat.prime p)] (hdiv : ¬p ∣ n) :
    polynomial.separable (polynomial.map (int.cast_ring_hom (zmod p)) (minpoly ℤ μ)) :=
  sorry

/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. -/
theorem squarefree_minpoly_mod {n : ℕ} {K : Type u_7} [field K] {μ : K} (h : is_primitive_root μ n)
    (hpos : 0 < n) [char_zero K] {p : ℕ} [fact (nat.prime p)] (hdiv : ¬p ∣ n) :
    squarefree (polynomial.map (int.cast_ring_hom (zmod p)) (minpoly ℤ μ)) :=
  polynomial.separable.squarefree (separable_minpoly_mod h hpos hdiv)

/- Let `P` be the minimal polynomial of a root of unity `μ` and `Q` be the minimal polynomial of
`μ ^ p`, where `p` is a prime that does not divide `n`. Then `P` divides `expand ℤ p Q`. -/

theorem minpoly_dvd_expand {n : ℕ} {K : Type u_7} [field K] {μ : K} (h : is_primitive_root μ n)
    (hpos : 0 < n) [char_zero K] {p : ℕ} (hprime : nat.prime p) (hdiv : ¬p ∣ n) :
    minpoly ℤ μ ∣ coe_fn (polynomial.expand ℤ p) (minpoly ℤ (μ ^ p)) :=
  sorry

/- Let `P` be the minimal polynomial of a root of unity `μ` and `Q` be the minimal polynomial of
`μ ^ p`, where `p` is a prime that does not divide `n`. Then `P` divides `Q ^ p` modulo `p`. -/

theorem minpoly_dvd_pow_mod {n : ℕ} {K : Type u_7} [field K] {μ : K} (h : is_primitive_root μ n)
    (hpos : 0 < n) [char_zero K] {p : ℕ} [hprime : fact (nat.prime p)] (hdiv : ¬p ∣ n) :
    polynomial.map (int.cast_ring_hom (zmod p)) (minpoly ℤ μ) ∣
        polynomial.map (int.cast_ring_hom (zmod p)) (minpoly ℤ (μ ^ p)) ^ p :=
  sorry

/- Let `P` be the minimal polynomial of a root of unity `μ` and `Q` be the minimal polynomial of
`μ ^ p`, where `p` is a prime that does not divide `n`. Then `P` divides `Q` modulo `p`. -/

theorem minpoly_dvd_mod_p {n : ℕ} {K : Type u_7} [field K] {μ : K} (h : is_primitive_root μ n)
    (hpos : 0 < n) [char_zero K] {p : ℕ} [hprime : fact (nat.prime p)] (hdiv : ¬p ∣ n) :
    polynomial.map (int.cast_ring_hom (zmod p)) (minpoly ℤ μ) ∣
        polynomial.map (int.cast_ring_hom (zmod p)) (minpoly ℤ (μ ^ p)) :=
  sorry

/-- If `p` is a prime that does not divide `n`,
then the minimal polynomials of a primitive `n`-th root of unity `μ`
and of `μ ^ p` are the same. -/
theorem minpoly_eq_pow {n : ℕ} {K : Type u_7} [field K] {μ : K} (h : is_primitive_root μ n)
    (hpos : 0 < n) [char_zero K] {p : ℕ} [hprime : fact (nat.prime p)] (hdiv : ¬p ∣ n) :
    minpoly ℤ μ = minpoly ℤ (μ ^ p) :=
  sorry

/-- If `m : ℕ` is coprime with `n`,
then the minimal polynomials of a primitive `n`-th root of unity `μ`
and of `μ ^ m` are the same. -/
theorem minpoly_eq_pow_coprime {n : ℕ} {K : Type u_7} [field K] {μ : K} (h : is_primitive_root μ n)
    (hpos : 0 < n) [char_zero K] {m : ℕ} (hcop : nat.coprime m n) :
    minpoly ℤ μ = minpoly ℤ (μ ^ m) :=
  sorry

/-- If `m : ℕ` is coprime with `n`,
then the minimal polynomial of a primitive `n`-th root of unity `μ`
has `μ ^ m` as root. -/
theorem pow_is_root_minpoly {n : ℕ} {K : Type u_7} [field K] {μ : K} (h : is_primitive_root μ n)
    (hpos : 0 < n) [char_zero K] {m : ℕ} (hcop : nat.coprime m n) :
    polynomial.is_root (polynomial.map (int.cast_ring_hom K) (minpoly ℤ μ)) (μ ^ m) :=
  sorry

/-- `primitive_roots n K` is a subset of the roots of the minimal polynomial of a primitive
`n`-th root of unity `μ`. -/
theorem is_roots_of_minpoly {n : ℕ} {K : Type u_7} [field K] {μ : K} (h : is_primitive_root μ n)
    (hpos : 0 < n) [char_zero K] :
    primitive_roots n K ⊆
        multiset.to_finset
          (polynomial.roots (polynomial.map (int.cast_ring_hom K) (minpoly ℤ μ))) :=
  sorry

/-- The degree of the minimal polynomial of `μ` is at least `totient n`. -/
theorem totient_le_degree_minpoly {n : ℕ} {K : Type u_7} [field K] {μ : K}
    (h : is_primitive_root μ n) (hpos : 0 < n) [char_zero K] :
    nat.totient n ≤ polynomial.nat_degree (minpoly ℤ μ) :=
  sorry

end Mathlib