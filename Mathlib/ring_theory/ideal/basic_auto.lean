/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Chris Hughes, Mario Carneiro
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.algebra.associated
import Mathlib.linear_algebra.basic
import Mathlib.order.zorn
import Mathlib.order.atoms
import Mathlib.PostPort

universes u u_1 v w l u_2 u_3 

namespace Mathlib

/-!

# Ideals over a ring

This file defines `ideal R`, the type of ideals over a commutative ring `R`.

## Implementation notes

`ideal R` is implemented using `submodule R R`, where `•` is interpreted as `*`.

## TODO

Support one-sided ideals, and ideals over non-commutative rings.

See `algebra.ring_quot` for quotients of non-commutative rings.
-/

/-- An ideal in a commutative semiring `R` is an additive submonoid `s` such that
`a * b ∈ s` whenever `b ∈ s`. If `R` is a ring, then `s` is an additive subgroup.  -/
def ideal (R : Type u) [comm_semiring R] := submodule R R

namespace ideal


protected theorem zero_mem {α : Type u} [comm_ring α] (I : ideal α) : 0 ∈ I := submodule.zero_mem I

protected theorem add_mem {α : Type u} [comm_ring α] (I : ideal α) {a : α} {b : α} :
    a ∈ I → b ∈ I → a + b ∈ I :=
  submodule.add_mem I

theorem neg_mem_iff {α : Type u} [comm_ring α] (I : ideal α) {a : α} : -a ∈ I ↔ a ∈ I :=
  submodule.neg_mem_iff I

theorem add_mem_iff_left {α : Type u} [comm_ring α] (I : ideal α) {a : α} {b : α} :
    b ∈ I → (a + b ∈ I ↔ a ∈ I) :=
  submodule.add_mem_iff_left I

theorem add_mem_iff_right {α : Type u} [comm_ring α] (I : ideal α) {a : α} {b : α} :
    a ∈ I → (a + b ∈ I ↔ b ∈ I) :=
  submodule.add_mem_iff_right I

protected theorem sub_mem {α : Type u} [comm_ring α] (I : ideal α) {a : α} {b : α} :
    a ∈ I → b ∈ I → a - b ∈ I :=
  submodule.sub_mem I

theorem mul_mem_left {α : Type u} [comm_ring α] (I : ideal α) (a : α) {b : α} : b ∈ I → a * b ∈ I :=
  submodule.smul_mem I a

theorem mul_mem_right {α : Type u} [comm_ring α] (I : ideal α) {a : α} (b : α) (h : a ∈ I) :
    a * b ∈ I :=
  mul_comm b a ▸ mul_mem_left I b h

end ideal


-- A separate namespace definition is needed because the variables were historically in a different order

namespace ideal


theorem ext {α : Type u} [comm_ring α] {I : ideal α} {J : ideal α} (h : ∀ (x : α), x ∈ I ↔ x ∈ J) :
    I = J :=
  submodule.ext h

theorem eq_top_of_unit_mem {α : Type u} [comm_ring α] (I : ideal α) (x : α) (y : α) (hx : x ∈ I)
    (h : y * x = 1) : I = ⊤ :=
  sorry

theorem eq_top_of_is_unit_mem {α : Type u} [comm_ring α] (I : ideal α) {x : α} (hx : x ∈ I)
    (h : is_unit x) : I = ⊤ :=
  (fun (_a : ∃ (b : α), b * x = 1) =>
      Exists.dcases_on _a
        fun (w : α) (h_1 : w * x = 1) => idRhs (I = ⊤) (eq_top_of_unit_mem I x w hx h_1))
    (iff.mp is_unit_iff_exists_inv' h)

theorem eq_top_iff_one {α : Type u} [comm_ring α] (I : ideal α) : I = ⊤ ↔ 1 ∈ I := sorry

theorem ne_top_iff_one {α : Type u} [comm_ring α] (I : ideal α) : I ≠ ⊤ ↔ ¬1 ∈ I :=
  not_congr (eq_top_iff_one I)

theorem exists_mem_ne_zero_iff_ne_bot {α : Type u} [comm_ring α] (I : ideal α) :
    (∃ (p : α), ∃ (H : p ∈ I), p ≠ 0) ↔ I ≠ ⊥ :=
  sorry

theorem exists_mem_ne_zero_of_ne_bot {α : Type u} [comm_ring α] (I : ideal α) (hI : I ≠ ⊥) :
    ∃ (p : α), ∃ (H : p ∈ I), p ≠ 0 :=
  iff.mpr (exists_mem_ne_zero_iff_ne_bot I) hI

@[simp] theorem unit_mul_mem_iff_mem {α : Type u} [comm_ring α] (I : ideal α) {x : α} {y : α}
    (hy : is_unit y) : y * x ∈ I ↔ x ∈ I :=
  sorry

@[simp] theorem mul_unit_mem_iff_mem {α : Type u} [comm_ring α] (I : ideal α) {x : α} {y : α}
    (hy : is_unit y) : x * y ∈ I ↔ x ∈ I :=
  mul_comm y x ▸ unit_mul_mem_iff_mem I hy

/-- The ideal generated by a subset of a ring -/
def span {α : Type u} [comm_ring α] (s : set α) : ideal α := submodule.span α s

theorem subset_span {α : Type u} [comm_ring α] {s : set α} : s ⊆ ↑(span s) := submodule.subset_span

theorem span_le {α : Type u} [comm_ring α] {s : set α} {I : ideal α} : span s ≤ I ↔ s ⊆ ↑I :=
  submodule.span_le

theorem span_mono {α : Type u} [comm_ring α] {s : set α} {t : set α} : s ⊆ t → span s ≤ span t :=
  submodule.span_mono

@[simp] theorem span_eq {α : Type u} [comm_ring α] (I : ideal α) : span ↑I = I :=
  submodule.span_eq I

@[simp] theorem span_singleton_one {α : Type u} [comm_ring α] : span 1 = ⊤ :=
  iff.mpr (eq_top_iff_one (span 1)) (subset_span (set.mem_singleton 1))

theorem mem_span_insert {α : Type u} [comm_ring α] {s : set α} {x : α} {y : α} :
    x ∈ span (insert y s) ↔ ∃ (a : α), ∃ (z : α), ∃ (H : z ∈ span s), x = a * y + z :=
  submodule.mem_span_insert

theorem mem_span_insert' {α : Type u} [comm_ring α] {s : set α} {x : α} {y : α} :
    x ∈ span (insert y s) ↔ ∃ (a : α), x + a * y ∈ span s :=
  submodule.mem_span_insert'

theorem mem_span_singleton' {α : Type u} [comm_ring α] {x : α} {y : α} :
    x ∈ span (singleton y) ↔ ∃ (a : α), a * y = x :=
  submodule.mem_span_singleton

theorem mem_span_singleton {α : Type u} [comm_ring α] {x : α} {y : α} :
    x ∈ span (singleton y) ↔ y ∣ x :=
  sorry

theorem span_singleton_le_span_singleton {α : Type u} [comm_ring α] {x : α} {y : α} :
    span (singleton x) ≤ span (singleton y) ↔ y ∣ x :=
  iff.trans span_le (iff.trans set.singleton_subset_iff mem_span_singleton)

theorem span_singleton_eq_span_singleton {α : Type u} [integral_domain α] {x : α} {y : α} :
    span (singleton x) = span (singleton y) ↔ associated x y :=
  sorry

theorem span_eq_bot {α : Type u} [comm_ring α] {s : set α} :
    span s = ⊥ ↔ ∀ (x : α), x ∈ s → x = 0 :=
  submodule.span_eq_bot

@[simp] theorem span_singleton_eq_bot {α : Type u} [comm_ring α] {x : α} :
    span (singleton x) = ⊥ ↔ x = 0 :=
  submodule.span_singleton_eq_bot

@[simp] theorem span_zero {α : Type u} [comm_ring α] : span 0 = ⊥ :=
  eq.mpr (id (Eq._oldrec (Eq.refl (span 0 = ⊥)) (Eq.symm set.singleton_zero)))
    (eq.mpr (id (Eq._oldrec (Eq.refl (span (singleton 0) = ⊥)) (propext span_singleton_eq_bot)))
      (Eq.refl 0))

theorem span_singleton_eq_top {α : Type u} [comm_ring α] {x : α} :
    span (singleton x) = ⊤ ↔ is_unit x :=
  sorry

theorem span_singleton_mul_right_unit {α : Type u} [comm_ring α] {a : α} (h2 : is_unit a) (x : α) :
    span (singleton (x * a)) = span (singleton x) :=
  sorry

theorem span_singleton_mul_left_unit {α : Type u} [comm_ring α] {a : α} (h2 : is_unit a) (x : α) :
    span (singleton (a * x)) = span (singleton x) :=
  sorry

/--
The ideal generated by an arbitrary binary relation.
-/
def of_rel {α : Type u} [comm_ring α] (r : α → α → Prop) : ideal α :=
  submodule.span α (set_of fun (x : α) => ∃ (a : α), ∃ (b : α), ∃ (h : r a b), x = a - b)

/-- An ideal `P` of a ring `R` is prime if `P ≠ R` and `xy ∈ P → x ∈ P ∨ y ∈ P` -/
def is_prime {α : Type u} [comm_ring α] (I : ideal α) :=
  I ≠ ⊤ ∧ ∀ {x y : α}, x * y ∈ I → x ∈ I ∨ y ∈ I

theorem is_prime.mem_or_mem {α : Type u} [comm_ring α] {I : ideal α} (hI : is_prime I) {x : α}
    {y : α} : x * y ∈ I → x ∈ I ∨ y ∈ I :=
  and.right hI

theorem is_prime.mem_or_mem_of_mul_eq_zero {α : Type u} [comm_ring α] {I : ideal α}
    (hI : is_prime I) {x : α} {y : α} (h : x * y = 0) : x ∈ I ∨ y ∈ I :=
  and.right hI x y (Eq.symm h ▸ ideal.zero_mem I)

theorem is_prime.mem_of_pow_mem {α : Type u} [comm_ring α] {I : ideal α} (hI : is_prime I) {r : α}
    (n : ℕ) (H : r ^ n ∈ I) : r ∈ I :=
  Nat.rec (fun (H : r ^ 0 ∈ I) => not.elim (mt (iff.mpr (eq_top_iff_one I)) (and.left hI)) H)
    (fun (n : ℕ) (ih : r ^ n ∈ I → r ∈ I) (H : r ^ Nat.succ n ∈ I) =>
      or.cases_on (is_prime.mem_or_mem hI H) id ih)
    n H

theorem not_is_prime_iff {α : Type u} [comm_ring α] {I : ideal α} :
    ¬is_prime I ↔ I = ⊤ ∨ ∃ (x : α), ∃ (H : ¬x ∈ I), ∃ (y : α), ∃ (H : ¬y ∈ I), x * y ∈ I :=
  sorry

theorem zero_ne_one_of_proper {α : Type u} [comm_ring α] {I : ideal α} (h : I ≠ ⊤) : 0 ≠ 1 :=
  fun (hz : 0 = 1) => iff.mp (ne_top_iff_one I) h (hz ▸ ideal.zero_mem I)

theorem span_singleton_prime {α : Type u} [comm_ring α] {p : α} (hp : p ≠ 0) :
    is_prime (span (singleton p)) ↔ prime p :=
  sorry

theorem bot_prime {R : Type u_1} [integral_domain R] : is_prime ⊥ := sorry

/-- An ideal is maximal if it is maximal in the collection of proper ideals. -/
def is_maximal {α : Type u} [comm_ring α] (I : ideal α) := is_coatom I

theorem is_maximal_iff {α : Type u} [comm_ring α] {I : ideal α} :
    is_maximal I ↔ ¬1 ∈ I ∧ ∀ (J : ideal α) (x : α), I ≤ J → ¬x ∈ I → x ∈ J → 1 ∈ J :=
  sorry

theorem is_maximal.eq_of_le {α : Type u} [comm_ring α] {I : ideal α} {J : ideal α}
    (hI : is_maximal I) (hJ : J ≠ ⊤) (IJ : I ≤ J) : I = J :=
  iff.mpr eq_iff_le_not_lt { left := IJ, right := fun (h : I < J) => hJ (and.right hI J h) }

theorem is_maximal.exists_inv {α : Type u} [comm_ring α] {I : ideal α} (hI : is_maximal I) {x : α}
    (hx : ¬x ∈ I) : ∃ (y : α), y * x - 1 ∈ I :=
  sorry

theorem is_maximal.is_prime {α : Type u} [comm_ring α] {I : ideal α} (H : is_maximal I) :
    is_prime I :=
  sorry

protected instance is_maximal.is_prime' {α : Type u} [comm_ring α] (I : ideal α)
    [H : is_maximal I] : is_prime I :=
  is_maximal.is_prime

/-- Krull's theorem: if `I` is an ideal that is not the whole ring, then it is included in some
    maximal ideal. -/
theorem exists_le_maximal {α : Type u} [comm_ring α] (I : ideal α) (hI : I ≠ ⊤) :
    ∃ (M : ideal α), is_maximal M ∧ I ≤ M :=
  sorry

/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/
theorem exists_maximal {α : Type u} [comm_ring α] [nontrivial α] : ∃ (M : ideal α), is_maximal M :=
  sorry

/-- If P is not properly contained in any maximal ideal then it is not properly contained
  in any proper ideal -/
theorem maximal_of_no_maximal {R : Type u} [comm_ring R] {P : ideal R}
    (hmax : ∀ (m : ideal R), P < m → ¬is_maximal m) (J : ideal R) (hPJ : P < J) : J = ⊤ :=
  sorry

theorem mem_span_pair {α : Type u} [comm_ring α] {x : α} {y : α} {z : α} :
    z ∈ span (insert x (singleton y)) ↔ ∃ (a : α), ∃ (b : α), a * x + b * y = z :=
  sorry

theorem span_singleton_lt_span_singleton {β : Type v} [integral_domain β] {x : β} {y : β} :
    span (singleton x) < span (singleton y) ↔ dvd_not_unit y x :=
  sorry

theorem factors_decreasing {β : Type v} [integral_domain β] (b₁ : β) (b₂ : β) (h₁ : b₁ ≠ 0)
    (h₂ : ¬is_unit b₂) : span (singleton (b₁ * b₂)) < span (singleton b₁) :=
  sorry

/-- The quotient `R/I` of a ring `R` by an ideal `I`. -/
def quotient {α : Type u} [comm_ring α] (I : ideal α) := submodule.quotient I

namespace quotient


protected instance has_one {α : Type u} [comm_ring α] (I : ideal α) : HasOne (quotient I) :=
  { one := submodule.quotient.mk 1 }

protected instance has_mul {α : Type u} [comm_ring α] (I : ideal α) : Mul (quotient I) :=
  { mul :=
      fun (a b : quotient I) =>
        quotient.lift_on₂' a b (fun (a b : α) => submodule.quotient.mk (a * b)) sorry }

protected instance comm_ring {α : Type u} [comm_ring α] (I : ideal α) : comm_ring (quotient I) :=
  comm_ring.mk add_comm_group.add sorry add_comm_group.zero sorry sorry add_comm_group.neg
    add_comm_group.sub sorry sorry Mul.mul sorry 1 sorry sorry sorry sorry sorry

/-- The ring homomorphism from a ring `R` to a quotient ring `R/I`. -/
def mk {α : Type u} [comm_ring α] (I : ideal α) : α →+* quotient I :=
  ring_hom.mk (fun (a : α) => submodule.quotient.mk a) sorry sorry sorry sorry

protected instance inhabited {α : Type u} [comm_ring α] {I : ideal α} : Inhabited (quotient I) :=
  { default := coe_fn (mk I) (bit1 (bit0 (bit1 (bit0 (bit0 1))))) }

protected theorem eq {α : Type u} [comm_ring α] {I : ideal α} {x : α} {y : α} :
    coe_fn (mk I) x = coe_fn (mk I) y ↔ x - y ∈ I :=
  submodule.quotient.eq I

@[simp] theorem mk_eq_mk {α : Type u} [comm_ring α] {I : ideal α} (x : α) :
    submodule.quotient.mk x = coe_fn (mk I) x :=
  rfl

theorem eq_zero_iff_mem {α : Type u} {a : α} [comm_ring α] {I : ideal α} :
    coe_fn (mk I) a = 0 ↔ a ∈ I :=
  sorry

theorem zero_eq_one_iff {α : Type u} [comm_ring α] {I : ideal α} : 0 = 1 ↔ I = ⊤ :=
  iff.trans eq_comm (iff.trans eq_zero_iff_mem (iff.symm (eq_top_iff_one I)))

theorem zero_ne_one_iff {α : Type u} [comm_ring α] {I : ideal α} : 0 ≠ 1 ↔ I ≠ ⊤ :=
  not_congr zero_eq_one_iff

protected theorem nontrivial {α : Type u} [comm_ring α] {I : ideal α} (hI : I ≠ ⊤) :
    nontrivial (quotient I) :=
  nontrivial.mk (Exists.intro 0 (Exists.intro 1 (iff.mpr zero_ne_one_iff hI)))

theorem mk_surjective {α : Type u} [comm_ring α] {I : ideal α} : function.surjective ⇑(mk I) :=
  fun (y : quotient I) => quotient.induction_on' y fun (x : α) => exists.intro x rfl

protected instance integral_domain {α : Type u} [comm_ring α] (I : ideal α) [hI : is_prime I] :
    integral_domain (quotient I) :=
  integral_domain.mk comm_ring.add sorry comm_ring.zero sorry sorry comm_ring.neg comm_ring.sub
    sorry sorry comm_ring.mul sorry comm_ring.one sorry sorry sorry sorry sorry sorry sorry

theorem is_integral_domain_iff_prime {α : Type u} [comm_ring α] (I : ideal α) :
    is_integral_domain (quotient I) ↔ is_prime I :=
  sorry

theorem exists_inv {α : Type u} [comm_ring α] {I : ideal α} [hI : is_maximal I] {a : quotient I} :
    a ≠ 0 → ∃ (b : quotient I), a * b = 1 :=
  sorry

/-- quotient by maximal ideal is a field. def rather than instance, since users will have
computable inverses in some applications -/
protected def field {α : Type u} [comm_ring α] (I : ideal α) [hI : is_maximal I] :
    field (quotient I) :=
  field.mk integral_domain.add sorry integral_domain.zero sorry sorry integral_domain.neg
    integral_domain.sub sorry sorry integral_domain.mul sorry integral_domain.one sorry sorry sorry
    sorry sorry
    (fun (a : quotient I) =>
      dite (a = 0) (fun (ha : a = 0) => 0) fun (ha : ¬a = 0) => classical.some (exists_inv ha))
    sorry sorry sorry

/-- If the quotient by an ideal is a field, then the ideal is maximal. -/
theorem maximal_of_is_field {α : Type u} [comm_ring α] (I : ideal α) (hqf : is_field (quotient I)) :
    is_maximal I :=
  sorry

/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/
theorem maximal_ideal_iff_is_field_quotient {α : Type u} [comm_ring α] (I : ideal α) :
    is_maximal I ↔ is_field (quotient I) :=
  { mp := fun (h : is_maximal I) => field.to_is_field (quotient I),
    mpr := fun (h : is_field (quotient I)) => maximal_of_is_field I h }

/-- Given a ring homomorphism `f : α →+* β` sending all elements of an ideal to zero,
lift it to the quotient by this ideal. -/
def lift {α : Type u} {β : Type v} [comm_ring α] [comm_ring β] (S : ideal α) (f : α →+* β)
    (H : ∀ (a : α), a ∈ S → coe_fn f a = 0) : quotient S →+* β :=
  ring_hom.mk (fun (x : quotient S) => quotient.lift_on' x ⇑f sorry) sorry sorry sorry sorry

@[simp] theorem lift_mk {α : Type u} {β : Type v} {a : α} [comm_ring α] [comm_ring β] (S : ideal α)
    (f : α →+* β) (H : ∀ (a : α), a ∈ S → coe_fn f a = 0) :
    coe_fn (lift S f H) (coe_fn (mk S) a) = coe_fn f a :=
  rfl

@[simp] theorem lift_comp_mk {α : Type u} {β : Type v} [comm_ring α] [comm_ring β] (S : ideal α)
    (f : α →+* β) (H : ∀ (a : α), a ∈ S → coe_fn f a = 0) : ring_hom.comp (lift S f H) (mk S) = f :=
  ring_hom.ext fun (_x : α) => rfl

theorem lift_surjective {α : Type u} {β : Type v} [comm_ring α] [comm_ring β] (S : ideal α)
    (f : α →+* β) (H : ∀ (a : α), a ∈ S → coe_fn f a = 0) (hf : function.surjective ⇑f) :
    function.surjective ⇑(lift S f H) :=
  sorry

end quotient


theorem mem_sup_left {R : Type u} [comm_ring R] {S : ideal R} {T : ideal R} {x : R} :
    x ∈ S → x ∈ S ⊔ T :=
  (fun (this : S ≤ S ⊔ T) => this) le_sup_left

theorem mem_sup_right {R : Type u} [comm_ring R] {S : ideal R} {T : ideal R} {x : R} :
    x ∈ T → x ∈ S ⊔ T :=
  (fun (this : T ≤ S ⊔ T) => this) le_sup_right

theorem mem_supr_of_mem {R : Type u} [comm_ring R] {ι : Type u_1} {S : ι → ideal R} (i : ι)
    {x : R} : x ∈ S i → x ∈ supr S :=
  (fun (this : S i ≤ supr S) => this) (le_supr S i)

theorem mem_Sup_of_mem {R : Type u} [comm_ring R] {S : set (ideal R)} {s : ideal R} (hs : s ∈ S)
    {x : R} : x ∈ s → x ∈ Sup S :=
  (fun (this : s ≤ Sup S) => this) (le_Sup hs)

theorem mem_Inf {R : Type u} [comm_ring R] {s : set (ideal R)} {x : R} :
    x ∈ Inf s ↔ ∀ {I : ideal R}, I ∈ s → x ∈ I :=
  sorry

@[simp] theorem mem_inf {R : Type u} [comm_ring R] {I : ideal R} {J : ideal R} {x : R} :
    x ∈ I ⊓ J ↔ x ∈ I ∧ x ∈ J :=
  iff.rfl

@[simp] theorem mem_infi {R : Type u} [comm_ring R] {ι : Type u_1} {I : ι → ideal R} {x : R} :
    x ∈ infi I ↔ ∀ (i : ι), x ∈ I i :=
  submodule.mem_infi fun (i : ι) => I i

@[simp] theorem mem_bot {R : Type u} [comm_ring R] {x : R} : x ∈ ⊥ ↔ x = 0 := submodule.mem_bot R

/-- All ideals in a field are trivial. -/
theorem eq_bot_or_top {K : Type u} [field K] (I : ideal K) : I = ⊥ ∨ I = ⊤ := sorry

theorem eq_bot_of_prime {K : Type u} [field K] (I : ideal K) [h : is_prime I] : I = ⊥ :=
  iff.mp or_iff_not_imp_right (eq_bot_or_top I) (and.left h)

theorem bot_is_maximal {K : Type u} [field K] : is_maximal ⊥ := sorry

/-- `I^n` as an ideal of `R^n`. -/
def pi {α : Type u} [comm_ring α] (I : ideal α) (ι : Type v) : ideal (ι → α) :=
  submodule.mk (set_of fun (x : ι → α) => ∀ (i : ι), x i ∈ I) sorry sorry sorry

theorem mem_pi {α : Type u} [comm_ring α] (I : ideal α) (ι : Type v) (x : ι → α) :
    x ∈ pi I ι ↔ ∀ (i : ι), x i ∈ I :=
  iff.rfl

/-- `R^n/I^n` is a `R/I`-module. -/
protected instance module_pi {α : Type u} [comm_ring α] (I : ideal α) (ι : Type v) :
    module (quotient I) (quotient (pi I ι)) :=
  semimodule.mk sorry sorry

/-- `R^n/I^n` is isomorphic to `(R/I)^n` as an `R/I`-module. -/
def pi_quot_equiv {α : Type u} [comm_ring α] (I : ideal α) (ι : Type v) :
    linear_equiv (quotient I) (quotient (pi I ι)) (ι → quotient I) :=
  linear_equiv.mk
    (fun (x : quotient (pi I ι)) =>
      quotient.lift_on' x (fun (f : ι → α) (i : ι) => coe_fn (quotient.mk I) (f i)) sorry)
    sorry sorry
    (fun (x : ι → quotient I) => coe_fn (quotient.mk (pi I ι)) fun (i : ι) => quotient.out' (x i))
    sorry sorry

/-- If `f : R^n → R^m` is an `R`-linear map and `I ⊆ R` is an ideal, then the image of `I^n` is
    contained in `I^m`. -/
theorem map_pi {α : Type u} [comm_ring α] (I : ideal α) {ι : Type u_1} [fintype ι] {ι' : Type w}
    (x : ι → α) (hi : ∀ (i : ι), x i ∈ I) (f : linear_map α (ι → α) (ι' → α)) (i : ι') :
    coe_fn f x i ∈ I :=
  sorry

end ideal


namespace ring


theorem not_is_field_of_subsingleton {R : Type u_1} [ring R] [subsingleton R] : ¬is_field R := sorry

theorem exists_not_is_unit_of_not_is_field {R : Type u_1} [comm_ring R] [nontrivial R]
    (hf : ¬is_field R) : ∃ (x : R), ∃ (H : x ≠ 0), ¬is_unit x :=
  sorry

theorem not_is_field_iff_exists_ideal_bot_lt_and_lt_top {R : Type u_1} [comm_ring R]
    [nontrivial R] : ¬is_field R ↔ ∃ (I : ideal R), ⊥ < I ∧ I < ⊤ :=
  sorry

theorem not_is_field_iff_exists_prime {R : Type u_1} [comm_ring R] [nontrivial R] :
    ¬is_field R ↔ ∃ (p : ideal R), p ≠ ⊥ ∧ ideal.is_prime p :=
  sorry

/-- When a ring is not a field, the maximal ideals are nontrivial. -/
theorem ne_bot_of_is_maximal_of_not_is_field {R : Type u_1} [comm_ring R] [nontrivial R]
    {M : ideal R} (max : ideal.is_maximal M) (not_field : ¬is_field R) : M ≠ ⊥ :=
  sorry

end ring


namespace ideal


/-- Maximal ideals in a non-field are nontrivial. -/
theorem bot_lt_of_maximal {R : Type u} [comm_ring R] [nontrivial R] (M : ideal R)
    [hm : is_maximal M] (non_field : ¬is_field R) : ⊥ < M :=
  sorry

end ideal


/-- The set of non-invertible elements of a monoid. -/
def nonunits (α : Type u) [monoid α] : set α := set_of fun (a : α) => ¬is_unit a

@[simp] theorem mem_nonunits_iff {α : Type u} {a : α} [comm_monoid α] :
    a ∈ nonunits α ↔ ¬is_unit a :=
  iff.rfl

theorem mul_mem_nonunits_right {α : Type u} {a : α} {b : α} [comm_monoid α] :
    b ∈ nonunits α → a * b ∈ nonunits α :=
  mt is_unit_of_mul_is_unit_right

theorem mul_mem_nonunits_left {α : Type u} {a : α} {b : α} [comm_monoid α] :
    a ∈ nonunits α → a * b ∈ nonunits α :=
  mt is_unit_of_mul_is_unit_left

theorem zero_mem_nonunits {α : Type u} [semiring α] : 0 ∈ nonunits α ↔ 0 ≠ 1 :=
  not_congr is_unit_zero_iff

@[simp] theorem one_not_mem_nonunits {α : Type u} [monoid α] : ¬1 ∈ nonunits α :=
  not_not_intro is_unit_one

theorem coe_subset_nonunits {α : Type u} [comm_ring α] {I : ideal α} (h : I ≠ ⊤) :
    ↑I ⊆ nonunits α :=
  fun (x : α) (hx : x ∈ ↑I) (hu : is_unit x) => h (ideal.eq_top_of_is_unit_mem I hx hu)

theorem exists_max_ideal_of_mem_nonunits {α : Type u} {a : α} [comm_ring α] (h : a ∈ nonunits α) :
    ∃ (I : ideal α), ideal.is_maximal I ∧ a ∈ I :=
  sorry

/-- A commutative ring is local if it has a unique maximal ideal. Note that
  `local_ring` is a predicate. -/
class local_ring (α : Type u) [comm_ring α] extends nontrivial α where
  is_local : ∀ (a : α), is_unit a ∨ is_unit (1 - a)

namespace local_ring


theorem is_unit_or_is_unit_one_sub_self {α : Type u} [comm_ring α] [local_ring α] (a : α) :
    is_unit a ∨ is_unit (1 - a) :=
  is_local a

theorem is_unit_of_mem_nonunits_one_sub_self {α : Type u} [comm_ring α] [local_ring α] (a : α)
    (h : 1 - a ∈ nonunits α) : is_unit a :=
  iff.mp or_iff_not_imp_right (is_local a) h

theorem is_unit_one_sub_self_of_mem_nonunits {α : Type u} [comm_ring α] [local_ring α] (a : α)
    (h : a ∈ nonunits α) : is_unit (1 - a) :=
  iff.mp or_iff_not_imp_left (is_local a) h

theorem nonunits_add {α : Type u} [comm_ring α] [local_ring α] {x : α} {y : α} (hx : x ∈ nonunits α)
    (hy : y ∈ nonunits α) : x + y ∈ nonunits α :=
  sorry

/-- The ideal of elements that are not units. -/
def maximal_ideal (α : Type u) [comm_ring α] [local_ring α] : ideal α :=
  submodule.mk (nonunits α) sorry sorry sorry

protected instance maximal_ideal.is_maximal (α : Type u) [comm_ring α] [local_ring α] :
    ideal.is_maximal (maximal_ideal α) :=
  eq.mpr
    (id (Eq._oldrec (Eq.refl (ideal.is_maximal (maximal_ideal α))) (propext ideal.is_maximal_iff)))
    { left := id fun (h : 1 ∈ maximal_ideal α) => h is_unit_one,
      right :=
        fun (I : ideal α) (x : α) (hI : maximal_ideal α ≤ I) (hx : ¬x ∈ maximal_ideal α)
          (H : x ∈ I) =>
          Exists.dcases_on
            (eq.mp (Eq._oldrec (Eq.refl (¬x ∈ maximal_ideal α)) (propext not_not)) hx)
            fun (u : units α) (hx_h : ↑u = x) =>
              Eq._oldrec
                (fun (H : ↑u ∈ I) =>
                  eq.mpr (id (Eq.refl (1 ∈ I)))
                    (eq.mp
                      ((fun (ᾰ ᾰ_1 : α) (e_2 : ᾰ = ᾰ_1) (ᾰ_2 ᾰ_3 : ideal α) (e_3 : ᾰ_2 = ᾰ_3) =>
                          congr (congr_arg has_mem.mem e_2) e_3)
                        (↑(u⁻¹) * ↑u) 1 (units.inv_mul u) I I (Eq.refl I))
                      (ideal.mul_mem_left I (↑(u⁻¹)) H)))
                hx_h H }

theorem maximal_ideal_unique (α : Type u) [comm_ring α] [local_ring α] :
    exists_unique fun (I : ideal α) => ideal.is_maximal I :=
  sorry

theorem eq_maximal_ideal {α : Type u} [comm_ring α] [local_ring α] {I : ideal α}
    (hI : ideal.is_maximal I) : I = maximal_ideal α :=
  unique_of_exists_unique (maximal_ideal_unique α) hI (maximal_ideal.is_maximal α)

theorem le_maximal_ideal {α : Type u} [comm_ring α] [local_ring α] {J : ideal α} (hJ : J ≠ ⊤) :
    J ≤ maximal_ideal α :=
  sorry

@[simp] theorem mem_maximal_ideal {α : Type u} [comm_ring α] [local_ring α] (x : α) :
    x ∈ maximal_ideal α ↔ x ∈ nonunits α :=
  iff.rfl

end local_ring


theorem local_of_nonunits_ideal {α : Type u} [comm_ring α] (hnze : 0 ≠ 1)
    (h : ∀ (x y : α), x ∈ nonunits α → y ∈ nonunits α → x + y ∈ nonunits α) : local_ring α :=
  sorry

theorem local_of_unique_max_ideal {α : Type u} [comm_ring α]
    (h : exists_unique fun (I : ideal α) => ideal.is_maximal I) : local_ring α :=
  sorry

theorem local_of_unique_nonzero_prime (R : Type u) [comm_ring R]
    (h : exists_unique fun (P : ideal R) => P ≠ ⊥ ∧ ideal.is_prime P) : local_ring R :=
  sorry

theorem local_of_surjective {A : Type u_1} {B : Type u_2} [comm_ring A] [local_ring A] [comm_ring B]
    [nontrivial B] (f : A →+* B) (hf : function.surjective ⇑f) : local_ring B :=
  sorry

/-- A local ring homomorphism is a homomorphism between local rings
  such that the image of the maximal ideal of the source is contained within
  the maximal ideal of the target. -/
class is_local_ring_hom {α : Type u} {β : Type v} [semiring α] [semiring β] (f : α →+* β) where
  map_nonunit : ∀ (a : α), is_unit (coe_fn f a) → is_unit a

protected instance is_local_ring_hom_id (A : Type u_1) [semiring A] :
    is_local_ring_hom (ring_hom.id A) :=
  is_local_ring_hom.mk fun (a : A) => id

@[simp] theorem is_unit_map_iff {A : Type u_1} {B : Type u_2} [semiring A] [semiring B]
    (f : A →+* B) [is_local_ring_hom f] (a : A) : is_unit (coe_fn f a) ↔ is_unit a :=
  { mp := is_local_ring_hom.map_nonunit a, mpr := ring_hom.is_unit_map f }

protected instance is_local_ring_hom_comp {A : Type u_1} {B : Type u_2} {C : Type u_3} [semiring A]
    [semiring B] [semiring C] (g : B →+* C) (f : A →+* B) [is_local_ring_hom g]
    [is_local_ring_hom f] : is_local_ring_hom (ring_hom.comp g f) :=
  is_local_ring_hom.mk
    fun (a : A) => is_local_ring_hom.map_nonunit a ∘ is_local_ring_hom.map_nonunit (coe_fn f a)

@[simp] theorem is_unit_of_map_unit {α : Type u} {β : Type v} [semiring α] [semiring β]
    (f : α →+* β) [is_local_ring_hom f] (a : α) (h : is_unit (coe_fn f a)) : is_unit a :=
  is_local_ring_hom.map_nonunit a h

theorem of_irreducible_map {α : Type u} {β : Type v} [semiring α] [semiring β] (f : α →+* β)
    [h : is_local_ring_hom f] {x : α} (hfx : irreducible (coe_fn f x)) : irreducible x :=
  sorry

theorem map_nonunit {α : Type u} {β : Type v} [comm_ring α] [local_ring α] [comm_ring β]
    [local_ring β] (f : α →+* β) [is_local_ring_hom f] (a : α)
    (h : a ∈ local_ring.maximal_ideal α) : coe_fn f a ∈ local_ring.maximal_ideal β :=
  fun (H : is_unit (coe_fn f a)) => h (is_unit_of_map_unit f a H)

namespace local_ring


/-- The residue field of a local ring is the quotient of the ring by its maximal ideal. -/
def residue_field (α : Type u) [comm_ring α] [local_ring α] := ideal.quotient (maximal_ideal α)

protected instance residue_field.field (α : Type u) [comm_ring α] [local_ring α] :
    field (residue_field α) :=
  ideal.quotient.field (maximal_ideal α)

protected instance residue_field.inhabited (α : Type u) [comm_ring α] [local_ring α] :
    Inhabited (residue_field α) :=
  { default := bit1 (bit0 (bit1 (bit0 (bit0 1)))) }

/-- The quotient map from a local ring to its residue field. -/
def residue (α : Type u) [comm_ring α] [local_ring α] : α →+* residue_field α :=
  ideal.quotient.mk (maximal_ideal α)

namespace residue_field


/-- The map on residue fields induced by a local homomorphism between local rings -/
def map {α : Type u} {β : Type v} [comm_ring α] [local_ring α] [comm_ring β] [local_ring β]
    (f : α →+* β) [is_local_ring_hom f] : residue_field α →+* residue_field β :=
  ideal.quotient.lift (maximal_ideal α) (ring_hom.comp (ideal.quotient.mk (maximal_ideal β)) f)
    sorry

end residue_field


end local_ring


namespace field


protected instance local_ring {α : Type u} [field α] : local_ring α :=
  local_ring.mk
    fun (a : α) =>
      dite (a = 0)
        (fun (h : a = 0) =>
          Or.inr
            (eq.mpr (id (Eq._oldrec (Eq.refl (is_unit (1 - a))) h))
              (eq.mpr (id (Eq._oldrec (Eq.refl (is_unit (1 - 0))) (sub_zero 1))) is_unit_one)))
        fun (h : ¬a = 0) => Or.inl (is_unit_of_mul_eq_one a (a⁻¹) (div_self h))

end Mathlib