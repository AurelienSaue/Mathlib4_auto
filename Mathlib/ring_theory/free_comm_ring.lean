/-
Copyright (c) 2019 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Johan Commelin
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.data.equiv.functor
import Mathlib.data.mv_polynomial.equiv
import Mathlib.data.mv_polynomial.comm_ring
import Mathlib.ring_theory.free_ring
import Mathlib.PostPort

universes u v u_1 u_2 

namespace Mathlib

/-!
# Free commutative rings

The theory of the free commutative ring generated by a type `α`.
It is isomorphic to the polynomial ring over ℤ with variables
in `α`

## Main definitions

* `free_comm_ring α`     : the free commutative ring on a type α
* `lift_hom (f : α → R)` : the ring hom `free_comm_ring α →+* R` induced by functoriality from `f`.
* `map (f : α → β)`      : the ring hom `free_comm_ring α →*+ free_comm_ring β` induced by
                           functoriality from f.

## Main results

`free_comm_ring` has functorial properties (it is an adjoint to the forgetful functor).
In this file we have:

* `of : α → free_comm_ring α`
* `lift_hom (f : α → R) : free_comm_ring α →+* R`
* `map (f : α → β) : free_comm_ring α →+* free_comm_ring β`

* `free_comm_ring_equiv_mv_polynomial_int : free_comm_ring α ≃+* mv_polynomial α ℤ` :
    `free_comm_ring α` is isomorphic to a polynomial ring.



## Implementation notes

`free_comm_ring α` is implemented not using `mv_polynomial` but
directly as the free abelian group on `multiset α`, the type
of monomials in this free commutative ring.

## Tags

free commutative ring, free ring
-/

/-- `free_comm_ring α` is the free commutative ring on the type `α`. -/
def free_comm_ring (α : Type u)  :=
  free_abelian_group (multiplicative (multiset α))

namespace free_comm_ring


/-- The structure of a commutative ring on `free_comm_ring α`. -/
protected instance comm_ring (α : Type u) : comm_ring (free_comm_ring α) :=
  free_abelian_group.comm_ring (multiplicative (multiset α))

protected instance inhabited (α : Type u) : Inhabited (free_comm_ring α) :=
  { default := 0 }

/-- The canonical map from `α` to the free commutative ring on `α`. -/
def of {α : Type u} (x : α) : free_comm_ring α :=
  free_abelian_group.of ↑[x]

theorem of_injective {α : Type u} : function.injective of :=
  function.injective.comp free_abelian_group.of_injective
    fun (x y : α) => iff.mp (iff.trans multiset.coe_eq_coe list.singleton_perm_singleton)

protected theorem induction_on {α : Type u} {C : free_comm_ring α → Prop} (z : free_comm_ring α) (hn1 : C (-1)) (hb : ∀ (b : α), C (of b)) (ha : ∀ (x y : free_comm_ring α), C x → C y → C (x + y)) (hm : ∀ (x y : free_comm_ring α), C x → C y → C (x * y)) : C z := sorry

/-- Lift a map `α → R` to a additive group homomorphism `free_comm_ring α → R`.
For a version producing a bundled homomorphism, see `lift_hom`. -/
def lift {α : Type u} {R : Type v} [comm_ring R] (f : α → R) : free_comm_ring α →+* R :=
  ring_hom.mk
    (add_monoid_hom.to_fun
      (free_abelian_group.lift
        fun (s : multiplicative (multiset α)) => multiset.prod (multiset.map f (coe_fn multiplicative.to_add s))))
    sorry sorry sorry sorry

@[simp] theorem lift_of {α : Type u} {R : Type v} [comm_ring R] (f : α → R) (x : α) : coe_fn (lift f) (of x) = f x := sorry

@[simp] theorem lift_comp_of {α : Type u} {R : Type v} [comm_ring R] (f : free_comm_ring α →+* R) : lift (⇑f ∘ of) = f := sorry

/-- A map `f : α → β` produces a ring homomorphism `free_comm_ring α →+* free_comm_ring β`. -/
def map {α : Type u} {β : Type v} (f : α → β) : free_comm_ring α →+* free_comm_ring β :=
  lift (of ∘ f)

@[simp] theorem map_of {α : Type u} {β : Type v} (f : α → β) (x : α) : coe_fn (map f) (of x) = of (f x) :=
  lift_of (of ∘ f) x

/-- `is_supported x s` means that all monomials showing up in `x` have variables in `s`. -/
def is_supported {α : Type u} (x : free_comm_ring α) (s : set α)  :=
  x ∈ ring.closure (of '' s)

theorem is_supported_upwards {α : Type u} {x : free_comm_ring α} {s : set α} {t : set α} (hs : is_supported x s) (hst : s ⊆ t) : is_supported x t :=
  ring.closure_mono (set.monotone_image hst) hs

theorem is_supported_add {α : Type u} {x : free_comm_ring α} {y : free_comm_ring α} {s : set α} (hxs : is_supported x s) (hys : is_supported y s) : is_supported (x + y) s :=
  is_add_submonoid.add_mem hxs hys

theorem is_supported_neg {α : Type u} {x : free_comm_ring α} {s : set α} (hxs : is_supported x s) : is_supported (-x) s :=
  is_add_subgroup.neg_mem hxs

theorem is_supported_sub {α : Type u} {x : free_comm_ring α} {y : free_comm_ring α} {s : set α} (hxs : is_supported x s) (hys : is_supported y s) : is_supported (x - y) s :=
  is_add_subgroup.sub_mem hxs hys

theorem is_supported_mul {α : Type u} {x : free_comm_ring α} {y : free_comm_ring α} {s : set α} (hxs : is_supported x s) (hys : is_supported y s) : is_supported (x * y) s :=
  is_submonoid.mul_mem hxs hys

theorem is_supported_zero {α : Type u} {s : set α} : is_supported 0 s :=
  is_add_submonoid.zero_mem

theorem is_supported_one {α : Type u} {s : set α} : is_supported 1 s :=
  is_submonoid.one_mem

theorem is_supported_int {α : Type u} {i : ℤ} {s : set α} : is_supported (↑i) s := sorry

/-- The restriction map from `free_comm_ring α` to `free_comm_ring s` where `s : set α`, defined
  by sending all variables not in `s` to zero. -/
def restriction {α : Type u} (s : set α) [decidable_pred s] : free_comm_ring α →+* free_comm_ring ↥s :=
  lift fun (p : α) => dite (p ∈ s) (fun (H : p ∈ s) => of { val := p, property := H }) fun (H : ¬p ∈ s) => 0

@[simp] theorem restriction_of {α : Type u} (s : set α) [decidable_pred s] (p : α) : coe_fn (restriction s) (of p) = dite (p ∈ s) (fun (H : p ∈ s) => of { val := p, property := H }) fun (H : ¬p ∈ s) => 0 :=
  lift_of (fun (p : α) => dite (p ∈ s) (fun (H : p ∈ s) => of { val := p, property := H }) fun (H : ¬p ∈ s) => 0) p

theorem is_supported_of {α : Type u} {p : α} {s : set α} : is_supported (of p) s ↔ p ∈ s := sorry

theorem map_subtype_val_restriction {α : Type u} {x : free_comm_ring α} (s : set α) [decidable_pred s] (hxs : is_supported x s) : coe_fn (map subtype.val) (coe_fn (restriction s) x) = x := sorry

theorem exists_finite_support {α : Type u} (x : free_comm_ring α) : ∃ (s : set α), set.finite s ∧ is_supported x s := sorry

theorem exists_finset_support {α : Type u} (x : free_comm_ring α) : ∃ (s : finset α), is_supported x ↑s := sorry

end free_comm_ring


namespace free_ring


/-- The canonical ring homomorphism from the free ring generated by `α` to the free commutative ring
    generated by `α`. -/
def to_free_comm_ring {α : Type u_1} : free_ring α →+* free_comm_ring α :=
  lift free_comm_ring.of

protected instance free_comm_ring.has_coe (α : Type u) : has_coe (free_ring α) (free_comm_ring α) :=
  has_coe.mk ⇑to_free_comm_ring

protected instance coe.is_ring_hom (α : Type u) : is_ring_hom coe :=
  ring_hom.is_ring_hom to_free_comm_ring

@[simp] protected theorem coe_zero (α : Type u) : ↑0 = 0 :=
  rfl

@[simp] protected theorem coe_one (α : Type u) : ↑1 = 1 :=
  rfl

@[simp] protected theorem coe_of {α : Type u} (a : α) : ↑(of a) = free_comm_ring.of a :=
  lift_of free_comm_ring.of a

@[simp] protected theorem coe_neg {α : Type u} (x : free_ring α) : ↑(-x) = -↑x :=
  ring_hom.map_neg (lift free_comm_ring.of) x

@[simp] protected theorem coe_add {α : Type u} (x : free_ring α) (y : free_ring α) : ↑(x + y) = ↑x + ↑y :=
  ring_hom.map_add (lift free_comm_ring.of) x y

@[simp] protected theorem coe_sub {α : Type u} (x : free_ring α) (y : free_ring α) : ↑(x - y) = ↑x - ↑y :=
  ring_hom.map_sub (lift free_comm_ring.of) x y

@[simp] protected theorem coe_mul {α : Type u} (x : free_ring α) (y : free_ring α) : ↑(x * y) = ↑x * ↑y :=
  ring_hom.map_mul (lift free_comm_ring.of) x y

protected theorem coe_surjective (α : Type u) : function.surjective coe := sorry

theorem coe_eq (α : Type u) : coe = Functor.map fun (l : List α) => ↑l := sorry

-- FIXME This was in `deprecated.ring`, but only used here.

-- It would be good to inline it into the next construction.

/-- Interpret an equivalence `f : R ≃ S` as a ring equivalence `R ≃+* S`. -/
def of' {R : Type u_1} {S : Type u_2} [ring R] [ring S] (e : R ≃ S) [is_ring_hom ⇑e] : R ≃+* S :=
  ring_equiv.mk (equiv.to_fun e) (equiv.inv_fun e) (equiv.left_inv e) (equiv.right_inv e) sorry sorry

/-- If α has size at most 1 then the natural map from the free ring on `α` to the
    free commutative ring on `α` is an isomorphism of rings. -/
def subsingleton_equiv_free_comm_ring (α : Type u) [subsingleton α] : free_ring α ≃+* free_comm_ring α :=
  of' (functor.map_equiv free_abelian_group (multiset.subsingleton_equiv α))

protected instance comm_ring (α : Type u) [subsingleton α] : comm_ring (free_ring α) :=
  comm_ring.mk ring.add sorry ring.zero sorry sorry ring.neg ring.sub sorry sorry ring.mul sorry ring.one sorry sorry
    sorry sorry sorry

end free_ring


/-- The free commutative ring on `α` is isomorphic to the polynomial ring over ℤ with
    variables in `α` -/
def free_comm_ring_equiv_mv_polynomial_int (α : Type u) : free_comm_ring α ≃+* mv_polynomial α ℤ :=
  ring_equiv.mk (⇑(free_comm_ring.lift fun (a : α) => mv_polynomial.X a))
    (mv_polynomial.eval₂ (int.cast_ring_hom (free_comm_ring α)) free_comm_ring.of) sorry sorry sorry sorry

/-- The free commutative ring on the empty type is isomorphic to `ℤ`. -/
def free_comm_ring_pempty_equiv_int : free_comm_ring pempty ≃+* ℤ :=
  ring_equiv.trans (free_comm_ring_equiv_mv_polynomial_int pempty) (mv_polynomial.pempty_ring_equiv ℤ)

/-- The free commutative ring on a type with one term is isomorphic to `ℤ[X]`. -/
def free_comm_ring_punit_equiv_polynomial_int : free_comm_ring PUnit ≃+* polynomial ℤ :=
  ring_equiv.trans (free_comm_ring_equiv_mv_polynomial_int PUnit) (mv_polynomial.punit_ring_equiv ℤ)

/-- The free ring on the empty type is isomorphic to `ℤ`. -/
def free_ring_pempty_equiv_int : free_ring pempty ≃+* ℤ :=
  ring_equiv.trans (free_ring.subsingleton_equiv_free_comm_ring pempty) free_comm_ring_pempty_equiv_int

/-- The free ring on a type with one term is isomorphic to `ℤ[X]`. -/
def free_ring_punit_equiv_polynomial_int : free_ring PUnit ≃+* polynomial ℤ :=
  ring_equiv.trans (free_ring.subsingleton_equiv_free_comm_ring PUnit) free_comm_ring_punit_equiv_polynomial_int

