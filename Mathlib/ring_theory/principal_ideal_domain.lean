/-
Copyright (c) 2018 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: Chris Hughes, Morenikeji Neri
-/
import Mathlib.PrePort
import Mathlib.Lean3Lib.init.default
import Mathlib.ring_theory.noetherian
import Mathlib.ring_theory.unique_factorization_domain
import Mathlib.PostPort

universes u v l u_1 u_2 

namespace Mathlib

/-!
# Principal ideal rings and principal ideal domains

A principal ideal ring (PIR) is a commutative ring in which all ideals are principal. A
principal ideal domain (PID) is an integral domain which is a principal ideal ring.

# Main definitions

Note that for principal ideal domains, one should use
`[integral domain R] [is_principal_ideal_ring R]`. There is no explicit definition of a PID.
Theorems about PID's are in the `principal_ideal_ring` namespace.

- `is_principal_ideal_ring`: a predicate on commutative rings, saying that every
  ideal is principal.
- `generator`: a generator of a principal ideal (or more generally submodule)
- `to_unique_factorization_monoid`: a PID is a unique factorization domain

# Main results

- `to_maximal_ideal`: a non-zero prime ideal in a PID is maximal.
- `euclidean_domain.to_principal_ideal_domain` : a Euclidean domain is a PID.

-/

/-- An `R`-submodule of `M` is principal if it is generated by one element. -/
class submodule.is_principal {R : Type u} {M : Type v} [ring R] [add_comm_group M] [module R M] (S : submodule R M) 
where
  principal : ∃ (a : M), S = submodule.span R (singleton a)

/-- A commutative ring is a principal ideal ring if all ideals are principal. -/
class is_principal_ideal_ring (R : Type u) [comm_ring R] 
where
  principal : ∀ (S : ideal R), submodule.is_principal S

namespace submodule.is_principal


/-- `generator I`, if `I` is a principal submodule, is an `x ∈ M` such that `span R {x} = I` -/
def generator {R : Type u} {M : Type v} [comm_ring R] [add_comm_group M] [module R M] (S : submodule R M) [is_principal S] : M :=
  classical.some sorry

theorem span_singleton_generator {R : Type u} {M : Type v} [comm_ring R] [add_comm_group M] [module R M] (S : submodule R M) [is_principal S] : span R (singleton (generator S)) = S :=
  Eq.symm (classical.some_spec (principal S))

@[simp] theorem generator_mem {R : Type u} {M : Type v} [comm_ring R] [add_comm_group M] [module R M] (S : submodule R M) [is_principal S] : generator S ∈ S := sorry

theorem mem_iff_eq_smul_generator {R : Type u} {M : Type v} [comm_ring R] [add_comm_group M] [module R M] (S : submodule R M) [is_principal S] {x : M} : x ∈ S ↔ ∃ (s : R), x = s • generator S := sorry

theorem mem_iff_generator_dvd {R : Type u} [comm_ring R] (S : ideal R) [is_principal S] {x : R} : x ∈ S ↔ generator S ∣ x := sorry

theorem eq_bot_iff_generator_eq_zero {R : Type u} {M : Type v} [comm_ring R] [add_comm_group M] [module R M] (S : submodule R M) [is_principal S] : S = ⊥ ↔ generator S = 0 :=
  eq.mpr (id (Eq._oldrec (Eq.refl (S = ⊥ ↔ generator S = 0)) (Eq.symm (propext span_singleton_eq_bot))))
    (eq.mpr (id (Eq._oldrec (Eq.refl (S = ⊥ ↔ span R (singleton (generator S)) = ⊥)) (span_singleton_generator S)))
      (iff.refl (S = ⊥)))

end submodule.is_principal


namespace is_prime


-- TODO -- for a non-ID one could perhaps prove that if p < q are prime then q maximal;

-- 0 isn't prime in a non-ID PIR but the Krull dimension is still <= 1.

-- The below result follows from this, but we could also use the below result to

-- prove this (quotient out by p).

theorem to_maximal_ideal {R : Type u} [integral_domain R] [is_principal_ideal_ring R] {S : ideal R} [hpi : ideal.is_prime S] (hS : S ≠ ⊥) : ideal.is_maximal S := sorry

end is_prime


theorem mod_mem_iff {R : Type u} [euclidean_domain R] {S : ideal R} {x : R} {y : R} (hy : y ∈ S) : x % y ∈ S ↔ x ∈ S := sorry

protected instance euclidean_domain.to_principal_ideal_domain {R : Type u} [euclidean_domain R] : is_principal_ideal_ring R := sorry

namespace principal_ideal_ring


protected instance is_noetherian_ring {R : Type u} [integral_domain R] [is_principal_ideal_ring R] : is_noetherian_ring R :=
  is_noetherian.mk
    fun (s : ideal R) =>
      Exists.dcases_on (submodule.is_principal.principal s)
        fun (a : R) (h : s = submodule.span R (singleton a)) =>
          Eq._oldrec
            (eq.mpr
              (id
                (Eq._oldrec (Eq.refl (submodule.fg (submodule.span R (singleton a)))) (Eq.symm (finset.coe_singleton a))))
              (Exists.intro (singleton a) (submodule.coe_injective rfl)))
            (Eq.symm h)

theorem is_maximal_of_irreducible {R : Type u} [integral_domain R] [is_principal_ideal_ring R] {p : R} (hp : irreducible p) : ideal.is_maximal (submodule.span R (singleton p)) := sorry

theorem irreducible_iff_prime {R : Type u} [integral_domain R] [is_principal_ideal_ring R] {p : R} : irreducible p ↔ prime p := sorry

theorem associates_irreducible_iff_prime {R : Type u} [integral_domain R] [is_principal_ideal_ring R] {p : associates R} : irreducible p ↔ prime p :=
  iff.mp associates.irreducible_iff_prime_iff fun (_x : R) => irreducible_iff_prime

/-- `factors a` is a multiset of irreducible elements whose product is `a`, up to units -/
def factors {R : Type u} [integral_domain R] [is_principal_ideal_ring R] (a : R) : multiset R :=
  dite (a = 0) (fun (h : a = 0) => ∅) fun (h : ¬a = 0) => classical.some sorry

theorem factors_spec {R : Type u} [integral_domain R] [is_principal_ideal_ring R] (a : R) (h : a ≠ 0) : (∀ (b : R), b ∈ factors a → irreducible b) ∧ associated (multiset.prod (factors a)) a := sorry

theorem ne_zero_of_mem_factors {R : Type v} [integral_domain R] [is_principal_ideal_ring R] {a : R} {b : R} (ha : a ≠ 0) (hb : b ∈ factors a) : b ≠ 0 :=
  irreducible.ne_zero (and.left (factors_spec a ha) b hb)

theorem mem_submonoid_of_factors_subset_of_units_subset {R : Type u} [integral_domain R] [is_principal_ideal_ring R] (s : submonoid R) {a : R} (ha : a ≠ 0) (hfac : ∀ (b : R), b ∈ factors a → b ∈ s) (hunit : ∀ (c : units R), ↑c ∈ s) : a ∈ s := sorry

/-- If a `ring_hom` maps all units and all factors of an element `a` into a submonoid `s`, then it
also maps `a` into that submonoid. -/
theorem ring_hom_mem_submonoid_of_factors_subset_of_units_subset {R : Type u_1} {S : Type u_2} [integral_domain R] [is_principal_ideal_ring R] [semiring S] (f : R →+* S) (s : submonoid S) (a : R) (ha : a ≠ 0) (h : ∀ (b : R), b ∈ factors a → coe_fn f b ∈ s) (hf : ∀ (c : units R), coe_fn f ↑c ∈ s) : coe_fn f a ∈ s :=
  mem_submonoid_of_factors_subset_of_units_subset (submonoid.comap (ring_hom.to_monoid_hom f) s) ha h hf

/-- A principal ideal domain has unique factorization -/
protected instance to_unique_factorization_monoid {R : Type u} [integral_domain R] [is_principal_ideal_ring R] : unique_factorization_monoid R :=
  unique_factorization_monoid.mk fun (_x : R) => irreducible_iff_prime

