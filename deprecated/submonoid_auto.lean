/-
Copyright (c) 2018 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Kenny Lau, Johan Commelin, Mario Carneiro, Kevin Buzzard
-/
import PrePort
import Lean3Lib.init.default
import Mathlib.group_theory.submonoid.basic
import Mathlib.algebra.big_operators.basic
import PostPort

universes u_2 l u_1 

namespace Mathlib

/-!
# Submonoids

This file defines unbundled multiplicative and additive submonoids (deprecated). For bundled form
see `group_theory/submonoid`.

We some results about images and preimages of submonoids under monoid homomorphisms. These theorems
use unbundled monoid homomorphisms (also deprecated).

There are also theorems about the submonoids generated by an element or a subset of a monoid,
defined inductively.

## Implementation notes

Unbundled submonoids will slowly be removed from mathlib.

## Tags
submonoid, submonoids, is_submonoid
-/

/-- `s` is an additive submonoid: a set containing 0 and closed under addition. -/
class is_add_submonoid {A : Type u_2} [add_monoid A] (s : set A) 
where
  zero_mem : 0 ∈ s
  add_mem : ∀ {a b : A}, a ∈ s → b ∈ s → a + b ∈ s

/-- `s` is a submonoid: a set containing 1 and closed under multiplication. -/
class is_submonoid {M : Type u_1} [monoid M] (s : set M) 
where
  one_mem : 1 ∈ s
  mul_mem : ∀ {a b : M}, a ∈ s → b ∈ s → a * b ∈ s

theorem additive.is_add_submonoid {M : Type u_1} [monoid M] (s : set M) [is_submonoid s] : is_add_submonoid s :=
  is_submonoid.dcases_on _inst_3
    fun (one_mem : 1 ∈ s) (mul_mem : ∀ {a b : M}, a ∈ s → b ∈ s → a * b ∈ s) =>
      idRhs (is_add_submonoid s) (is_add_submonoid.mk one_mem mul_mem)

theorem additive.is_add_submonoid_iff {M : Type u_1} [monoid M] {s : set M} : is_add_submonoid s ↔ is_submonoid s := sorry

theorem multiplicative.is_submonoid {A : Type u_2} [add_monoid A] (s : set A) [is_add_submonoid s] : is_submonoid s :=
  is_add_submonoid.dcases_on _inst_3
    fun (zero_mem : 0 ∈ s) (add_mem : ∀ {a b : A}, a ∈ s → b ∈ s → a + b ∈ s) =>
      idRhs (is_submonoid s) (is_submonoid.mk zero_mem add_mem)

theorem multiplicative.is_submonoid_iff {A : Type u_2} [add_monoid A] {s : set A} : is_submonoid s ↔ is_add_submonoid s := sorry

/-- The intersection of two submonoids of a monoid `M` is a submonoid of `M`. -/
protected instance is_submonoid.inter {M : Type u_1} [monoid M] (s₁ : set M) (s₂ : set M) [is_submonoid s₁] [is_submonoid s₂] : is_submonoid (s₁ ∩ s₂) :=
  is_submonoid.mk { left := is_submonoid.one_mem, right := is_submonoid.one_mem }
    fun (x y : M) (hx : x ∈ s₁ ∩ s₂) (hy : y ∈ s₁ ∩ s₂) =>
      { left := is_submonoid.mul_mem (and.left hx) (and.left hy),
        right := is_submonoid.mul_mem (and.right hx) (and.right hy) }

/-- The intersection of an indexed set of submonoids of a monoid `M` is a submonoid of `M`. -/
protected instance is_add_submonoid.Inter {M : Type u_1} [add_monoid M] {ι : Sort u_2} (s : ι → set M) [h : ∀ (y : ι), is_add_submonoid (s y)] : is_add_submonoid (set.Inter s) :=
  is_add_submonoid.mk (iff.mpr set.mem_Inter fun (y : ι) => is_add_submonoid.zero_mem)
    fun (x₁ x₂ : M) (h₁ : x₁ ∈ set.Inter s) (h₂ : x₂ ∈ set.Inter s) =>
      iff.mpr set.mem_Inter
        fun (y : ι) => is_add_submonoid.add_mem (iff.mp set.mem_Inter h₁ y) (iff.mp set.mem_Inter h₂ y)

/-- The union of an indexed, directed, nonempty set of submonoids of a monoid `M` is a submonoid
    of `M`. -/
theorem is_add_submonoid_Union_of_directed {M : Type u_1} [add_monoid M] {ι : Type u_2} [hι : Nonempty ι] (s : ι → set M) [∀ (i : ι), is_add_submonoid (s i)] (directed : ∀ (i j : ι), ∃ (k : ι), s i ⊆ s k ∧ s j ⊆ s k) : is_add_submonoid (set.Union fun (i : ι) => s i) := sorry

/-- The set of natural number powers `1, x, x², ...` of an element `x` of a monoid. -/
/-- The set of natural number multiples `0, x, 2x, ...` of an element `x` of an `add_monoid`. -/
def powers {M : Type u_1} [monoid M] (x : M) : set M :=
  set_of fun (y : M) => ∃ (n : ℕ), x ^ n = y

def multiples {A : Type u_2} [add_monoid A] (x : A) : set A :=
  set_of fun (y : A) => ∃ (n : ℕ), n •ℕ x = y

/-- 1 is in the set of natural number powers of an element of a monoid. -/
theorem powers.one_mem {M : Type u_1} [monoid M] {x : M} : 1 ∈ powers x :=
  Exists.intro 0 (pow_zero x)

/-- 0 is in the set of natural number multiples of an element of an `add_monoid`. -/
theorem multiples.zero_mem {A : Type u_2} [add_monoid A] {x : A} : 0 ∈ multiples x :=
  Exists.intro 0 (zero_nsmul x)

/-- An element of a monoid is in the set of that element's natural number powers. -/
theorem powers.self_mem {M : Type u_1} [monoid M] {x : M} : x ∈ powers x :=
  Exists.intro 1 (pow_one x)

/-- An element of an `add_monoid` is in the set of that element's natural number multiples. -/
theorem multiples.self_mem {A : Type u_2} [add_monoid A] {x : A} : x ∈ multiples x :=
  Exists.intro 1 (one_nsmul x)

/-- The set of natural number powers of an element of a monoid is closed under multiplication. -/
theorem powers.mul_mem {M : Type u_1} [monoid M] {x : M} {y : M} {z : M} : y ∈ powers x → z ∈ powers x → y * z ∈ powers x := sorry

/-- The set of natural number multiples of an element of an `add_monoid` is closed under
    addition. -/
theorem multiples.add_mem {A : Type u_2} [add_monoid A] {x : A} {y : A} {z : A} : y ∈ multiples x → z ∈ multiples x → y + z ∈ multiples x :=
  powers.mul_mem

/-- The set of natural number powers of an element of a monoid `M` is a submonoid of `M`. -/
protected instance multiples.is_add_submonoid {M : Type u_1} [add_monoid M] (x : M) : is_add_submonoid (multiples x) :=
  is_add_submonoid.mk multiples.zero_mem fun (y z : M) => multiples.add_mem

/-- A monoid is a submonoid of itself. -/
protected instance univ.is_submonoid {M : Type u_1} [monoid M] : is_submonoid set.univ :=
  is_submonoid.mk (eq.mpr (id (propext ((fun {α : Type u_1} (x : α) => iff_true_intro (set.mem_univ x)) 1))) trivial)
    (eq.mpr
      (id
        (Eq.trans
          (Eq.trans
            (forall_congr_eq
              fun (a : M) =>
                forall_congr_eq
                  fun (b : M) =>
                    Eq.trans
                      (imp_congr_eq (propext ((fun {α : Type u_1} (x : α) => iff_true_intro (set.mem_univ x)) a))
                        (Eq.trans
                          (imp_congr_eq (propext ((fun {α : Type u_1} (x : α) => iff_true_intro (set.mem_univ x)) b))
                            (propext ((fun {α : Type u_1} (x : α) => iff_true_intro (set.mem_univ x)) (a * b))))
                          (propext (forall_prop_of_true True.intro))))
                      (propext (forall_prop_of_true True.intro)))
            (propext (forall_const M)))
          (propext (forall_const M))))
      trivial)

/-- The preimage of a submonoid under a monoid hom is a submonoid of the domain. -/
protected instance preimage.is_add_submonoid {M : Type u_1} [add_monoid M] {N : Type u_2} [add_monoid N] (f : M → N) [is_add_monoid_hom f] (s : set N) [is_add_submonoid s] : is_add_submonoid (f ⁻¹' s) :=
  is_add_submonoid.mk
    ((fun (this : f 0 ∈ s) => this)
      (eq.mpr (id (Eq._oldrec (Eq.refl (f 0 ∈ s)) (is_add_monoid_hom.map_zero f))) is_add_submonoid.zero_mem))
    fun (a b : M) (ha : f a ∈ s) (hb : f b ∈ s) =>
      (fun (this : f (a + b) ∈ s) => this)
        (eq.mpr (id (Eq._oldrec (Eq.refl (f (a + b) ∈ s)) (is_add_monoid_hom.map_add f a b)))
          (is_add_submonoid.add_mem ha hb))

/-- The image of a submonoid under a monoid hom is a submonoid of the codomain. -/
instance image.is_add_submonoid {M : Type u_1} [add_monoid M] {γ : Type u_2} [add_monoid γ] (f : M → γ) [is_add_monoid_hom f] (s : set M) [is_add_submonoid s] : is_add_submonoid (f '' s) := sorry

/-- The image of a monoid hom is a submonoid of the codomain. -/
protected instance range.is_add_submonoid {M : Type u_1} [add_monoid M] {γ : Type u_2} [add_monoid γ] (f : M → γ) [is_add_monoid_hom f] : is_add_submonoid (set.range f) :=
  eq.mpr (id (Eq._oldrec (Eq.refl (is_add_submonoid (set.range f))) (Eq.symm set.image_univ)))
    (image.is_add_submonoid f set.univ)

/-- Submonoids are closed under natural powers. -/
theorem is_submonoid.pow_mem {M : Type u_1} [monoid M] {s : set M} {a : M} [is_submonoid s] (h : a ∈ s) {n : ℕ} : a ^ n ∈ s := sorry

/-- An `add_submonoid` is closed under multiplication by naturals. -/
theorem is_add_submonoid.smul_mem {A : Type u_2} [add_monoid A] {t : set A} {a : A} [is_add_submonoid t] (h : a ∈ t) {n : ℕ} : n •ℕ a ∈ t :=
  is_submonoid.pow_mem

/-- The set of natural number powers of an element of a submonoid is a subset of the submonoid. -/
theorem is_submonoid.power_subset {M : Type u_1} [monoid M] {s : set M} {a : M} [is_submonoid s] (h : a ∈ s) : powers a ⊆ s := sorry

/-- The set of natural number multiples of an element of an `add_submonoid` is a subset of the
    `add_submonoid`. -/
theorem is_add_submonoid.multiple_subset {A : Type u_2} [add_monoid A] {t : set A} {a : A} [is_add_submonoid t] : a ∈ t → multiples a ⊆ t :=
  is_submonoid.power_subset

namespace is_submonoid


/-- The product of a list of elements of a submonoid is an element of the submonoid. -/
theorem list_prod_mem {M : Type u_1} [monoid M] {s : set M} [is_submonoid s] {l : List M} : (∀ (x : M), x ∈ l → x ∈ s) → list.prod l ∈ s := sorry

/-- The product of a multiset of elements of a submonoid of a `comm_monoid` is an element of
the submonoid. -/
theorem Mathlib.is_add_submonoid.multiset_sum_mem {M : Type u_1} [add_comm_monoid M] (s : set M) [is_add_submonoid s] (m : multiset M) : (∀ (a : M), a ∈ m → a ∈ s) → multiset.sum m ∈ s := sorry

/-- The product of elements of a submonoid of a `comm_monoid` indexed by a `finset` is an element
of the submonoid. -/
theorem finset_prod_mem {M : Type u_1} {A : Type u_2} [comm_monoid M] (s : set M) [is_submonoid s] (f : A → M) (t : finset A) : (∀ (b : A), b ∈ t → f b ∈ s) → (finset.prod t fun (b : A) => f b) ∈ s := sorry

end is_submonoid


-- TODO: modify `subtype_instance` to produce this definition, then use it here

--  and for `subtype.group`

/-- Submonoids are themselves monoids. -/
def subtype.add_monoid {M : Type u_1} [add_monoid M] {s : set M} [is_add_submonoid s] : add_monoid ↥s :=
  add_monoid.mk (fun (x y : ↥s) => { val := ↑x + ↑y, property := sorry }) sorry
    { val := 0, property := is_add_submonoid.zero_mem } sorry sorry

/-- Submonoids of commutative monoids are themselves commutative monoids. -/
def subtype.add_comm_monoid {M : Type u_1} [add_comm_monoid M] {s : set M} [is_add_submonoid s] : add_comm_monoid ↥s :=
  add_comm_monoid.mk add_monoid.add sorry add_monoid.zero sorry sorry sorry

/-- Submonoids inherit the 1 of the monoid. -/
@[simp] theorem is_submonoid.coe_one {M : Type u_1} [monoid M] {s : set M} [is_submonoid s] : ↑1 = 1 :=
  rfl

/-- Submonoids inherit the multiplication of the monoid. -/
@[simp] theorem is_add_submonoid.coe_add {M : Type u_1} [add_monoid M] {s : set M} [is_add_submonoid s] (a : ↥s) (b : ↥s) : ↑(a + b) = ↑a + ↑b :=
  rfl

/-- Submonoids inherit the exponentiation by naturals of the monoid. -/
@[simp] theorem is_submonoid.coe_pow {M : Type u_1} [monoid M] {s : set M} [is_submonoid s] (a : ↥s) (n : ℕ) : ↑(a ^ n) = ↑a ^ n := sorry

/-- An `add_submonoid` inherits the multiplication by naturals of the `add_monoid`. -/
@[simp] theorem is_add_submonoid.smul_coe {A : Type u_1} [add_monoid A] {s : set A} [is_add_submonoid s] (a : ↥s) (n : ℕ) : ↑(n •ℕ a) = n •ℕ ↑a := sorry

/-- The natural injection from a submonoid into the monoid is a monoid hom. -/
protected instance subtype_val.is_add_monoid_hom {M : Type u_1} [add_monoid M] {s : set M} [is_add_submonoid s] : is_add_monoid_hom subtype.val :=
  is_add_monoid_hom.mk rfl

/-- The natural injection from a submonoid into the monoid is a monoid hom. -/
protected instance coe.is_add_monoid_hom {M : Type u_1} [add_monoid M] {s : set M} [is_add_submonoid s] : is_add_monoid_hom coe :=
  subtype_val.is_add_monoid_hom

/-- Given a monoid hom `f : γ → M` whose image is contained in a submonoid `s`, the induced map
    from `γ` to `s` is a monoid hom. -/
protected instance subtype_mk.is_add_monoid_hom {M : Type u_1} [add_monoid M] {s : set M} {γ : Type u_2} [add_monoid γ] [is_add_submonoid s] (f : γ → M) [is_add_monoid_hom f] (h : ∀ (x : γ), f x ∈ s) : is_add_monoid_hom fun (x : γ) => { val := f x, property := h x } :=
  is_add_monoid_hom.mk (subtype.eq (is_add_monoid_hom.map_zero f))

/-- Given two submonoids `s` and `t` such that `s ⊆ t`, the natural injection from `s` into `t` is
    a monoid hom. -/
protected instance set_inclusion.is_monoid_hom {M : Type u_1} [monoid M] {s : set M} (t : set M) [is_submonoid s] [is_submonoid t] (h : s ⊆ t) : is_monoid_hom (set.inclusion h) :=
  subtype_mk.is_monoid_hom (fun (x : ↥s) => ↑x) fun (x : ↥s) => set.inclusion._proof_1 h x

namespace add_monoid


/-- The inductively defined membership predicate for the submonoid generated by a subset of a
    monoid. -/
inductive in_closure {A : Type u_2} [add_monoid A] (s : set A) : A → Prop
where
| basic : ∀ {a : A}, a ∈ s → in_closure s a
| zero : in_closure s 0
| add : ∀ {a b : A}, in_closure s a → in_closure s b → in_closure s (a + b)

end add_monoid


namespace monoid


/-- The inductively defined membership predicate for the `add_submonoid` generated by a subset of an
    add_monoid. -/
inductive in_closure {M : Type u_1} [monoid M] (s : set M) : M → Prop
where
| basic : ∀ {a : M}, a ∈ s → in_closure s a
| one : in_closure s 1
| mul : ∀ {a b : M}, in_closure s a → in_closure s b → in_closure s (a * b)

/-- The inductively defined submonoid generated by a subset of a monoid. -/
def Mathlib.add_monoid.closure {M : Type u_1} [add_monoid M] (s : set M) : set M :=
  set_of fun (a : M) => add_monoid.in_closure s a

protected instance Mathlib.add_monoid.closure.is_add_submonoid {M : Type u_1} [add_monoid M] (s : set M) : is_add_submonoid (add_monoid.closure s) :=
  is_add_submonoid.mk add_monoid.in_closure.zero fun (a b : M) => add_monoid.in_closure.add

/-- A subset of a monoid is contained in the submonoid it generates. -/
theorem Mathlib.add_monoid.subset_closure {M : Type u_1} [add_monoid M] {s : set M} : s ⊆ add_monoid.closure s :=
  fun (a : M) => add_monoid.in_closure.basic

/-- The submonoid generated by a set is contained in any submonoid that contains the set. -/
theorem Mathlib.add_monoid.closure_subset {M : Type u_1} [add_monoid M] {s : set M} {t : set M} [is_add_submonoid t] (h : s ⊆ t) : add_monoid.closure s ⊆ t := sorry

/-- Given subsets `t` and `s` of a monoid `M`, if `s ⊆ t`, the submonoid of `M` generated by `s` is
    contained in the submonoid generated by `t`. -/
theorem Mathlib.add_monoid.closure_mono {M : Type u_1} [add_monoid M] {s : set M} {t : set M} (h : s ⊆ t) : add_monoid.closure s ⊆ add_monoid.closure t :=
  add_monoid.closure_subset (set.subset.trans h add_monoid.subset_closure)

/-- The submonoid generated by an element of a monoid equals the set of natural number powers of
    the element. -/
theorem closure_singleton {M : Type u_1} [monoid M] {x : M} : closure (singleton x) = powers x :=
  set.eq_of_subset_of_subset (closure_subset (iff.mpr set.singleton_subset_iff powers.self_mem))
    (is_submonoid.power_subset (iff.mp set.singleton_subset_iff subset_closure))

/-- The image under a monoid hom of the submonoid generated by a set equals the submonoid generated
    by the image of the set under the monoid hom. -/
theorem Mathlib.add_monoid.image_closure {M : Type u_1} [add_monoid M] {A : Type u_2} [add_monoid A] (f : M → A) [is_add_monoid_hom f] (s : set M) : f '' add_monoid.closure s = add_monoid.closure (f '' s) := sorry

/-- Given an element `a` of the submonoid of a monoid `M` generated by a set `s`, there exists
a list of elements of `s` whose product is `a`. -/
theorem Mathlib.add_monoid.exists_list_of_mem_closure {M : Type u_1} [add_monoid M] {s : set M} {a : M} (h : a ∈ add_monoid.closure s) : ∃ (l : List M), (∀ (x : M), x ∈ l → x ∈ s) ∧ list.sum l = a := sorry

/-- Given sets `s, t` of a commutative monoid `M`, `x ∈ M` is in the submonoid of `M` generated by
    `s ∪ t` iff there exists an element of the submonoid generated by `s` and an element of the
    submonoid generated by `t` whose product is `x`. -/
theorem Mathlib.add_monoid.mem_closure_union_iff {M : Type u_1} [add_comm_monoid M] {s : set M} {t : set M} {x : M} : x ∈ add_monoid.closure (s ∪ t) ↔
  ∃ (y : M), ∃ (H : y ∈ add_monoid.closure s), ∃ (z : M), ∃ (H : z ∈ add_monoid.closure t), y + z = x := sorry

end monoid


/-- Create a bundled submonoid from a set `s` and `[is_submonoid s]`. -/
def add_submonoid.of {M : Type u_1} [add_monoid M] (s : set M) [h : is_add_submonoid s] : add_submonoid M :=
  add_submonoid.mk s is_add_submonoid.zero_mem is_add_submonoid.add_mem

protected instance submonoid.is_submonoid {M : Type u_1} [monoid M] (S : submonoid M) : is_submonoid ↑S :=
  is_submonoid.mk (submonoid.one_mem' S) (submonoid.mul_mem' S)

